<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://owasp-sbot.github.io/OSBot-Utils/llm-briefs/features/v3.71.1__semantic-graphs__llm-usage-brief/" />
      <link rel="shortcut icon" href="../../../img/favicon.ico" />
    <title>Semantic Graphs - LLM Usage Brief - OSBot-Utils Documentation</title>
    <link rel="stylesheet" href="../../../css/theme.css" />
    <link rel="stylesheet" href="../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Semantic Graphs - LLM Usage Brief";
        var mkdocs_page_input_path = "llm-briefs/features/v3.71.1__semantic-graphs__llm-usage-brief.md";
        var mkdocs_page_url = "/OSBot-Utils/llm-briefs/features/v3.71.1__semantic-graphs__llm-usage-brief/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../.." class="icon icon-home"> OSBot-Utils Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Code</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" >OSBot Utils</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" >Helpers</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../../code/osbot_utils/helpers/flows/osbot-utils-flow-system-documentation/">Flows</a>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Development</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../../dev/Python-code-formatting-guidelines/">Coding Guidelines</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Type Safety</a>
    <ul>
                <li class="toctree-l2"><a class="" href="../../../dev/type_safe/python-type-safety-frameworks-compared.md">Frameworks Compared</a>
                </li>
                <li class="toctree-l2"><a class="" href="../../../dev/type_safe/type-safe-technical-documentation.md">Technical Documentation</a>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../..">OSBot-Utils Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Semantic Graphs - LLM Usage Brief</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="semantic-graphs-llm-usage-brief">Semantic Graphs - LLM Usage Brief<a class="headerlink" href="#semantic-graphs-llm-usage-brief" title="Permanent link">&para;</a></h1>
<p><strong>Version</strong>: v3.70.x<br />
<strong>Purpose</strong>: Guide for LLMs and developers on building and working with semantic graphs (knowledge graphs)<br />
<strong>Location</strong>: <code>osbot_utils.helpers.semantic_graphs</code><br />
<strong>Repo</strong>: https://github.com/owasp-sbot/OSBot-Utils<br />
<strong>Install</strong>: <code>pip install osbot-utils</code></p>
<hr />
<h2 id="what-are-semantic-graphs">What are Semantic Graphs?<a class="headerlink" href="#what-are-semantic-graphs" title="Permanent link">&para;</a></h2>
<p><strong>Semantic Graphs is a comprehensive, type-safe framework for building, validating, and projecting knowledge graphs in Python.</strong> It provides a rigorous schema layer for defining graph structures (nodes, edges, properties), ontologies that constrain what's valid, taxonomies for categorizing concepts, and business logic utilities that operate on this data.</p>
<p>Instead of building ad-hoc graph structures with dictionaries, writing custom validation code, and manually tracking relationships, you get a complete system with runtime type safety, automatic validation against ontology rules, and human-readable projections for debugging and export.</p>
<h3 id="the-problem-it-solves">The Problem It Solves<a class="headerlink" href="#the-problem-it-solves" title="Permanent link">&para;</a></h3>
<p>When building knowledge graphs or semantic models, you typically need to:
- Define what kinds of nodes and relationships are valid
- Enforce type constraints on graph structure
- Validate that edges follow domain rules (e.g., "methods can call functions, but not packages")
- Add properties to nodes and edges with type validation
- Generate human-readable outputs for debugging
- Maintain referential integrity between IDs</p>
<p>Without a framework, this leads to fragile, error-prone code:</p>
<pre><code class="language-python"># Without Semantic Graphs - ad-hoc and dangerous
graph = {
    'nodes': [
        {'id': 'n1', 'type': 'class', 'name': 'MyClass'},
        {'id': 'n2', 'type': 'methd', 'name': 'foo'},  # Typo: 'methd'
    ],
    'edges': [
        {'from': 'n1', 'to': 'n2', 'rel': 'contains'},
        {'from': 'n1', 'to': 'n99', 'rel': 'calls'},   # n99 doesn't exist!
    ]
}

# No validation, no type safety, no constraints
# Errors discovered deep in processing, not at creation time
</code></pre>
<p><strong>With Semantic Graphs:</strong></p>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Builder   import Semantic_Graph__Builder
from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Validator import Semantic_Graph__Validator
from osbot_utils.helpers.semantic_graphs.ontology.Ontology__Registry     import Ontology__Registry

# Build graph with type-safe builder
builder = Semantic_Graph__Builder()
builder.with_ontology_id(my_ontology.ontology_id)
builder.add_node_with_seed(node_type_id = nt_class_id                    ,
                           name         = Safe_Str__Id      ('MyClass')  ,
                           seed         = Safe_Str__Id__Seed('my-class' ))
builder.add_node_with_seed(node_type_id = nt_method_id                   ,
                           name         = Safe_Str__Id      ('foo')      ,
                           seed         = Safe_Str__Id__Seed('my-method'))

graph = builder.build()

# Validate against ontology rules
validator = Semantic_Graph__Validator()
result    = validator.validate(graph, ontology)
if result.valid is False:
    print(result.errors)  # Clear error messages
</code></pre>
<h3 id="design-philosophy">Design Philosophy<a class="headerlink" href="#design-philosophy" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Schemas are pure data</strong> — Schema classes contain only type annotations, never methods</li>
<li><strong>Business logic is separate</strong> — Utils, Validators, and Builders contain all operations</li>
<li><strong>IDs vs Refs</strong> — Internal identifiers (IDs) for integrity, human-readable labels (Refs) for display</li>
<li><strong>Deterministic reproducibility</strong> — Generate consistent IDs from seeds for testing and versioning</li>
<li><strong>Ontology-driven validation</strong> — Edge rules define what's valid; validators enforce it</li>
<li><strong>Type-safe throughout</strong> — Runtime type checking on every operation via Type_Safe</li>
<li><strong>Projections for humans</strong> — Transform internal schemas to human-readable formats</li>
</ol>
<h3 id="key-capabilities">Key Capabilities<a class="headerlink" href="#key-capabilities" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Schema-based graph modeling</strong> — Type-safe nodes, edges, and properties</li>
<li><strong>Ontology definitions</strong> — Define valid node types, predicates, and edge rules</li>
<li><strong>Taxonomy hierarchies</strong> — Categorize node types into hierarchical structures</li>
<li><strong>Rule sets</strong> — Enforce cardinality, transitivity, and required property rules</li>
<li><strong>Fluent builder API</strong> — Construct graphs with method chaining</li>
<li><strong>Deterministic IDs</strong> — Generate reproducible identifiers from seeds</li>
<li><strong>Validation engine</strong> — Validate graphs against ontology constraints</li>
<li><strong>Human-readable projections</strong> — Transform IDs to refs for export and debugging</li>
<li><strong>Property support</strong> — Attach typed key-value properties to nodes and edges</li>
</ul>
<hr />
<h2 id="how-it-works-system-architecture">How It Works: System Architecture<a class="headerlink" href="#how-it-works-system-architecture" title="Permanent link">&para;</a></h2>
<h3 id="high-level-component-overview">High-Level Component Overview<a class="headerlink" href="#high-level-component-overview" title="Permanent link">&para;</a></h3>
<p>The Semantic Graphs framework consists of five major subsystems that work together:</p>
<pre><code>┌─────────────────────────────────────────────────────────────────────────────────┐
│                           SEMANTIC GRAPHS FRAMEWORK                             │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐              │
│  │    TAXONOMY     │    │    ONTOLOGY     │    │    RULE SET     │              │
│  │   (Categories)  │◄───│  (Vocabulary)   │───►│  (Constraints)  │              │
│  │                 │    │                 │    │                 │              │
│  │ • Category tree │    │ • Node types    │    │ • Cardinality   │              │
│  │ • Hierarchies   │    │ • Predicates    │    │ • Transitivity  │              │
│  │ • Inheritance   │    │ • Edge rules    │    │ • Required props│              │
│  └────────┬────────┘    │ • Properties    │    └────────┬────────┘              │
│           │             └────────┬────────┘             │                       │
│           │                      │                      │                       │
│           ▼                      ▼                      ▼                       │
│  ┌────────────────────────────────────────────────────────────────────┐         │
│  │                      SEMANTIC GRAPH                                │         │
│  │                      (Instance Data)                               │         │
│  │                                                                    │         │
│  │   ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐         │         │
│  │   │  Node   │───►│  Edge   │───►│  Node   │    │Properties│        │         │
│  │   │ (class) │    │(contains│    │(method) │    │(metadata)│        │         │
│  │   └─────────┘    └─────────┘    └─────────┘    └─────────┘         │         │
│  └────────────────────────────────────────────────────────────────────┘         │
│                                      │                                          │
│                                      ▼                                          │
│  ┌────────────────────────────────────────────────────────────────────┐         │
│  │                        PROJECTION                                  │         │
│  │                   (Human-Readable View)                            │         │
│  │                                                                    │         │
│  │   IDs ──────► Refs    │    Internal ──────► Export-Ready           │         │
│  │   abc123 ──► &quot;class&quot;  │    Schema__ ──────► Projected__            │         │
│  └────────────────────────────────────────────────────────────────────┘         │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="the-four-pillars">The Four Pillars<a class="headerlink" href="#the-four-pillars" title="Permanent link">&para;</a></h3>
<pre><code>┌───────────────────────────────────────────────────────────────────────────────┐
│                         THE FOUR PILLARS                                      │
├───────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│   TAXONOMY              ONTOLOGY              GRAPH                PROJECTION │
│   ════════              ════════              ═════                ══════════ │
│                                                                               │
│   Categories            Vocabulary            Instance Data        Human View │
│   ──────────            ──────────            ─────────────        ────────── │
│   &quot;What kinds          &quot;What terms           &quot;The actual          &quot;Readable   │
│    of things            exist in our          nodes, edges,        format for │
│    exist?&quot;              domain?&quot;              and data&quot;            export&quot;    │
│                                                                               │
│   ┌───────────┐        ┌─────────┐          ┌─────────┐          ┌─────────┐  │
│   │code_elem  │        │ class   │          │ MyClass │          │ &quot;class&quot; │  │
│   │    │      │        │ method  │          │   │     │          │&quot;MyClass&quot;│  │
│   │ ┌──┴──┐   │        │ func    │          │   ▼     │          │    │    │  │
│   │ │     │   │        │contains │          │  foo    │          │    ▼    │  │
│   │call  cont │        │ calls   │          │  bar    │          │&quot;method&quot; │  │
│   │able  ainer│        │ uses    │          └─────────┘          │ &quot;foo&quot;   │  │
│   └───────────┘        └─────────┘                               └─────────┘  │
│                                                                               │
│   Taxonomy__           Ontology__            Semantic_Graph__     Projector   │
│   Registry             Registry              Builder/Utils        project()   │
│                                                                               │
└───────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="data-flow-from-definition-to-projection">Data Flow: From Definition to Projection<a class="headerlink" href="#data-flow-from-definition-to-projection" title="Permanent link">&para;</a></h3>
<pre><code>┌─────────────────────────────────────────────────────────────────────────────────┐
│                           DATA FLOW OVERVIEW                                    │
└─────────────────────────────────────────────────────────────────────────────────┘

     DEFINITION PHASE                    BUILD PHASE                 OUTPUT PHASE
     ════════════════                    ═══════════                 ════════════

  ┌──────────────────┐              ┌──────────────────┐         ┌──────────────────┐
  │  1. TAXONOMY     │              │  4. GRAPH        │         │  6. VALIDATION   │
  │                  │              │     BUILDER      │         │                  │
  │  Define category │              │                  │         │  Check graph     │
  │  hierarchies     │              │  Construct nodes │         │  against ontology│
  │                  │              │  and edges       │         │  edge rules      │
  └────────┬─────────┘              └────────┬─────────┘         └────────┬─────────┘
           │                                 │                            │
           ▼                                 ▼                            ▼
  ┌──────────────────┐              ┌──────────────────┐         ┌──────────────────┐
  │  2. ONTOLOGY     │              │  5. SCHEMA       │         │  7. PROJECTION   │
  │                  │─────────────►│     GRAPH        │────────►│                  │
  │  Define node     │  references  │                  │         │  Transform IDs   │
  │  types, preds,   │              │  Type-safe       │         │  to human-       │
  │  edge rules      │              │  instance data   │         │  readable refs   │
  └────────┬─────────┘              └──────────────────┘         └────────┬─────────┘
           │                                                              │
           ▼                                                              ▼
  ┌──────────────────┐                                           ┌──────────────────┐
  │  3. RULE SET     │                                           │  8. EXPORT       │
  │                  │                                           │                  │
  │  Define property │                                           │  JSON, Vis.js,   │
  │  requirements,   │                                           │  Cytoscape,      │
  │  cardinality     │                                           │  Mermaid, etc.   │
  └──────────────────┘                                           └──────────────────┘
</code></pre>
<h3 id="the-idref-duality-system">The ID/Ref Duality System<a class="headerlink" href="#the-idref-duality-system" title="Permanent link">&para;</a></h3>
<p>A core concept in Semantic Graphs is the separation between internal IDs and human-readable Refs:</p>
<pre><code>┌────────────────────────────────────────────────────────────────────────────────────┐
│                            ID vs REF DUALITY                                       │
├────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                    │
│                    ID (Internal)                    REF (Human)                    │
│                    ═════════════                    ═══════════                    │
│                                                                                    │
│   Node_Type_Id     &quot;a7b3c9d2e1f4...&quot;               Node_Type_Ref    &quot;class&quot;        │
│   Predicate_Id     &quot;x8y2z6w4v5u3...&quot;               Predicate_Ref    &quot;contains&quot;     │
│   Category_Id      &quot;m1n2o3p4q5r6...&quot;               Category_Ref     &quot;callable&quot;     │
│   Ontology_Id      &quot;i9j8k7l6m5n4...&quot;               Ontology_Ref     &quot;code_analysis&quot;│
│                                                                                    │
│   ┌─────────────────────────────────────────────────────────────────────────────┐  │
│   │                                                                             │  │
│   │   SCHEMA__ (Internal Storage)          PROJECTED__ (Human Output)           │  │
│   │   ─────────────────────────           ───────────────────────────           │  │
│   │                                                                             │  │
│   │   node_type_id: &quot;a7b3c9d2...&quot;    ───►    ref: &quot;class&quot;                       │  │
│   │   predicate_id: &quot;x8y2z6w4...&quot;    ───►    ref: &quot;contains&quot;                    │  │
│   │   from_node_id: &quot;node123...&quot;     ───►    from_name: &quot;MyClass&quot;               │  │
│   │   to_node_id:   &quot;node456...&quot;     ───►    to_name: &quot;process&quot;                 │  │
│   │                                                                             │  │
│   └─────────────────────────────────────────────────────────────────────────────┘  │
│                                                                                    │
│   WHY TWO SYSTEMS?                                                                 │
│   ────────────────                                                                 │
│                                                                                    │
│   • IDs: Guaranteed unique, enable foreign keys, support versioning                │
│   • Refs: Human-readable, used in config files, shown in exports                   │
│   • Deterministic IDs: Same seed → same ID (reproducible builds)                   │
│   • Projector: Transforms ID-based schemas to ref-based output                     │
│                                                                                    │
└────────────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="schema-vs-logic-separation">Schema vs Logic Separation<a class="headerlink" href="#schema-vs-logic-separation" title="Permanent link">&para;</a></h3>
<pre><code>┌─────────────────────────────────────────────────────────────────────────────────┐
│                       SCHEMA vs LOGIC SEPARATION                                │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│   ┌─────────────────────────────┐    ┌─────────────────────────────┐            │
│   │      SCHEMA CLASSES         │    │      LOGIC CLASSES          │            │
│   │      (Pure Data)            │    │      (Operations)           │            │
│   ├─────────────────────────────┤    ├─────────────────────────────┤            │
│   │                             │    │                             │            │
│   │ Schema__Semantic_Graph      │    │ Semantic_Graph__Builder     │            │
│   │   • graph_id                │    │   • add_node()              │            │
│   │   • ontology_id             │    │   • add_edge()              │            │
│   │   • nodes                   │    │   • build()                 │            │
│   │   • edges                   │    │                             │            │
│   │                             │    │ Semantic_Graph__Utils       │            │
│   │ Schema__Ontology            │    │   • get_node()              │            │
│   │   • node_types              │    │   • neighbors()             │            │
│   │   • predicates              │    │   • has_edge()              │            │
│   │   • edge_rules              │    │                             │            │
│   │                             │    │ Semantic_Graph__Validator   │            │
│   │ Schema__Taxonomy            │    │   • validate()              │            │
│   │   • categories              │    │   • validate_edges()        │            │
│   │   • root_id                 │    │                             │            │
│   │                             │    │ Ontology__Utils             │            │
│   │                             │    │   • create_node_type()      │            │
│   │   ❌ NO METHODS!            │    │   • is_valid_edge()         │            │
│   │                             │    │                             │            │
│   └─────────────────────────────┘    └─────────────────────────────┘            │
│                                                                                 │
│   WHY SEPARATE?                                                                 │
│   ─────────────                                                                 │
│                                                                                 │
│   • Schemas serialize cleanly to JSON (no method baggage)                       │
│   • Single Responsibility: schemas describe, logic operates                     │
│   • Easy to swap logic implementations without changing data                    │
│   • Testable: logic classes can be unit tested independently                    │
│   • Type_Safe enforces this at runtime                                          │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="complete-workflow-building-a-code-analysis-graph">Complete Workflow: Building a Code Analysis Graph<a class="headerlink" href="#complete-workflow-building-a-code-analysis-graph" title="Permanent link">&para;</a></h3>
<pre><code>┌────────────────────────────────────────────────────────────────────────────────────┐
│              COMPLETE WORKFLOW: CODE ANALYSIS GRAPH                                │
├────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                    │
│   STEP 1: Define Taxonomy (Category Hierarchy)                                     │
│   ═══════════════════════════════════════════                                      │
│                                                                                    │
│                        code_element (root)                                         │
│                              │                                                     │
│              ┌───────────────┼───────────────┐                                     │
│              ▼               ▼               ▼                                     │
│          callable       container          data                                    │
│           │   │            │   │            │                                      │
│           ▼   ▼            ▼   ▼            ▼                                      │
│       method function   class module    variable                                   │
│                                                                                    │
│   STEP 2: Define Ontology (Vocabulary + Rules)                                     │
│   ════════════════════════════════════════════                                     │
│                                                                                    │
│   Node Types:    class, method, function, module, variable                         │
│   Predicates:    contains/contained_by, calls/called_by, uses/used_by              │
│   Properties:    line_number (int), is_async (bool), docstring (str)               │
│                                                                                    │
│   Edge Rules:                                                                      │
│   ┌────────────┬────────────┬────────────┐                                         │
│   │  Source    │  Predicate │  Target    │                                         │
│   ├────────────┼────────────┼────────────┤                                         │
│   │  module    │  contains  │  class     │                                         │
│   │  module    │  contains  │  function  │                                         │
│   │  class     │  contains  │  method    │                                         │
│   │  method    │  calls     │  function  │                                         │
│   │  method    │  calls     │  method    │                                         │
│   │  function  │  uses      │  variable  │                                         │
│   └────────────┴────────────┴────────────┘                                         │
│                                                                                    │
│   STEP 3: Build Graph Instance                                                     │
│   ════════════════════════════                                                     │
│                                                                                    │
│   builder = Semantic_Graph__Builder()                                              │
│   builder.with_ontology_id(ontology.ontology_id)                                   │
│                                                                                    │
│   # Add nodes with properties                                                      │
│   builder.add_node_with_seed(nt_module, &quot;main&quot;,    seed_1, props={line: 1})        │
│   builder.add_node_with_seed(nt_class,  &quot;Parser&quot;,  seed_2, props={line: 10})       │
│   builder.add_node_with_seed(nt_method, &quot;parse&quot;,   seed_3, props={line: 15})       │
│   builder.add_node_with_seed(nt_func,   &quot;helper&quot;,  seed_4, props={line: 50})       │
│                                                                                    │
│   # Add edges                                                                      │
│   builder.add_edge(main_id,   contains_id, parser_id)                              │
│   builder.add_edge(parser_id, contains_id, parse_id)                               │
│   builder.add_edge(parse_id,  calls_id,    helper_id)                              │
│                                                                                    │
│   graph = builder.build()                                                          │
│                                                                                    │
│   RESULT:                                                                          │
│   ┌─────────────────────────────────────────────────────────────┐                  │
│   │                                                             │                  │
│   │    ┌──────────┐                                             │                  │
│   │    │  main    │ (module)                                    │                  │
│   │    │  line: 1 │                                             │                  │
│   │    └────┬─────┘                                             │                  │
│   │         │ contains                                          │                  │
│   │         ▼                                                   │                  │
│   │    ┌──────────┐         ┌──────────┐                        │                  │
│   │    │  Parser  │ ──────► │  helper  │                        │                  │
│   │    │ (class)  │ contains│(function)│                        │                  │
│   │    │ line: 10 │         │ line: 50 │                        │                  │
│   │    └────┬─────┘         └────▲─────┘                        │                  │
│   │         │ contains              │ calls                     │                  │
│   │         ▼                       │                           │                  │
│   │    ┌──────────┐                 │                           │                  │
│   │    │  parse   │─────────────────┘                           │                  │
│   │    │ (method) │                                             │                  │
│   │    │ line: 15 │                                             │                  │
│   │    └──────────┘                                             │                  │
│   │                                                             │                  │
│   └─────────────────────────────────────────────────────────────┘                  │
│                                                                                    │
│   STEP 4: Validate                                                                 │
│   ════════════════                                                                 │
│                                                                                    │
│   validator = Semantic_Graph__Validator()                                          │
│   result = validator.validate(graph, ontology)                                     │
│                                                                                    │
│   ✓ All node types exist in ontology                                               │
│   ✓ All predicates exist in ontology                                               │
│   ✓ All edges match edge rules                                                     │
│   ✓ result.valid == True                                                           │
│                                                                                    │
│   STEP 5: Project for Export                                                       │
│   ══════════════════════════                                                       │
│                                                                                    │
│   projector = Semantic_Graph__Projector(ontology_registry, taxonomy_registry)      │
│   projection = projector.project(graph)                                            │
│                                                                                    │
│   OUTPUT (Human-Readable):                                                         │
│   {                                                                                │
│     &quot;projection&quot;: {                                                                │
│       &quot;nodes&quot;: [                                                                   │
│         {&quot;ref&quot;: &quot;module&quot;,   &quot;name&quot;: &quot;main&quot;,   &quot;properties&quot;: {&quot;line_number&quot;: &quot;1&quot;}}, │
│         {&quot;ref&quot;: &quot;class&quot;,    &quot;name&quot;: &quot;Parser&quot;, &quot;properties&quot;: {&quot;line_number&quot;: &quot;10&quot;}},│
│         {&quot;ref&quot;: &quot;method&quot;,   &quot;name&quot;: &quot;parse&quot;,  &quot;properties&quot;: {&quot;line_number&quot;: &quot;15&quot;}},│
│         {&quot;ref&quot;: &quot;function&quot;, &quot;name&quot;: &quot;helper&quot;, &quot;properties&quot;: {&quot;line_number&quot;: &quot;50&quot;}} │
│       ],                                                                           │
│       &quot;edges&quot;: [                                                                   │
│         {&quot;from_name&quot;: &quot;main&quot;,   &quot;ref&quot;: &quot;contains&quot;, &quot;to_name&quot;: &quot;Parser&quot;},           │
│         {&quot;from_name&quot;: &quot;Parser&quot;, &quot;ref&quot;: &quot;contains&quot;, &quot;to_name&quot;: &quot;parse&quot;},            │
│         {&quot;from_name&quot;: &quot;parse&quot;,  &quot;ref&quot;: &quot;calls&quot;,    &quot;to_name&quot;: &quot;helper&quot;}            │
│       ]                                                                            │
│     },                                                                             │
│     &quot;taxonomy&quot;: {                                                                  │
│       &quot;node_type_categories&quot;: {&quot;class&quot;: &quot;container&quot;, &quot;method&quot;: &quot;callable&quot;, ...},   │
│       &quot;category_parents&quot;: {&quot;callable&quot;: &quot;code_element&quot;, &quot;container&quot;: &quot;code_element&quot;}│
│     }                                                                              │
│   }                                                                                │
│                                                                                    │
└────────────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="validation-flow-detail">Validation Flow Detail<a class="headerlink" href="#validation-flow-detail" title="Permanent link">&para;</a></h3>
<pre><code>┌─────────────────────────────────────────────────────────────────────────────────┐
│                          VALIDATION FLOW                                        │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│                    ┌───────────────────────┐                                    │
│                    │   Semantic_Graph__    │                                    │
│                    │     Validator         │                                    │
│                    └───────────┬───────────┘                                    │
│                                │                                                │
│              ┌─────────────────┼─────────────────┐                              │
│              ▼                 ▼                 ▼                              │
│   ┌───────────────────┐ ┌───────────────────┐ ┌───────────────────┐             │
│   │  validate_nodes() │ │  validate_edges() │ │  validate_edges   │             │
│   │                   │ │                   │ │  _against_rules() │             │
│   └─────────┬─────────┘ └─────────┬─────────┘ └─────────┬─────────┘             │
│             │                     │                     │                       │
│             ▼                     ▼                     ▼                       │
│   ┌───────────────────┐ ┌───────────────────┐ ┌───────────────────┐             │
│   │ For each node:    │ │ For each edge:    │ │ For each edge:    │             │
│   │                   │ │                   │ │                   │             │
│   │ • node_type_id    │ │ • from_node_id    │ │ • Get source type │             │
│   │   exists in       │ │   exists?         │ │ • Get target type │             │
│   │   ontology?       │ │ • to_node_id      │ │ • Check edge_rules│             │
│   │                   │ │   exists?         │ │   for match       │             │
│   │ Error if not:     │ │ • predicate_id    │ │                   │             │
│   │ &quot;Unknown          │ │   exists in       │ │ Error if not:     │             │
│   │  node_type_id&quot;    │ │   ontology?       │ │ &quot;Invalid edge:    │             │
│   │                   │ │                   │ │  class --[calls]  │             │
│   │                   │ │ Error if not:     │ │  --&gt; package&quot;     │             │
│   │                   │ │ &quot;Unknown          │ │                   │             │
│   │                   │ │  predicate_id&quot;    │ │                   │             │
│   └───────────────────┘ └───────────────────┘ └───────────────────┘             │
│                                                                                 │
│                                    │                                            │
│                                    ▼                                            │
│                    ┌───────────────────────────────┐                            │
│                    │   Schema__Validation_Result   │                            │
│                    │                               │                            │
│                    │   valid: bool                 │                            │
│                    │   errors: List[str]           │                            │
│                    └───────────────────────────────┘                            │
│                                                                                 │
│   EDGE RULE MATCHING:                                                           │
│   ──────────────────                                                            │
│                                                                                 │
│   Edge: method --[calls]--&gt; function                                            │
│                                                                                 │
│   Check: Does any rule in ontology.edge_rules match?                            │
│                                                                                 │
│   Rule 1: class  --[contains]--&gt; method    ❌ No match                          │
│   Rule 2: method --[calls]   --&gt; method    ❌ No match (target differs)         │
│   Rule 3: method --[calls]   --&gt; function  ✓ MATCH!                             │
│                                                                                 │
│   Result: Edge is valid                                                         │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="projection-transformation-flow">Projection Transformation Flow<a class="headerlink" href="#projection-transformation-flow" title="Permanent link">&para;</a></h3>
<pre><code>┌─────────────────────────────────────────────────────────────────────────────────┐
│                       PROJECTION TRANSFORMATION                                 │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│   INPUT: Schema__Semantic_Graph (ID-based)                                      │
│   ════════════════════════════════════════                                      │
│                                                                                 │
│   graph.nodes = {                                                               │
│     Node_Id(&quot;abc123&quot;): Schema__Semantic_Graph__Node(                            │
│       node_id      = Node_Id(&quot;abc123&quot;),                                         │
│       node_type_id = Node_Type_Id(&quot;xyz789&quot;),     ◄── ID, not human-readable     │
│       name         = &quot;MyClass&quot;,                                                 │
│       properties   = {Property_Name_Id(&quot;prop1&quot;): &quot;42&quot;}                          │
│     )                                                                           │
│   }                                                                             │
│                                                                                 │
│   graph.edges = [                                                               │
│     Schema__Semantic_Graph__Edge(                                               │
│       from_node_id = Node_Id(&quot;abc123&quot;),          ◄── ID                         │
│       predicate_id = Predicate_Id(&quot;def456&quot;),     ◄── ID                         │
│       to_node_id   = Node_Id(&quot;ghi789&quot;)           ◄── ID                         │
│     )                                                                           │
│   ]                                                                             │
│                                                                                 │
│                              │                                                  │
│                              │  Semantic_Graph__Projector.project()             │
│                              │                                                  │
│                              │  1. Build ID → Ref lookup maps from ontology     │
│                              │  2. Build Node_Id → name lookup from graph       │
│                              │  3. Transform each node (type_id → type_ref)     │
│                              │  4. Transform each edge (node_ids → names)       │
│                              │  5. Build filtered references (only used refs)   │
│                              │  6. Build taxonomy section                       │
│                              ▼                                                  │
│                                                                                 │
│   OUTPUT: Schema__Projected__Semantic_Graph (Ref-based)                         │
│   ═════════════════════════════════════════════════════                         │
│                                                                                 │
│   projection.projection.nodes = [                                               │
│     Schema__Projected__Node(                                                    │
│       ref        = Node_Type_Ref(&quot;class&quot;),       ◄── Human-readable!            │
│       name       = &quot;MyClass&quot;,                                                   │
│       properties = {Property_Name_Ref(&quot;line_number&quot;): &quot;42&quot;}                     │
│     )                                                                           │
│   ]                                                                             │
│                                                                                 │
│   projection.projection.edges = [                                               │
│     Schema__Projected__Edge(                                                    │
│       from_name = &quot;MyClass&quot;,                     ◄── Name, not ID!              │
│       ref       = Predicate_Ref(&quot;contains&quot;),     ◄── Human-readable!            │
│       to_name   = &quot;process&quot;                      ◄── Name, not ID!              │
│     )                                                                           │
│   ]                                                                             │
│                                                                                 │
│   projection.references = {                      ◄── Correlation table          │
│     node_types: {&quot;class&quot;: &quot;xyz789&quot;, &quot;method&quot;: &quot;uvw123&quot;},                        │
│     predicates: {&quot;contains&quot;: &quot;def456&quot;, &quot;calls&quot;: &quot;stu987&quot;}                       │
│   }                                                                             │
│                                                                                 │
│   projection.taxonomy = {                        ◄── Category mapping           │
│     node_type_categories: {&quot;class&quot;: &quot;container&quot;, &quot;method&quot;: &quot;callable&quot;},         │
│     category_parents: {&quot;container&quot;: &quot;code_element&quot;, &quot;callable&quot;: &quot;code_element&quot;} │
│   }                                                                             │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="registry-pattern">Registry Pattern<a class="headerlink" href="#registry-pattern" title="Permanent link">&para;</a></h3>
<pre><code>┌─────────────────────────────────────────────────────────────────────────────────┐
│                          REGISTRY PATTERN                                       │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│   Registries provide dual-indexed storage for domain objects:                   │
│                                                                                 │
│   ┌──────────────────────────────────────────────────────────────────────────┐  │
│   │                     Ontology__Registry                                   │  │
│   │                                                                          │  │
│   │   ontologies_by_id:   Dict[Ontology_Id, Schema__Ontology]                │  │
│   │   ontologies_by_ref:  Dict[Ontology_Ref, Schema__Ontology]               │  │
│   │                                                                          │  │
│   │   ┌─────────────────────────────────────────────────────────────────┐    │  │
│   │   │                        DUAL INDEX                                │   │  │
│   │   │                                                                  │   │  │
│   │   │   by_id[&quot;a7b3c9...&quot;] ───┐                                        │   │  │
│   │   │                         ├───► Schema__Ontology(...)              │   │  │
│   │   │   by_ref[&quot;code_analysis&quot;] ──┘                                    │   │  │
│   │   │                                                                  │   │  │
│   │   │   get_by_id(Ontology_Id(&quot;a7b3c9...&quot;))   → Schema__Ontology       │   │  │
│   │   │   get_by_ref(Ontology_Ref(&quot;code_analysis&quot;)) → Schema__Ontology   │   │  │
│   │   │                                                                  │   │  │
│   │   └──────────────────────────────────────────────────────────────────┘   │  │
│   │                                                                          │  │
│   │   Factory Methods:                                                       │  │
│   │   ─────────────────                                                      │  │
│   │   create_with__random_id(ref, ...)        → Random Obj_Id                │  │
│   │   create_with__deterministic_id(ref, seed, ...) → Obj_Id.from_seed()     │  │
│   │   create_with__explicit_id(ref, id, ...)  → Use provided ID              │  │
│   │                                                                          │  │
│   └──────────────────────────────────────────────────────────────────────────┘  │
│                                                                                 │
│   Same pattern for: Taxonomy__Registry, Rule__Engine                            │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="property-system-architecture">Property System Architecture<a class="headerlink" href="#property-system-architecture" title="Permanent link">&para;</a></h3>
<pre><code>┌─────────────────────────────────────────────────────────────────────────────────┐
│                        PROPERTY SYSTEM                                          │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│   Properties allow attaching typed key-value data to nodes and edges.           │
│                                                                                 │
│   ONTOLOGY DEFINES:                                                             │
│   ═════════════════                                                             │
│                                                                                 │
│   Property Types (how values are interpreted):                                  │
│   ┌─────────────────────────────────────────┐                                   │
│   │ property_type_id │ property_type_ref    │                                   │
│   ├─────────────────────────────────────────┤                                   │
│   │ &quot;pt001...&quot;       │ &quot;integer&quot;            │                                   │
│   │ &quot;pt002...&quot;       │ &quot;boolean&quot;            │                                   │
│   │ &quot;pt003...&quot;       │ &quot;string&quot;             │                                   │
│   └─────────────────────────────────────────┘                                   │
│                                                                                 │
│   Property Names (what properties exist):                                       │
│   ┌──────────────────────────────────────────────────────────┐                  │
│   │ property_name_id │ property_name_ref │ property_type_id  │                  │
│   ├──────────────────────────────────────────────────────────┤                  │
│   │ &quot;pn001...&quot;       │ &quot;line_number&quot;     │ &quot;pt001...&quot; (int)  │                  │
│   │ &quot;pn002...&quot;       │ &quot;is_async&quot;        │ &quot;pt002...&quot; (bool) │                  │
│   │ &quot;pn003...&quot;       │ &quot;docstring&quot;       │ &quot;pt003...&quot; (str)  │                  │
│   └──────────────────────────────────────────────────────────┘                  │
│                                                                                 │
│   GRAPH INSTANCE USES:                                                          │
│   ════════════════════                                                          │
│                                                                                 │
│   Node with properties:                                                         │
│   ┌─────────────────────────────────────────────────────────────┐               │
│   │ Schema__Semantic_Graph__Node                                 │              │
│   │                                                              │              │
│   │   node_id:      Node_Id(&quot;node123...&quot;)                        │              │
│   │   node_type_id: Node_Type_Id(&quot;method...&quot;)                    │              │
│   │   name:         &quot;process&quot;                                    │              │
│   │   properties:   Dict__Node_Properties {                      │              │
│   │                   Property_Name_Id(&quot;pn001&quot;): &quot;42&quot;   ◄── Values are strings  │
│   │                   Property_Name_Id(&quot;pn002&quot;): &quot;true&quot;     (type in ontology)  │
│   │                 }                                            │              │
│   └─────────────────────────────────────────────────────────────┘               │
│                                                                                 │
│   PROJECTION TRANSFORMS:                                                        │
│   ══════════════════════                                                        │
│                                                                                 │
│   Property_Name_Id(&quot;pn001&quot;)  ───►  Property_Name_Ref(&quot;line_number&quot;)             │
│                                                                                 │
│   Projected node:                                                               │
│   { &quot;ref&quot;: &quot;method&quot;, &quot;name&quot;: &quot;process&quot;, &quot;properties&quot;: {&quot;line_number&quot;: &quot;42&quot;} }   │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<hr />
<h2 id="quick-start">Quick Start<a class="headerlink" href="#quick-start" title="Permanent link">&para;</a></h2>
<h3 id="creating-an-ontology">Creating an Ontology<a class="headerlink" href="#creating-an-ontology" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.ontology.Ontology__Registry                  import Ontology__Registry
from osbot_utils.helpers.semantic_graphs.ontology.Ontology__Utils                     import Ontology__Utils
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Ontology_Ref              import Ontology_Ref
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Node_Type_Ref             import Node_Type_Ref
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Predicate_Ref             import Predicate_Ref
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Id__Seed import Safe_Str__Id__Seed

# Create registry and utils
registry = Ontology__Registry()
utils    = Ontology__Utils()

# Create node types
nt_class  = utils.create_node_type(node_type_ref = Node_Type_Ref('class') ,
                                   seed          = Safe_Str__Id__Seed('nt-class'))
nt_method = utils.create_node_type(node_type_ref = Node_Type_Ref('method'),
                                   seed          = Safe_Str__Id__Seed('nt-method'))

# Create predicates
pred_contains, pred_contained_by = utils.create_predicate_pair(
    predicate_ref = Predicate_Ref('contains')   ,
    inverse_ref   = Predicate_Ref('contained_by'),
    seed          = Safe_Str__Id__Seed('pred-contains'),
    inverse_seed  = Safe_Str__Id__Seed('pred-contained-by'))

# Create edge rule: class --contains--&gt; method
edge_rule = utils.create_edge_rule(source_type_id = nt_class.node_type_id ,
                                   predicate_id   = pred_contains.predicate_id,
                                   target_type_id = nt_method.node_type_id)

# Register ontology
ontology = registry.create_with__deterministic_id(
    ontology_ref = Ontology_Ref('code_analysis'),
    seed         = Safe_Str__Id__Seed('ontology-code'))
ontology.node_types[nt_class.node_type_id]       = nt_class
ontology.node_types[nt_method.node_type_id]      = nt_method
ontology.predicates[pred_contains.predicate_id]  = pred_contains
ontology.edge_rules.append(edge_rule)
</code></pre>
<h3 id="building-a-graph">Building a Graph<a class="headerlink" href="#building-a-graph" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Builder          import Semantic_Graph__Builder
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Id import Safe_Str__Id

# Create builder
builder = Semantic_Graph__Builder()
builder.with_ontology_id(ontology.ontology_id)
builder.with_deterministic_graph_id(Safe_Str__Id__Seed('my-graph'))

# Add nodes
builder.add_node_with_seed(node_type_id = nt_class.node_type_id        ,
                           name         = Safe_Str__Id('MyClass')      ,
                           seed         = Safe_Str__Id__Seed('node-class'))

builder.add_node_with_seed(node_type_id = nt_method.node_type_id       ,
                           name         = Safe_Str__Id('process')      ,
                           seed         = Safe_Str__Id__Seed('node-method'))

# Get node IDs for edges
from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id import Obj_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Node_Id import Node_Id

class_node_id  = Node_Id(Obj_Id.from_seed(Safe_Str__Id__Seed('node-class')))
method_node_id = Node_Id(Obj_Id.from_seed(Safe_Str__Id__Seed('node-method')))

# Add edge
builder.add_edge(from_node_id = class_node_id             ,
                 predicate_id = pred_contains.predicate_id,
                 to_node_id   = method_node_id            )

# Build the graph
graph = builder.build()
</code></pre>
<h3 id="validating-a-graph">Validating a Graph<a class="headerlink" href="#validating-a-graph" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Validator import Semantic_Graph__Validator

validator = Semantic_Graph__Validator()
result    = validator.validate(graph, ontology)

if result.valid:
    print(&quot;Graph is valid!&quot;)
else:
    for error in result.errors:
        print(f&quot;Validation error: {error}&quot;)
</code></pre>
<h3 id="creating-a-projection">Creating a Projection<a class="headerlink" href="#creating-a-projection" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.projector.Semantic_Graph__Projector import Semantic_Graph__Projector

projector  = Semantic_Graph__Projector(ontology_registry = registry)
projection = projector.project(graph)

# Human-readable output
for node in projection.projection.nodes:
    print(f&quot;Node: {node.ref} - {node.name}&quot;)

for edge in projection.projection.edges:
    print(f&quot;Edge: {edge.from_name} --[{edge.ref}]--&gt; {edge.to_name}&quot;)
</code></pre>
<hr />
<h2 id="core-concepts">Core Concepts<a class="headerlink" href="#core-concepts" title="Permanent link">&para;</a></h2>
<h3 id="id-vs-ref-the-dual-identity-system">ID vs Ref: The Dual Identity System<a class="headerlink" href="#id-vs-ref-the-dual-identity-system" title="Permanent link">&para;</a></h3>
<p>Every entity in Semantic Graphs has two identifiers:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Purpose</th>
<th>Example</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ID</strong></td>
<td>Unique instance identifier</td>
<td><code>Node_Type_Id('abc123...')</code></td>
<td>Internal references, foreign keys</td>
</tr>
<tr>
<td><strong>Ref</strong></td>
<td>Human-readable label</td>
<td><code>Node_Type_Ref('class')</code></td>
<td>Display, configuration, debugging</td>
</tr>
</tbody>
</table>
<pre><code class="language-python"># ID: Machine-readable, unique per instance
node_type.node_type_id = Node_Type_Id(Obj_Id())           # Random: 'a1b2c3d4...'
node_type.node_type_id = Node_Type_Id(Obj_Id.from_seed('my-seed'))  # Deterministic

# Ref: Human-readable, defined once
node_type.node_type_ref = Node_Type_Ref('class')          # Display name

# Why both?
# - IDs provide referential integrity (foreign keys)
# - Refs enable human-readable projections
# - Deterministic IDs enable reproducible builds
</code></pre>
<h3 id="schema-vs-business-logic-separation">Schema vs Business Logic Separation<a class="headerlink" href="#schema-vs-business-logic-separation" title="Permanent link">&para;</a></h3>
<p><strong>CRITICAL</strong>: Schemas are pure data containers. All logic lives in Utils/Builders/Validators.</p>
<pre><code class="language-python"># ✗ WRONG - Logic in schema
class Schema__Ontology(Type_Safe):
    node_types : Dict__Node_Types__By_Id

    def is_valid_edge(self, source, pred, target):  # NO! Move to utils
        pass

# ✓ CORRECT - Schema is pure data
class Schema__Ontology(Type_Safe):
    node_types : Dict__Node_Types__By_Id
    predicates : Dict__Predicates__By_Id
    edge_rules : List__Edge_Rules

# ✓ CORRECT - Logic in separate utils class
class Ontology__Utils(Type_Safe):

    @type_safe
    def is_valid_edge(self                         ,
                      ontology       : Schema__Ontology,
                      source_type_id : Node_Type_Id    ,
                      predicate_id   : Predicate_Id    ,
                      target_type_id : Node_Type_Id    ) -&gt; bool:
        for rule in ontology.edge_rules:
            if (rule.source_type_id == source_type_id and
                rule.predicate_id   == predicate_id   and
                rule.target_type_id == target_type_id):
                return True
        return False
</code></pre>
<h3 id="deterministic-id-generation">Deterministic ID Generation<a class="headerlink" href="#deterministic-id-generation" title="Permanent link">&para;</a></h3>
<p>Generate reproducible IDs from seed strings for testing and versioning:</p>
<pre><code class="language-python">from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id import Obj_Id
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Id__Seed import Safe_Str__Id__Seed

# Random ID - different each time
random_id = Obj_Id()                                      # 'a1b2c3d4...' (random)

# Deterministic ID - same seed = same ID
seed = Safe_Str__Id__Seed('my-stable-seed')
det_id_1 = Obj_Id.from_seed(seed)                         # 'x7y8z9...'
det_id_2 = Obj_Id.from_seed(seed)                         # Same: 'x7y8z9...'

# Use cases:
# - Reproducible test data
# - Version-controlled ontologies
# - Idempotent graph construction
</code></pre>
<h3 id="property-system">Property System<a class="headerlink" href="#property-system" title="Permanent link">&para;</a></h3>
<p>Nodes and edges can have typed properties:</p>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.schemas.collection.Dict__Node_Properties import Dict__Node_Properties
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Property_Name_Id import Property_Name_Id
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Text import Safe_Str__Text

# Create property on a node
node_props = Dict__Node_Properties()
node_props[pn_line_number_id] = Safe_Str__Text('42')
node_props[pn_is_async_id]    = Safe_Str__Text('false')

builder.add_node_with_seed(node_type_id = nt_method_id             ,
                           name         = Safe_Str__Id('my_method'),
                           seed         = Safe_Str__Id__Seed('nm') ,
                           properties   = node_props               )

# Query properties
from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Utils import Semantic_Graph__Utils

utils = Semantic_Graph__Utils()
line  = utils.get_node_property(graph, node_id, pn_line_number_id)  # '42'
</code></pre>
<h3 id="edge-rules-and-validation">Edge Rules and Validation<a class="headerlink" href="#edge-rules-and-validation" title="Permanent link">&para;</a></h3>
<p>Ontologies define which edges are valid:</p>
<pre><code class="language-python"># Edge rule: class --contains--&gt; method
rule = Schema__Ontology__Edge_Rule(source_type_id = nt_class_id ,
                                   predicate_id   = pred_contains_id,
                                   target_type_id = nt_method_id)
ontology.edge_rules.append(rule)

# Validator checks all edges against rules
validator = Semantic_Graph__Validator()
result    = validator.validate(graph, ontology)

# Error example: &quot;Invalid edge: class --[calls]--&gt; package&quot;
</code></pre>
<h3 id="projections-schema-to-human-readable">Projections: Schema to Human-Readable<a class="headerlink" href="#projections-schema-to-human-readable" title="Permanent link">&para;</a></h3>
<p>Projections transform internal IDs to human-readable refs:</p>
<pre><code class="language-python"># Schema__ (internal)
{
    &quot;nodes&quot;: {&quot;abc123...&quot;: {&quot;node_type_id&quot;: &quot;xyz789...&quot;, &quot;name&quot;: &quot;MyClass&quot;}},
    &quot;edges&quot;: [{&quot;from_node_id&quot;: &quot;abc123...&quot;, &quot;predicate_id&quot;: &quot;def456...&quot;, ...}]
}

# Projected__ (human-readable)
{
    &quot;projection&quot;: {
        &quot;nodes&quot;: [{&quot;ref&quot;: &quot;class&quot;, &quot;name&quot;: &quot;MyClass&quot;}],
        &quot;edges&quot;: [{&quot;from_name&quot;: &quot;MyClass&quot;, &quot;ref&quot;: &quot;contains&quot;, &quot;to_name&quot;: &quot;process&quot;}]
    },
    &quot;references&quot;: {
        &quot;node_types&quot;: {&quot;class&quot;: &quot;xyz789...&quot;},
        &quot;predicates&quot;: {&quot;contains&quot;: &quot;def456...&quot;}
    }
}
</code></pre>
<hr />
<h2 id="architecture-overview">Architecture Overview<a class="headerlink" href="#architecture-overview" title="Permanent link">&para;</a></h2>
<h3 id="layer-structure">Layer Structure<a class="headerlink" href="#layer-structure" title="Permanent link">&para;</a></h3>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                         Testing Layer                            │
│  QA__Semantic_Graphs__Test_Data                                  │
├─────────────────────────────────────────────────────────────────┤
│                       Business Logic Layer                       │
│  Semantic_Graph__Builder    │  Ontology__Utils                  │
│  Semantic_Graph__Utils      │  Ontology__Registry               │
│  Semantic_Graph__Validator  │  Taxonomy__Utils                  │
│  Semantic_Graph__Projector  │  Taxonomy__Registry               │
│                             │  Rule__Engine / Rule_Set__Utils   │
├─────────────────────────────────────────────────────────────────┤
│                         Schema Layer                             │
│  Schema__Semantic_Graph     │  Schema__Ontology                 │
│  Schema__Semantic_Graph__Node│ Schema__Ontology__Node_Type      │
│  Schema__Semantic_Graph__Edge│ Schema__Ontology__Predicate      │
│  Schema__Validation_Result  │  Schema__Ontology__Edge_Rule      │
│                             │  Schema__Taxonomy                 │
│                             │  Schema__Rule_Set                 │
├─────────────────────────────────────────────────────────────────┤
│                       Identifier Layer                           │
│  Node_Id, Edge_Id, Graph_Id │  Node_Type_Id, Node_Type_Ref      │
│  Ontology_Id, Ontology_Ref  │  Predicate_Id, Predicate_Ref      │
│  Taxonomy_Id, Taxonomy_Ref  │  Property_Name_Id, Property_Name_Ref│
│  Category_Id, Category_Ref  │  Property_Type_Id, Property_Type_Ref│
├─────────────────────────────────────────────────────────────────┤
│                       Collection Layer                           │
│  Dict__Nodes__By_Id         │  List__Semantic_Graph__Edges      │
│  Dict__Node_Types__By_Id    │  List__Edge_Rules                 │
│  Dict__Predicates__By_Id    │  List__Validation_Errors          │
│  Dict__Categories__By_Id    │  Dict__Node_Properties            │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="key-classes-by-purpose">Key Classes by Purpose<a class="headerlink" href="#key-classes-by-purpose" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Purpose</th>
<th>Class</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Graph Building</strong></td>
<td><code>Semantic_Graph__Builder</code></td>
<td>Fluent API for constructing graphs</td>
</tr>
<tr>
<td><strong>Graph Queries</strong></td>
<td><code>Semantic_Graph__Utils</code></td>
<td>Query nodes, edges, neighbors, properties</td>
</tr>
<tr>
<td><strong>Graph Validation</strong></td>
<td><code>Semantic_Graph__Validator</code></td>
<td>Validate against ontology rules</td>
</tr>
<tr>
<td><strong>Graph Projection</strong></td>
<td><code>Semantic_Graph__Projector</code></td>
<td>Transform Schema__ to Projected__</td>
</tr>
<tr>
<td><strong>Ontology Management</strong></td>
<td><code>Ontology__Registry</code></td>
<td>Register and lookup ontologies</td>
</tr>
<tr>
<td><strong>Ontology Operations</strong></td>
<td><code>Ontology__Utils</code></td>
<td>Create node types, predicates, rules</td>
</tr>
<tr>
<td><strong>Taxonomy Management</strong></td>
<td><code>Taxonomy__Registry</code></td>
<td>Register and lookup taxonomies</td>
</tr>
<tr>
<td><strong>Taxonomy Operations</strong></td>
<td><code>Taxonomy__Utils</code></td>
<td>Navigate category hierarchies</td>
</tr>
<tr>
<td><strong>Rule Management</strong></td>
<td><code>Rule__Engine</code></td>
<td>Register and lookup rule sets</td>
</tr>
<tr>
<td><strong>Rule Validation</strong></td>
<td><code>Rule_Set__Utils</code></td>
<td>Validate property requirements</td>
</tr>
<tr>
<td><strong>Test Data</strong></td>
<td><code>QA__Semantic_Graphs__Test_Data</code></td>
<td>Factory for test fixtures</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="import-reference">Import Reference<a class="headerlink" href="#import-reference" title="Permanent link">&para;</a></h2>
<h3 id="core-graph-classes">Core Graph Classes<a class="headerlink" href="#core-graph-classes" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Builder   import Semantic_Graph__Builder
from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Utils     import Semantic_Graph__Utils
from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Validator import Semantic_Graph__Validator
</code></pre>
<h3 id="ontology-classes">Ontology Classes<a class="headerlink" href="#ontology-classes" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.ontology.Ontology__Registry     import Ontology__Registry
from osbot_utils.helpers.semantic_graphs.ontology.Ontology__Utils        import Ontology__Utils
</code></pre>
<h3 id="taxonomy-classes">Taxonomy Classes<a class="headerlink" href="#taxonomy-classes" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.taxonomy.Taxonomy__Registry     import Taxonomy__Registry
from osbot_utils.helpers.semantic_graphs.taxonomy.Taxonomy__Utils        import Taxonomy__Utils
</code></pre>
<h3 id="rule-classes">Rule Classes<a class="headerlink" href="#rule-classes" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.rule.Rule__Engine               import Rule__Engine
from osbot_utils.helpers.semantic_graphs.rule.Rule_Set__Utils            import Rule_Set__Utils
</code></pre>
<h3 id="projector">Projector<a class="headerlink" href="#projector" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.projector.Semantic_Graph__Projector import Semantic_Graph__Projector
</code></pre>
<h3 id="graph-schemas">Graph Schemas<a class="headerlink" href="#graph-schemas" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.schemas.graph.Schema__Semantic_Graph       import Schema__Semantic_Graph
from osbot_utils.helpers.semantic_graphs.schemas.graph.Schema__Semantic_Graph__Node import Schema__Semantic_Graph__Node
from osbot_utils.helpers.semantic_graphs.schemas.graph.Schema__Semantic_Graph__Edge import Schema__Semantic_Graph__Edge
from osbot_utils.helpers.semantic_graphs.schemas.graph.Schema__Validation_Result    import Schema__Validation_Result
</code></pre>
<h3 id="ontology-schemas">Ontology Schemas<a class="headerlink" href="#ontology-schemas" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.schemas.ontology.Schema__Ontology              import Schema__Ontology
from osbot_utils.helpers.semantic_graphs.schemas.ontology.Schema__Ontology__Node_Type   import Schema__Ontology__Node_Type
from osbot_utils.helpers.semantic_graphs.schemas.ontology.Schema__Ontology__Predicate   import Schema__Ontology__Predicate
from osbot_utils.helpers.semantic_graphs.schemas.ontology.Schema__Ontology__Edge_Rule   import Schema__Ontology__Edge_Rule
from osbot_utils.helpers.semantic_graphs.schemas.ontology.Schema__Ontology__Property_Name import Schema__Ontology__Property_Name
from osbot_utils.helpers.semantic_graphs.schemas.ontology.Schema__Ontology__Property_Type import Schema__Ontology__Property_Type
</code></pre>
<h3 id="taxonomy-schemas">Taxonomy Schemas<a class="headerlink" href="#taxonomy-schemas" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.schemas.taxonomy.Schema__Taxonomy             import Schema__Taxonomy
from osbot_utils.helpers.semantic_graphs.schemas.taxonomy.Schema__Taxonomy__Category   import Schema__Taxonomy__Category
</code></pre>
<h3 id="rule-schemas">Rule Schemas<a class="headerlink" href="#rule-schemas" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.schemas.rule.Schema__Rule_Set                     import Schema__Rule_Set
from osbot_utils.helpers.semantic_graphs.schemas.rule.Schema__Rule__Cardinality            import Schema__Rule__Cardinality
from osbot_utils.helpers.semantic_graphs.schemas.rule.Schema__Rule__Transitivity           import Schema__Rule__Transitivity
from osbot_utils.helpers.semantic_graphs.schemas.rule.Schema__Rule__Required_Node_Property import Schema__Rule__Required_Node_Property
from osbot_utils.helpers.semantic_graphs.schemas.rule.Schema__Rule__Required_Edge_Property import Schema__Rule__Required_Edge_Property
</code></pre>
<h3 id="projected-schemas">Projected Schemas<a class="headerlink" href="#projected-schemas" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.schemas.projected.Schema__Projected__Semantic_Graph import Schema__Projected__Semantic_Graph
from osbot_utils.helpers.semantic_graphs.schemas.projected.Schema__Projected__Node           import Schema__Projected__Node
from osbot_utils.helpers.semantic_graphs.schemas.projected.Schema__Projected__Edge           import Schema__Projected__Edge
from osbot_utils.helpers.semantic_graphs.schemas.projected.Schema__Projected__Data           import Schema__Projected__Data
from osbot_utils.helpers.semantic_graphs.schemas.projected.Schema__Projected__References     import Schema__Projected__References
from osbot_utils.helpers.semantic_graphs.schemas.projected.Schema__Projected__Taxonomy       import Schema__Projected__Taxonomy
</code></pre>
<h3 id="identifier-types">Identifier Types<a class="headerlink" href="#identifier-types" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># Instance IDs (unique per object)
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Ontology_Id      import Ontology_Id
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Taxonomy_Id      import Taxonomy_Id
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Node_Type_Id     import Node_Type_Id
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Predicate_Id     import Predicate_Id
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Category_Id      import Category_Id
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Property_Name_Id import Property_Name_Id
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Property_Type_Id import Property_Type_Id
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Rule_Set_Id      import Rule_Set_Id

# Human-readable Refs (labels)
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Ontology_Ref      import Ontology_Ref
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Taxonomy_Ref      import Taxonomy_Ref
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Node_Type_Ref     import Node_Type_Ref
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Predicate_Ref     import Predicate_Ref
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Category_Ref      import Category_Ref
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Property_Name_Ref import Property_Name_Ref
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Property_Type_Ref import Property_Type_Ref
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Rule_Set_Ref      import Rule_Set_Ref

# ID source tracking
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Schema__Id__Source import Schema__Id__Source
from osbot_utils.helpers.semantic_graphs.schemas.enum.Enum__Id__Source_Type    import Enum__Id__Source_Type
</code></pre>
<h3 id="collection-types">Collection Types<a class="headerlink" href="#collection-types" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># Node/Edge collections
from osbot_utils.helpers.semantic_graphs.schemas.collection.Dict__Nodes__By_Id          import Dict__Nodes__By_Id
from osbot_utils.helpers.semantic_graphs.schemas.collection.List__Semantic_Graph__Edges import List__Semantic_Graph__Edges
from osbot_utils.helpers.semantic_graphs.schemas.collection.List__Node_Ids              import List__Node_Ids

# Ontology collections
from osbot_utils.helpers.semantic_graphs.schemas.collection.Dict__Node_Types__By_Id     import Dict__Node_Types__By_Id
from osbot_utils.helpers.semantic_graphs.schemas.collection.Dict__Predicates__By_Id     import Dict__Predicates__By_Id
from osbot_utils.helpers.semantic_graphs.schemas.collection.Dict__Property_Names__By_Id import Dict__Property_Names__By_Id
from osbot_utils.helpers.semantic_graphs.schemas.collection.Dict__Property_Types__By_Id import Dict__Property_Types__By_Id
from osbot_utils.helpers.semantic_graphs.schemas.collection.List__Edge_Rules            import List__Edge_Rules

# Property collections
from osbot_utils.helpers.semantic_graphs.schemas.collection.Dict__Node_Properties       import Dict__Node_Properties
from osbot_utils.helpers.semantic_graphs.schemas.collection.Dict__Edge_Properties       import Dict__Edge_Properties
</code></pre>
<h3 id="test-data-factory">Test Data Factory<a class="headerlink" href="#test-data-factory" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.testing.QA__Semantic_Graphs__Test_Data import QA__Semantic_Graphs__Test_Data
</code></pre>
<h3 id="supporting-types">Supporting Types<a class="headerlink" href="#supporting-types" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.type_safe.Type_Safe                                                  import Type_Safe
from osbot_utils.type_safe.type_safe_core.decorators.type_safe                        import type_safe
from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id                      import Obj_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Node_Id                     import Node_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Edge_Id                     import Edge_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Graph_Id                    import Graph_Id
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Id       import Safe_Str__Id
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Id__Seed import Safe_Str__Id__Seed
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Text          import Safe_Str__Text
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Version       import Safe_Str__Version
</code></pre>
<hr />
<h2 id="api-reference-by-category">API Reference by Category<a class="headerlink" href="#api-reference-by-category" title="Permanent link">&para;</a></h2>
<h3 id="semantic_graph__builder-methods">Semantic_Graph__Builder Methods<a class="headerlink" href="#semantic_graph__builder-methods" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>with_ontology_id(id)</code></td>
<td>Set ontology for this graph</td>
<td><code>self</code> (fluent)</td>
</tr>
<tr>
<td><code>with_registry(registry)</code></td>
<td>Set registry for ref resolution</td>
<td><code>self</code> (fluent)</td>
</tr>
<tr>
<td><code>with_graph_id(id, source)</code></td>
<td>Set explicit graph ID</td>
<td><code>self</code> (fluent)</td>
</tr>
<tr>
<td><code>with_deterministic_graph_id(seed)</code></td>
<td>Set deterministic graph ID</td>
<td><code>self</code> (fluent)</td>
</tr>
<tr>
<td><code>add_node(type_id, name, ...)</code></td>
<td>Add node with ID</td>
<td><code>self</code> (fluent)</td>
</tr>
<tr>
<td><code>add_node_by_ref(type_ref, name, ...)</code></td>
<td>Add node, resolving type ref</td>
<td><code>self</code> (fluent)</td>
</tr>
<tr>
<td><code>add_node_with_seed(type_id, name, seed, ...)</code></td>
<td>Add node with deterministic ID</td>
<td><code>self</code> (fluent)</td>
</tr>
<tr>
<td><code>add_node_property(node_id, prop_id, value)</code></td>
<td>Add property to existing node</td>
<td><code>self</code> (fluent)</td>
</tr>
<tr>
<td><code>add_edge(from_id, pred_id, to_id, ...)</code></td>
<td>Add edge with IDs</td>
<td><code>self</code> (fluent)</td>
</tr>
<tr>
<td><code>add_edge_by_ref(from_id, pred_ref, to_id, ...)</code></td>
<td>Add edge, resolving predicate ref</td>
<td><code>self</code> (fluent)</td>
</tr>
<tr>
<td><code>add_edge_with_seed(from_id, pred_id, to_id, seed, ...)</code></td>
<td>Add edge with deterministic ID</td>
<td><code>self</code> (fluent)</td>
</tr>
<tr>
<td><code>add_edge_property(edge_id, prop_id, value)</code></td>
<td>Add property to existing edge</td>
<td><code>self</code> (fluent)</td>
</tr>
<tr>
<td><code>build()</code></td>
<td>Return completed graph</td>
<td><code>Schema__Semantic_Graph</code></td>
</tr>
</tbody>
</table>
<h3 id="semantic_graph__utils-methods">Semantic_Graph__Utils Methods<a class="headerlink" href="#semantic_graph__utils-methods" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>get_node(graph, node_id)</code></td>
<td>Get node by ID</td>
<td><code>Schema__Semantic_Graph__Node</code></td>
</tr>
<tr>
<td><code>has_node(graph, node_id)</code></td>
<td>Check if node exists</td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>all_node_ids(graph)</code></td>
<td>All node IDs</td>
<td><code>List__Node_Ids</code></td>
</tr>
<tr>
<td><code>node_count(graph)</code></td>
<td>Number of nodes</td>
<td><code>int</code></td>
</tr>
<tr>
<td><code>edge_count(graph)</code></td>
<td>Number of edges</td>
<td><code>int</code></td>
</tr>
<tr>
<td><code>nodes_by_type(graph, type_id)</code></td>
<td>Nodes of specific type</td>
<td><code>List__Node_Ids</code></td>
</tr>
<tr>
<td><code>outgoing_edges(graph, node_id)</code></td>
<td>Edges from node</td>
<td><code>List__Semantic_Graph__Edges</code></td>
</tr>
<tr>
<td><code>incoming_edges(graph, node_id)</code></td>
<td>Edges to node</td>
<td><code>List__Semantic_Graph__Edges</code></td>
</tr>
<tr>
<td><code>edges_with_predicate(graph, pred_id)</code></td>
<td>Edges with predicate</td>
<td><code>List__Semantic_Graph__Edges</code></td>
</tr>
<tr>
<td><code>neighbors(graph, node_id)</code></td>
<td>Adjacent nodes (both directions)</td>
<td><code>List__Node_Ids</code></td>
</tr>
<tr>
<td><code>outgoing_neighbors(graph, node_id)</code></td>
<td>Nodes this node points to</td>
<td><code>List__Node_Ids</code></td>
</tr>
<tr>
<td><code>incoming_neighbors(graph, node_id)</code></td>
<td>Nodes pointing to this node</td>
<td><code>List__Node_Ids</code></td>
</tr>
<tr>
<td><code>has_edge(graph, from_id, pred_id, to_id)</code></td>
<td>Check if edge exists</td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>find_edge(graph, from_id, pred_id, to_id)</code></td>
<td>Find specific edge</td>
<td><code>Schema__Semantic_Graph__Edge</code></td>
</tr>
<tr>
<td><code>get_node_property(graph, node_id, prop_id)</code></td>
<td>Get property from node</td>
<td><code>Safe_Str__Text</code></td>
</tr>
<tr>
<td><code>has_node_property(graph, node_id, prop_id)</code></td>
<td>Check if node has property</td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>nodes_with_property(graph, prop_id)</code></td>
<td>All nodes with property</td>
<td><code>List__Node_Ids</code></td>
</tr>
<tr>
<td><code>get_edge_property(edge, prop_id)</code></td>
<td>Get property from edge</td>
<td><code>Safe_Str__Text</code></td>
</tr>
<tr>
<td><code>has_edge_property(edge, prop_id)</code></td>
<td>Check if edge has property</td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>edges_with_property(graph, prop_id)</code></td>
<td>All edges with property</td>
<td><code>List__Semantic_Graph__Edges</code></td>
</tr>
</tbody>
</table>
<h3 id="ontology__registry-methods">Ontology__Registry Methods<a class="headerlink" href="#ontology__registry-methods" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>create_with__random_id(ref, ...)</code></td>
<td>Create ontology with random ID</td>
<td><code>Schema__Ontology</code></td>
</tr>
<tr>
<td><code>create_with__deterministic_id(ref, seed, ...)</code></td>
<td>Create ontology with deterministic ID</td>
<td><code>Schema__Ontology</code></td>
</tr>
<tr>
<td><code>create_with__explicit_id(ref, id, ...)</code></td>
<td>Create ontology with explicit ID</td>
<td><code>Schema__Ontology</code></td>
</tr>
<tr>
<td><code>register(ontology)</code></td>
<td>Register ontology in indexes</td>
<td><code>Schema__Ontology</code></td>
</tr>
<tr>
<td><code>get_by_id(id)</code></td>
<td>Lookup by instance ID</td>
<td><code>Schema__Ontology</code></td>
</tr>
<tr>
<td><code>get_by_ref(ref)</code></td>
<td>Lookup by reference name</td>
<td><code>Schema__Ontology</code></td>
</tr>
<tr>
<td><code>has_id(id)</code></td>
<td>Check if ID exists</td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>has_ref(ref)</code></td>
<td>Check if ref exists</td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>all_ids()</code></td>
<td>All registered IDs</td>
<td><code>List__Ontology_Ids</code></td>
</tr>
<tr>
<td><code>all_refs()</code></td>
<td>All registered refs</td>
<td><code>List__Ontology_Refs</code></td>
</tr>
<tr>
<td><code>get_node_type_by_id(ont_id, type_id)</code></td>
<td>Get node type by ID</td>
<td><code>Schema__Ontology__Node_Type</code></td>
</tr>
<tr>
<td><code>get_node_type_by_ref(ont_id, type_ref)</code></td>
<td>Get node type by ref</td>
<td><code>Schema__Ontology__Node_Type</code></td>
</tr>
<tr>
<td><code>get_predicate_by_id(ont_id, pred_id)</code></td>
<td>Get predicate by ID</td>
<td><code>Schema__Ontology__Predicate</code></td>
</tr>
<tr>
<td><code>get_predicate_by_ref(ont_id, pred_ref)</code></td>
<td>Get predicate by ref</td>
<td><code>Schema__Ontology__Predicate</code></td>
</tr>
<tr>
<td><code>get_property_name_by_id(ont_id, prop_id)</code></td>
<td>Get property name by ID</td>
<td><code>Schema__Ontology__Property_Name</code></td>
</tr>
<tr>
<td><code>get_property_type_by_id(ont_id, type_id)</code></td>
<td>Get property type by ID</td>
<td><code>Schema__Ontology__Property_Type</code></td>
</tr>
</tbody>
</table>
<h3 id="ontology__utils-methods">Ontology__Utils Methods<a class="headerlink" href="#ontology__utils-methods" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>create_node_type(ref, category_id, seed)</code></td>
<td>Create node type</td>
<td><code>Schema__Ontology__Node_Type</code></td>
</tr>
<tr>
<td><code>create_predicate(ref, inverse_id, seed)</code></td>
<td>Create predicate</td>
<td><code>Schema__Ontology__Predicate</code></td>
</tr>
<tr>
<td><code>create_predicate_pair(ref, inverse_ref, ...)</code></td>
<td>Create linked predicate pair</td>
<td><code>tuple</code></td>
</tr>
<tr>
<td><code>create_property_name(ref, type_id, seed)</code></td>
<td>Create property name</td>
<td><code>Schema__Ontology__Property_Name</code></td>
</tr>
<tr>
<td><code>create_property_type(ref, seed)</code></td>
<td>Create property type</td>
<td><code>Schema__Ontology__Property_Type</code></td>
</tr>
<tr>
<td><code>create_edge_rule(source_id, pred_id, target_id)</code></td>
<td>Create edge rule</td>
<td><code>Schema__Ontology__Edge_Rule</code></td>
</tr>
<tr>
<td><code>get_node_type(ontology, id)</code></td>
<td>Get node type by ID</td>
<td><code>Schema__Ontology__Node_Type</code></td>
</tr>
<tr>
<td><code>has_node_type(ontology, id)</code></td>
<td>Check if node type exists</td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>get_predicate(ontology, id)</code></td>
<td>Get predicate by ID</td>
<td><code>Schema__Ontology__Predicate</code></td>
</tr>
<tr>
<td><code>has_predicate(ontology, id)</code></td>
<td>Check if predicate exists</td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>get_inverse_predicate(ontology, id)</code></td>
<td>Get inverse predicate</td>
<td><code>Schema__Ontology__Predicate</code></td>
</tr>
<tr>
<td><code>is_valid_edge(ontology, src_id, pred_id, tgt_id)</code></td>
<td>Check if edge is valid per rules</td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>valid_targets_for(ontology, src_id, pred_id)</code></td>
<td>Get valid target types</td>
<td><code>List__Node_Type_Ids</code></td>
</tr>
<tr>
<td><code>valid_predicates_for(ontology, src_id)</code></td>
<td>Get valid predicates from source</td>
<td><code>List__Predicate_Ids</code></td>
</tr>
</tbody>
</table>
<h3 id="taxonomy__utils-methods">Taxonomy__Utils Methods<a class="headerlink" href="#taxonomy__utils-methods" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>get_category(taxonomy, id)</code></td>
<td>Get category by ID</td>
<td><code>Schema__Taxonomy__Category</code></td>
</tr>
<tr>
<td><code>get_category_by_ref(taxonomy, ref)</code></td>
<td>Get category by ref</td>
<td><code>Schema__Taxonomy__Category</code></td>
</tr>
<tr>
<td><code>has_category(taxonomy, id)</code></td>
<td>Check if category exists</td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>all_category_ids(taxonomy)</code></td>
<td>All category IDs</td>
<td><code>List__Category_Ids</code></td>
</tr>
<tr>
<td><code>get_root_category(taxonomy)</code></td>
<td>Get root category</td>
<td><code>Schema__Taxonomy__Category</code></td>
</tr>
<tr>
<td><code>get_parent(taxonomy, id)</code></td>
<td>Get parent category</td>
<td><code>Schema__Taxonomy__Category</code></td>
</tr>
<tr>
<td><code>get_children(taxonomy, id)</code></td>
<td>Get child IDs</td>
<td><code>List__Category_Ids</code></td>
</tr>
<tr>
<td><code>get_ancestors(taxonomy, id)</code></td>
<td>All ancestor IDs (to root)</td>
<td><code>List__Category_Ids</code></td>
</tr>
<tr>
<td><code>get_descendants(taxonomy, id)</code></td>
<td>All descendant IDs (recursive)</td>
<td><code>List__Category_Ids</code></td>
</tr>
<tr>
<td><code>is_ancestor_of(taxonomy, cat_id, child_id)</code></td>
<td>Check if category is ancestor</td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>depth(taxonomy, id)</code></td>
<td>Depth in tree (root = 0)</td>
<td><code>int</code></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="common-patterns">Common Patterns<a class="headerlink" href="#common-patterns" title="Permanent link">&para;</a></h2>
<h3 id="pattern-1-complete-graph-construction">Pattern 1: Complete Graph Construction<a class="headerlink" href="#pattern-1-complete-graph-construction" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.testing.QA__Semantic_Graphs__Test_Data import QA__Semantic_Graphs__Test_Data

# Use test data factory for quick setup
test_data = QA__Semantic_Graphs__Test_Data()
fixture   = test_data.create_complete_fixture()

ontology_registry = fixture['ontology_registry']
taxonomy_registry = fixture['taxonomy_registry']
graph             = fixture['graph']
projection        = fixture['projection']
</code></pre>
<h3 id="pattern-2-custom-ontology-from-scratch">Pattern 2: Custom Ontology from Scratch<a class="headerlink" href="#pattern-2-custom-ontology-from-scratch" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.ontology.Ontology__Registry import Ontology__Registry
from osbot_utils.helpers.semantic_graphs.ontology.Ontology__Utils    import Ontology__Utils

registry = Ontology__Registry()
utils    = Ontology__Utils()

# Create node types
person  = utils.create_node_type(Node_Type_Ref('person') , seed=Safe_Str__Id__Seed('nt-person'))
company = utils.create_node_type(Node_Type_Ref('company'), seed=Safe_Str__Id__Seed('nt-company'))

# Create predicates with inverses
works_at, employs = utils.create_predicate_pair(Predicate_Ref('works_at'),
                                                Predicate_Ref('employs') ,
                                                seed        = Safe_Str__Id__Seed('pred-works'),
                                                inverse_seed= Safe_Str__Id__Seed('pred-employs'))

# Create edge rule: person --works_at--&gt; company
rule = utils.create_edge_rule(person.node_type_id, works_at.predicate_id, company.node_type_id)

# Create ontology with all components
ontology = registry.create_with__deterministic_id(ontology_ref = Ontology_Ref('hr_domain'),
                                                  seed         = Safe_Str__Id__Seed('ont-hr'))
ontology.node_types[person.node_type_id]    = person
ontology.node_types[company.node_type_id]   = company
ontology.predicates[works_at.predicate_id]  = works_at
ontology.predicates[employs.predicate_id]   = employs
ontology.edge_rules.append(rule)
</code></pre>
<h3 id="pattern-3-graph-with-properties">Pattern 3: Graph with Properties<a class="headerlink" href="#pattern-3-graph-with-properties" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.schemas.collection.Dict__Node_Properties import Dict__Node_Properties

# Define property names in ontology
pn_salary = utils.create_property_name(Property_Name_Ref('salary'),
                                       property_type_id = pt_integer_id)
ontology.property_names[pn_salary.property_name_id] = pn_salary

# Build graph with properties
builder = Semantic_Graph__Builder()
builder.with_ontology_id(ontology.ontology_id)

props = Dict__Node_Properties()
props[pn_salary.property_name_id] = Safe_Str__Text('100000')

builder.add_node_with_seed(node_type_id = person.node_type_id     ,
                           name         = Safe_Str__Id('Alice')   ,
                           seed         = Safe_Str__Id__Seed('n1'),
                           properties   = props                   )
</code></pre>
<h3 id="pattern-4-validation-workflow">Pattern 4: Validation Workflow<a class="headerlink" href="#pattern-4-validation-workflow" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Validator import Semantic_Graph__Validator
from osbot_utils.helpers.semantic_graphs.rule.Rule_Set__Utils            import Rule_Set__Utils

# Validate against ontology edge rules
validator = Semantic_Graph__Validator()
result    = validator.validate(graph, ontology)

if result.valid is False:
    for error in result.errors:
        print(f&quot;Edge rule violation: {error}&quot;)

# Validate required properties
rule_utils = Rule_Set__Utils()
violations = rule_utils.validate_all_properties(rule_set, graph)

if len(violations) &gt; 0:
    for v in violations:
        print(f&quot;Missing property {v['missing_property']} on {v['node_id']}&quot;)
</code></pre>
<h3 id="pattern-5-projection-for-export">Pattern 5: Projection for Export<a class="headerlink" href="#pattern-5-projection-for-export" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.semantic_graphs.projector.Semantic_Graph__Projector import Semantic_Graph__Projector

projector  = Semantic_Graph__Projector(ontology_registry = registry        ,
                                       taxonomy_registry = taxonomy_registry)
projection = projector.project(graph)

# Export to JSON-friendly format
export_data = {
    'nodes': [{'type': n.ref, 'name': n.name, 'properties': dict(n.properties or {})}
              for n in projection.projection.nodes],
    'edges': [{'from': e.from_name, 'relation': e.ref, 'to': e.to_name}
              for e in projection.projection.edges],
    'taxonomy': {
        'node_categories': dict(projection.taxonomy.node_type_categories),
        'category_hierarchy': dict(projection.taxonomy.category_parents)
    }
}
</code></pre>
<hr />
<h2 id="best-practices">Best Practices<a class="headerlink" href="#best-practices" title="Permanent link">&para;</a></h2>
<h3 id="do-use-deterministic-ids-for-reproducibility">DO: Use Deterministic IDs for Reproducibility<a class="headerlink" href="#do-use-deterministic-ids-for-reproducibility" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># ✓ Correct - deterministic IDs for test fixtures
builder.add_node_with_seed(node_type_id = nt_class_id                    ,
                           name         = Safe_Str__Id('MyClass')        ,
                           seed         = Safe_Str__Id__Seed('test-class'))

# ✓ Correct - same seed = same ID every time
id_1 = Obj_Id.from_seed(Safe_Str__Id__Seed('stable-seed'))
id_2 = Obj_Id.from_seed(Safe_Str__Id__Seed('stable-seed'))
assert id_1 == id_2
</code></pre>
<h3 id="do-keep-schemas-pure-data">DO: Keep Schemas Pure Data<a class="headerlink" href="#do-keep-schemas-pure-data" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># ✓ Correct - schema is pure data
class Schema__MyGraph(Type_Safe):
    graph_id    : Graph_Id
    ontology_id : Ontology_Id
    nodes       : Dict__Nodes__By_Id

# ✓ Correct - logic in separate class
class MyGraph__Utils(Type_Safe):

    @type_safe
    def count_nodes_by_type(self, graph: Schema__MyGraph, type_id: Node_Type_Id) -&gt; int:
        count = 0
        for node in graph.nodes.values():
            if node.node_type_id == type_id:
                count += 1
        return count
</code></pre>
<h3 id="do-validate-before-processing">DO: Validate Before Processing<a class="headerlink" href="#do-validate-before-processing" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># ✓ Correct - validate first, then process
validator = Semantic_Graph__Validator()
result    = validator.validate(graph, ontology)

if result.valid is False:
    return None  # or raise appropriate error

# Safe to process validated graph
return process_graph(graph)
</code></pre>
<h3 id="do-use-fluent-builder-pattern">DO: Use Fluent Builder Pattern<a class="headerlink" href="#do-use-fluent-builder-pattern" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># ✓ Correct - chain builder calls
graph = (Semantic_Graph__Builder()
         .with_ontology_id(ontology.ontology_id)
         .with_deterministic_graph_id(Safe_Str__Id__Seed('my-graph'))
         .add_node_with_seed(nt_class_id, Safe_Str__Id('A'), Safe_Str__Id__Seed('a'))
         .add_node_with_seed(nt_class_id, Safe_Str__Id('B'), Safe_Str__Id__Seed('b'))
         .build())
</code></pre>
<h3 id="dont-put-logic-in-schemas">DON'T: Put Logic in Schemas<a class="headerlink" href="#dont-put-logic-in-schemas" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># ✗ Wrong - method in schema
class Schema__Ontology(Type_Safe):
    node_types : Dict__Node_Types__By_Id

    def get_node_type(self, id):                         # NO!
        return self.node_types.get(id)
</code></pre>
<h3 id="dont-use-raw-strings-for-idsrefs">DON'T: Use Raw Strings for IDs/Refs<a class="headerlink" href="#dont-use-raw-strings-for-idsrefs" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># ✗ Wrong - raw strings
ontology_id = 'abc123'
node_type   = 'class'

# ✓ Correct - typed identifiers
ontology_id = Ontology_Id(Obj_Id())
node_type   = Node_Type_Ref('class')
</code></pre>
<h3 id="dont-mix-ids-and-refs">DON'T: Mix IDs and Refs<a class="headerlink" href="#dont-mix-ids-and-refs" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># ✗ Wrong - using ref where ID expected
edge = Schema__Semantic_Graph__Edge(from_node_id = 'node-1',           # String!
                                    predicate_id = Predicate_Ref('calls'),  # Ref not ID!
                                    to_node_id   = node_2.node_id)

# ✓ Correct - proper ID types
edge = Schema__Semantic_Graph__Edge(from_node_id = node_1.node_id     ,
                                    predicate_id = pred_calls.predicate_id,
                                    to_node_id   = node_2.node_id     )
</code></pre>
<h3 id="dont-forget-edge-rules">DON'T: Forget Edge Rules<a class="headerlink" href="#dont-forget-edge-rules" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># ✗ Wrong - adding edges without rules
builder.add_edge(class_id, calls_id, package_id)  # Will fail validation!

# ✓ Correct - ensure rule exists in ontology first
rule = utils.create_edge_rule(nt_class_id, pred_calls_id, nt_method_id)
ontology.edge_rules.append(rule)
# Now edge is valid
builder.add_edge(class_id, pred_calls_id, method_id)
</code></pre>
<hr />
<h2 id="troubleshooting">Troubleshooting<a class="headerlink" href="#troubleshooting" title="Permanent link">&para;</a></h2>
<h3 id="problem-unknown-node_type_id-validation-error">Problem: "Unknown node_type_id" Validation Error<a class="headerlink" href="#problem-unknown-node_type_id-validation-error" title="Permanent link">&para;</a></h3>
<p><strong>Cause</strong>: Node type not registered in ontology</p>
<pre><code class="language-python"># ✗ Error: Node 'n1' has unknown node_type_id: abc123...
builder.add_node(node_type_id = Node_Type_Id('abc123'),  # Not in ontology!
                 name         = Safe_Str__Id('test'))

# ✓ Solution: Register node type first
nt_test = utils.create_node_type(Node_Type_Ref('test'))
ontology.node_types[nt_test.node_type_id] = nt_test

builder.add_node(node_type_id = nt_test.node_type_id,
                 name         = Safe_Str__Id('test'))
</code></pre>
<h3 id="problem-invalid-edge-validation-error">Problem: "Invalid edge" Validation Error<a class="headerlink" href="#problem-invalid-edge-validation-error" title="Permanent link">&para;</a></h3>
<p><strong>Cause</strong>: No edge rule allows this combination</p>
<pre><code class="language-python"># ✗ Error: Invalid edge: class --[calls]--&gt; package
# No rule permits class to call package

# ✓ Solution: Add edge rule or use correct types
rule = utils.create_edge_rule(nt_class_id, pred_calls_id, nt_method_id)
ontology.edge_rules.append(rule)
</code></pre>
<h3 id="problem-registry-required-to-resolve-ref-error">Problem: "Registry required to resolve ref" Error<a class="headerlink" href="#problem-registry-required-to-resolve-ref-error" title="Permanent link">&para;</a></h3>
<p><strong>Cause</strong>: Using <code>*_by_ref</code> method without registry</p>
<pre><code class="language-python"># ✗ Error: Registry required to resolve node_type_ref to node_type_id
builder.add_node_by_ref(Node_Type_Ref('class'), Safe_Str__Id('A'))

# ✓ Solution: Set registry first
builder.with_registry(ontology_registry)
builder.add_node_by_ref(Node_Type_Ref('class'), Safe_Str__Id('A'))
</code></pre>
<h3 id="problem-nodeedge-not-found">Problem: Node/Edge Not Found<a class="headerlink" href="#problem-nodeedge-not-found" title="Permanent link">&para;</a></h3>
<p><strong>Cause</strong>: Wrong ID or ID not in graph</p>
<pre><code class="language-python"># Check if node exists before accessing
if utils.has_node(graph, node_id):
    node = utils.get_node(graph, node_id)
else:
    print(f&quot;Node {node_id} not found&quot;)

# Use find_edge which returns None if not found
edge = utils.find_edge(graph, from_id, pred_id, to_id)
if edge is None:
    print(&quot;Edge not found&quot;)
</code></pre>
<h3 id="problem-empty-projection">Problem: Empty Projection<a class="headerlink" href="#problem-empty-projection" title="Permanent link">&para;</a></h3>
<p><strong>Cause</strong>: Ontology not found in registry</p>
<pre><code class="language-python"># ✗ Empty projection - ontology_id not in registry
projector  = Semantic_Graph__Projector(ontology_registry = Ontology__Registry())
projection = projector.project(graph)  # projection.projection.nodes is empty

# ✓ Solution: Ensure ontology is registered
registry.register(ontology)
projector  = Semantic_Graph__Projector(ontology_registry = registry)
projection = projector.project(graph)
</code></pre>
<h3 id="problem-deterministic-ids-dont-match">Problem: Deterministic IDs Don't Match<a class="headerlink" href="#problem-deterministic-ids-dont-match" title="Permanent link">&para;</a></h3>
<p><strong>Cause</strong>: Different seeds or seed string variations</p>
<pre><code class="language-python"># These produce DIFFERENT IDs
id_1 = Obj_Id.from_seed(Safe_Str__Id__Seed('my-node'))
id_2 = Obj_Id.from_seed(Safe_Str__Id__Seed('my_node'))   # Different seed!
id_3 = Obj_Id.from_seed(Safe_Str__Id__Seed('My-Node'))   # Case matters!

# ✓ Use consistent seed naming conventions
SEED_MY_NODE = Safe_Str__Id__Seed('my-node')
id_1 = Obj_Id.from_seed(SEED_MY_NODE)
id_2 = Obj_Id.from_seed(SEED_MY_NODE)  # Same!
</code></pre>
<h3 id="problem-property-value-type-mismatch">Problem: Property Value Type Mismatch<a class="headerlink" href="#problem-property-value-type-mismatch" title="Permanent link">&para;</a></h3>
<p><strong>Cause</strong>: Properties store <code>Safe_Str__Text</code>, not native types</p>
<pre><code class="language-python"># ✗ Wrong - storing int directly
node.properties[prop_id] = 42  # Type error!

# ✓ Correct - convert to Safe_Str__Text
node.properties[prop_id] = Safe_Str__Text('42')

# Reading: parse string value as needed
line_number = int(str(utils.get_node_property(graph, node_id, pn_line_number_id)))
</code></pre>
<hr />
<h2 id="summary-checklist">Summary Checklist<a class="headerlink" href="#summary-checklist" title="Permanent link">&para;</a></h2>
<p>When working with Semantic Graphs:</p>
<p><strong>Schema Design:</strong>
- [ ] Schemas are PURE DATA - no methods
- [ ] All attributes have type annotations
- [ ] Use Dict__ and List__ typed collections
- [ ] Use ID types for internal references (Node_Id, Edge_Id, etc.)
- [ ] Use Ref types for human-readable labels (Node_Type_Ref, Predicate_Ref, etc.)</p>
<p><strong>Ontology Setup:</strong>
- [ ] Create node types with <code>Ontology__Utils.create_node_type()</code>
- [ ] Create predicate pairs with <code>Ontology__Utils.create_predicate_pair()</code>
- [ ] Define edge rules for all valid edge combinations
- [ ] Register ontology with <code>Ontology__Registry.register()</code>
- [ ] Define property names and types if using properties</p>
<p><strong>Graph Building:</strong>
- [ ] Use <code>Semantic_Graph__Builder</code> for construction
- [ ] Call <code>with_ontology_id()</code> before adding nodes/edges
- [ ] Use <code>*_with_seed()</code> methods for deterministic IDs
- [ ] Use <code>*_by_ref()</code> methods with registry for human-friendly building
- [ ] Call <code>build()</code> to get final graph</p>
<p><strong>Validation:</strong>
- [ ] Validate graphs with <code>Semantic_Graph__Validator.validate()</code>
- [ ] Check <code>result.valid</code> before processing
- [ ] Use <code>Rule_Set__Utils.validate_all_properties()</code> for property rules
- [ ] Handle validation errors gracefully</p>
<p><strong>Projection:</strong>
- [ ] Create projector with ontology and taxonomy registries
- [ ] Use <code>Semantic_Graph__Projector.project()</code> for human-readable output
- [ ] Access <code>projection.projection.nodes</code> and <code>projection.projection.edges</code>
- [ ] Use <code>projection.references</code> to map refs back to IDs</p>
<p><strong>ID Management:</strong>
- [ ] Use <code>Obj_Id()</code> for random IDs
- [ ] Use <code>Obj_Id.from_seed()</code> for deterministic IDs
- [ ] Store seeds as constants for reproducibility
- [ ] Track ID sources with <code>Schema__Id__Source</code> when needed</p>
<p><strong>Testing:</strong>
- [ ] Use <code>QA__Semantic_Graphs__Test_Data</code> for test fixtures
- [ ] Use deterministic seeds for reproducible tests
- [ ] Create complete fixtures with <code>create_complete_fixture()</code>
- [ ] Access pre-generated IDs with <code>get_*_id__*()</code> methods</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="../../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../../..";</script>
    <script src="../../../js/theme_extra.js"></script>
    <script src="../../../js/theme.js"></script>
      <script src="../../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
