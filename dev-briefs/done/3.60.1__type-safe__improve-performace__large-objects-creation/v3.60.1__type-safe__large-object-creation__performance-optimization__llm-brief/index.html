<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://owasp-sbot.github.io/OSBot-Utils/dev-briefs/done/3.60.1__type-safe__improve-performace__large-objects-creation/v3.60.1__type-safe__large-object-creation__performance-optimization__llm-brief/" />
      <link rel="shortcut icon" href="../../../../img/favicon.ico" />
    <title>Type_Safe Large Object Creation: Performance Optimization Brief - OSBot-Utils Documentation</title>
    <link rel="stylesheet" href="../../../../css/theme.css" />
    <link rel="stylesheet" href="../../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Type_Safe Large Object Creation: Performance Optimization Brief";
        var mkdocs_page_input_path = "dev-briefs/done/3.60.1__type-safe__improve-performace__large-objects-creation/v3.60.1__type-safe__large-object-creation__performance-optimization__llm-brief.md";
        var mkdocs_page_url = "/OSBot-Utils/dev-briefs/done/3.60.1__type-safe__improve-performace__large-objects-creation/v3.60.1__type-safe__large-object-creation__performance-optimization__llm-brief/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../../.." class="icon icon-home"> OSBot-Utils Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Code</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" >OSBot Utils</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" >Helpers</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../../../code/osbot_utils/helpers/flows/osbot-utils-flow-system-documentation/">Flows</a>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Development</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../../../dev/Python-code-formatting-guidelines/">Coding Guidelines</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Type Safety</a>
    <ul>
                <li class="toctree-l2"><a class="" href="../../../../dev/type_safe/python-type-safety-frameworks-compared.md">Frameworks Compared</a>
                </li>
                <li class="toctree-l2"><a class="" href="../../../../dev/type_safe/type-safe-technical-documentation.md">Technical Documentation</a>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../..">OSBot-Utils Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Type_Safe Large Object Creation: Performance Optimization Brief</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="type_safe-large-object-creation-performance-optimization-brief">Type_Safe Large Object Creation: Performance Optimization Brief<a class="headerlink" href="#type_safe-large-object-creation-performance-optimization-brief" title="Permanent link">&para;</a></h1>
<p><strong>Version</strong>: v3.60.1<br />
<strong>Date</strong>: December 2025<br />
<strong>Purpose</strong>: Guide for LLM session focused on optimizing Type_Safe construction for complex nested objects<br />
<strong>Context</strong>: Performance bottleneck discovered in Html_MGraph conversion pipeline</p>
<hr />
<h2 id="executive-summary">Executive Summary<a class="headerlink" href="#executive-summary" title="Permanent link">&para;</a></h2>
<p>During performance profiling of an HTML-to-Graph conversion system, we discovered that <strong>Type_Safe object construction is a major bottleneck</strong>. A single <code>MGraph__Index()</code> construction takes <strong>~1.9ms</strong> despite containing only empty data structures. This object is created 6 times during document setup, consuming <strong>~11-14ms</strong> just for empty index construction.</p>
<p>The root cause is the deeply nested Type_Safe object hierarchy—when a parent Type_Safe class has attributes that are themselves Type_Safe classes, the entire tree is recursively instantiated. For <code>MGraph__Index</code>, this creates <strong>100+ nested objects</strong> on every construction.</p>
<p><strong>Goal</strong>: Find a way to optimize Type_Safe object creation for performance-sensitive situations where construction speed is more important than immediate type validation.</p>
<hr />
<h2 id="background-the-html_mgraph-project">Background: The Html_MGraph Project<a class="headerlink" href="#background-the-html_mgraph-project" title="Permanent link">&para;</a></h2>
<h3 id="what-it-does">What It Does<a class="headerlink" href="#what-it-does" title="Permanent link">&para;</a></h3>
<p>The Html_MGraph service transforms HTML documents into graph representations for visualization, analysis, and manipulation. It converts HTML into a multi-graph model where different aspects (DOM structure, attributes, scripts, styles) are represented as interconnected graphs.</p>
<pre><code>HTML Document  ──────►  Graph Representation  ──────►  Visual Output
                              │
                              ├── Head Graph
                              ├── Body Graph
                              ├── Attributes Graph
                              ├── Scripts Graph
                              └── Styles Graph
</code></pre>
<h3 id="architecture">Architecture<a class="headerlink" href="#architecture" title="Permanent link">&para;</a></h3>
<p>The system uses MGraph-DB, a type-safe graph database framework built on OSBot-Utils Type_Safe. Each HTML document creates:</p>
<ul>
<li><strong>1 Document Graph</strong> (container)</li>
<li><strong>5 Subgraphs</strong> (Head, Body, Attributes, Scripts, Styles)</li>
<li><strong>1 Index per graph</strong> (for O(1) lookups)</li>
</ul>
<p>Each graph has its own <code>MGraph__Index</code> instance for fast node/edge lookups.</p>
<h3 id="the-performance-problem-discovered">The Performance Problem Discovered<a class="headerlink" href="#the-performance-problem-discovered" title="Permanent link">&para;</a></h3>
<p>Processing a simple HTML document like:</p>
<pre><code class="language-html">&lt;html&gt;&lt;body&gt;&lt;div class=&quot;main&quot; id=&quot;content&quot;&gt;Hello World&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;
</code></pre>
<p>Takes <strong>~45ms</strong>, of which <strong>~14ms (31%)</strong> is spent just on <code>.index()</code> calls—and most of that is <strong>constructing empty index objects</strong>.</p>
<h4 id="profiling-data">Profiling Data<a class="headerlink" href="#profiling-data" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MGraph__Index()</code> construction</td>
<td>1.9ms</td>
</tr>
<tr>
<td>× 6 subgraphs</td>
<td>= ~11.4ms</td>
</tr>
<tr>
<td>Loading actual data into index</td>
<td>0.026ms</td>
</tr>
<tr>
<td><strong>Ratio: construction vs work</strong></td>
<td><strong>73:1</strong></td>
</tr>
</tbody>
</table>
<p>The index construction is <strong>73× slower</strong> than the actual work of populating it.</p>
<hr />
<h2 id="the-problem-mgraph__index-object-tree">The Problem: MGraph__Index Object Tree<a class="headerlink" href="#the-problem-mgraph__index-object-tree" title="Permanent link">&para;</a></h2>
<h3 id="class-definition">Class Definition<a class="headerlink" href="#class-definition" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">class MGraph__Index(Type_Safe):
    index_data   : Schema__MGraph__Index__Data          # Composite index data
    index_config : Schema__MGraph__Index__Config = None
    edges_index  : MGraph__Index__Edges                 # Edge-node structural indexing
    edit_index   : MGraph__Index__Edit                  # Add/remove operations
    labels_index : MGraph__Index__Labels                # Label indexing
    paths_index  : MGraph__Index__Paths                 # Path indexing
    query_index  : MGraph__Index__Query                 # Complex cross-index queries
    stats_index  : MGraph__Index__Stats                 # Statistics calculation
    types_index  : MGraph__Index__Types                 # Type indexing
    values_index : MGraph__Index__Values                # Value node indexing
    resolver     : MGraph__Type__Resolver               # Type resolution
</code></pre>
<h3 id="the-object-tree-explosion">The Object Tree Explosion<a class="headerlink" href="#the-object-tree-explosion" title="Permanent link">&para;</a></h3>
<p>When <code>MGraph__Index()</code> is called, Type_Safe auto-initializes all attributes. Each attribute that is a Type_Safe class triggers its own initialization, recursively. Here's the actual object tree created:</p>
<pre><code>MGraph__Index
├── index_data: Schema__MGraph__Index__Data
│   ├── edges: Schema__MGraph__Index__Data__Edges
│   │   ├── edges_to_nodes: Dict
│   │   ├── nodes_to_outgoing_edges: Dict
│   │   └── nodes_to_incoming_edges: Dict
│   ├── labels: Schema__MGraph__Index__Data__Labels
│   │   ├── edges_predicates: Dict
│   │   ├── edges_by_predicate: Dict
│   │   ├── edges_incoming_labels: Dict
│   │   ├── edges_by_incoming_label: Dict
│   │   ├── edges_outgoing_labels: Dict
│   │   └── edges_by_outgoing_label: Dict
│   ├── paths: Schema__MGraph__Index__Data__Paths
│   │   ├── nodes_by_path: Dict
│   │   └── edges_by_path: Dict
│   └── types: Schema__MGraph__Index__Data__Types
│       ├── nodes_types: Dict
│       ├── nodes_by_type: Dict
│       ├── edges_types: Dict
│       ├── edges_by_type: Dict
│       ├── nodes_to_incoming_edges_by_type: Dict
│       └── nodes_to_outgoing_edges_by_type: Dict
├── edges_index: MGraph__Index__Edges
│   └── data: Schema__MGraph__Index__Data__Edges (DUPLICATE STRUCTURE)
├── edit_index: MGraph__Index__Edit
│   ├── edges_index: MGraph__Index__Edges (DUPLICATE)
│   ├── labels_index: MGraph__Index__Labels (DUPLICATE)
│   ├── paths_index: MGraph__Index__Paths (DUPLICATE)
│   ├── types_index: MGraph__Index__Types (DUPLICATE)
│   ├── values_index: MGraph__Index__Values (DUPLICATE)
│   └── resolver: MGraph__Type__Resolver (DUPLICATE)
├── query_index: MGraph__Index__Query
│   ├── edges_index: MGraph__Index__Edges (DUPLICATE)
│   ├── labels_index: MGraph__Index__Labels (DUPLICATE)
│   ├── types_index: MGraph__Index__Types (DUPLICATE)
│   └── values_index: MGraph__Index__Values (DUPLICATE)
├── stats_index: MGraph__Index__Stats
│   ├── edges_index: MGraph__Index__Edges (DUPLICATE)
│   ├── labels_index: MGraph__Index__Labels (DUPLICATE)
│   ├── paths_index: MGraph__Index__Paths (DUPLICATE)
│   └── types_index: MGraph__Index__Types (DUPLICATE)
├── labels_index: MGraph__Index__Labels
│   └── data: Schema__MGraph__Index__Data__Labels
├── paths_index: MGraph__Index__Paths
│   └── data: Schema__MGraph__Index__Data__Paths
├── types_index: MGraph__Index__Types
│   └── data: Schema__MGraph__Index__Data__Types
├── values_index: MGraph__Index__Values
│   └── index_data: Schema__MGraph__Index__Data__Values
└── resolver: MGraph__Type__Resolver
    └── mgraph_defaults: (10 string fields)
</code></pre>
<h3 id="key-issue-duplicate-objects">Key Issue: Duplicate Objects<a class="headerlink" href="#key-issue-duplicate-objects" title="Permanent link">&para;</a></h3>
<p>The design <strong>intends</strong> to share objects via wiring in <code>__init__</code>:</p>
<pre><code class="language-python">def __init__(self, **kwargs):
    super().__init__(**kwargs)
    self._sync_index_data()

def _sync_index_data(self) -&gt; None:
    # Wire up each sub-index with shared references
    self.edges_index.data  = self.index_data.edges   # Reassign to shared
    self.edit_index.edges_index = self.edges_index   # Reassign to shared
    self.query_index.edges_index = self.edges_index  # Reassign to shared
    # ... etc
</code></pre>
<p><strong>But the damage is already done</strong>—Type_Safe has already constructed separate instances for each attribute during <code>super().__init__()</code>. The wiring replaces references, but the original objects were still created and then discarded.</p>
<h3 id="measured-sub-index-construction-times">Measured Sub-Index Construction Times<a class="headerlink" href="#measured-sub-index-construction-times" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Sub-Index</th>
<th>Construction Time</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MGraph__Index__Edges</code></td>
<td>50µs</td>
</tr>
<tr>
<td><code>MGraph__Index__Labels</code></td>
<td>80µs</td>
</tr>
<tr>
<td><code>MGraph__Index__Types</code></td>
<td>90µs</td>
</tr>
<tr>
<td><code>MGraph__Index__Values</code></td>
<td>60µs</td>
</tr>
<tr>
<td><strong>Sum of 4 sub-indexes</strong></td>
<td><strong>~280µs</strong></td>
</tr>
<tr>
<td><strong>Actual <code>MGraph__Index</code></strong></td>
<td><strong>~1,900µs</strong></td>
</tr>
<tr>
<td><strong>Unaccounted overhead</strong></td>
<td><strong>~1,620µs</strong></td>
</tr>
</tbody>
</table>
<p>The simple sub-indexes are fast, but something in the full construction adds 1.6ms of overhead.</p>
<hr />
<h2 id="root-cause-analysis">Root Cause Analysis<a class="headerlink" href="#root-cause-analysis" title="Permanent link">&para;</a></h2>
<h3 id="type_safe-auto-initialization-behavior">Type_Safe Auto-Initialization Behavior<a class="headerlink" href="#type_safe-auto-initialization-behavior" title="Permanent link">&para;</a></h3>
<p>When Type_Safe sees:</p>
<pre><code class="language-python">class MyClass(Type_Safe):
    my_attr: SomeType_Safe_Class
</code></pre>
<p>It automatically calls <code>SomeType_Safe_Class()</code> during initialization if no value is provided. This is <strong>the correct and desired behavior</strong> for type safety—but it creates performance issues for deeply nested structures.</p>
<h3 id="the-multiplication-effect">The Multiplication Effect<a class="headerlink" href="#the-multiplication-effect" title="Permanent link">&para;</a></h3>
<p>For <code>MGraph__Index</code>:
- 10+ direct Type_Safe attributes
- Each has 4-6 nested Type_Safe attributes
- Some have further nesting
- Results in <strong>100+ object constructions</strong></p>
<p>Even if each construction is only 10-20µs, 100 × 15µs = 1.5ms.</p>
<h3 id="why-this-matters-for-html_mgraph">Why This Matters for Html_MGraph<a class="headerlink" href="#why-this-matters-for-html_mgraph" title="Permanent link">&para;</a></h3>
<p>Every HTML element processed needs:
1. Node creation (triggers index access)
2. Attribute registration (triggers index access)
3. Edge creation (triggers index access)</p>
<p>The index is cached after first access per graph, but with <strong>6 separate graphs</strong>, that's 6 × 1.9ms = <strong>11.4ms</strong> of mandatory index construction overhead—before processing a single HTML element.</p>
<hr />
<h2 id="potential-optimization-approaches">Potential Optimization Approaches<a class="headerlink" href="#potential-optimization-approaches" title="Permanent link">&para;</a></h2>
<h3 id="approach-1-lazy-attribute-initialization">Approach 1: Lazy Attribute Initialization<a class="headerlink" href="#approach-1-lazy-attribute-initialization" title="Permanent link">&para;</a></h3>
<p>Only create sub-objects when first accessed:</p>
<pre><code class="language-python">class MGraph__Index(Type_Safe):
    _edges_index: MGraph__Index__Edges = None  # Private, starts None

    @property
    def edges_index(self) -&gt; MGraph__Index__Edges:
        if self._edges_index is None:
            self._edges_index = MGraph__Index__Edges()
        return self._edges_index
</code></pre>
<p><strong>Pros</strong>: Only pay for what you use<br />
<strong>Cons</strong>: Requires changing attribute access patterns, loses Type_Safe validation on assignment</p>
<h3 id="approach-2-factory-pattern-with-shared-objects">Approach 2: Factory Pattern with Shared Objects<a class="headerlink" href="#approach-2-factory-pattern-with-shared-objects" title="Permanent link">&para;</a></h3>
<p>Create shared instances and pass them in:</p>
<pre><code class="language-python">@classmethod
def create_fast(cls, shared_resolver: MGraph__Type__Resolver = None) -&gt; 'MGraph__Index':
    # Create shared objects once
    edges_data = Schema__MGraph__Index__Data__Edges()
    edges_index = MGraph__Index__Edges(data=edges_data)

    # Pass to avoid re-creation
    return cls(
        edges_index=edges_index,
        edit_index=MGraph__Index__Edit(edges_index=edges_index),
        # ...
    )
</code></pre>
<p><strong>Pros</strong>: Avoids duplicate object creation<br />
<strong>Cons</strong>: Complex factory code, bypasses normal construction</p>
<h3 id="approach-3-type_safe-fast-mode">Approach 3: Type_Safe "Fast Mode"<a class="headerlink" href="#approach-3-type_safe-fast-mode" title="Permanent link">&para;</a></h3>
<p>A new Type_Safe option that skips auto-initialization of nested Type_Safe objects:</p>
<pre><code class="language-python">class MGraph__Index(Type_Safe):
    __type_safe_fast_init__ = True  # Skip nested auto-init

    edges_index: MGraph__Index__Edges = None  # Will be None until set
</code></pre>
<p><strong>Pros</strong>: Opt-in at class level, minimal code changes<br />
<strong>Cons</strong>: Requires Type_Safe framework changes, shifts responsibility to user</p>
<h3 id="approach-4-singletonflyweight-for-empty-objects">Approach 4: Singleton/Flyweight for Empty Objects<a class="headerlink" href="#approach-4-singletonflyweight-for-empty-objects" title="Permanent link">&para;</a></h3>
<p>Cache and reuse empty instances:</p>
<pre><code class="language-python">class MGraph__Index__Edges(Type_Safe):
    _empty_instance = None

    @classmethod
    def empty(cls) -&gt; 'MGraph__Index__Edges':
        if cls._empty_instance is None:
            cls._empty_instance = cls()
        return cls._empty_instance
</code></pre>
<p><strong>Pros</strong>: Very fast for repeated empty constructions<br />
<strong>Cons</strong>: Mutation issues (must be immutable or cloned)</p>
<h3 id="approach-5-__slots__-manual-init">Approach 5: <code>__slots__</code> + Manual Init<a class="headerlink" href="#approach-5-__slots__-manual-init" title="Permanent link">&para;</a></h3>
<p>Bypass Type_Safe for performance-critical classes:</p>
<pre><code class="language-python">class MGraph__Index__Edges:  # Not Type_Safe
    __slots__ = ['data']

    def __init__(self, data=None):
        self.data = data or Schema__MGraph__Index__Data__Edges()
</code></pre>
<p><strong>Pros</strong>: Maximum performance<br />
<strong>Cons</strong>: Loses all Type_Safe benefits</p>
<h3 id="approach-6-deferred-validation">Approach 6: Deferred Validation<a class="headerlink" href="#approach-6-deferred-validation" title="Permanent link">&para;</a></h3>
<p>Construct fast, validate later:</p>
<pre><code class="language-python">class MGraph__Index(Type_Safe):
    __defer_validation__ = True

    def validate(self):
        # Called explicitly when ready
        super()._validate_all_attributes()
</code></pre>
<p><strong>Pros</strong>: Fast construction, validation when needed<br />
<strong>Cons</strong>: Requires framework changes, validation might never happen</p>
<hr />
<h2 id="questions-for-this-session">Questions for This Session<a class="headerlink" href="#questions-for-this-session" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>What is the actual breakdown of the 1.9ms?</strong> </li>
<li>How much is Type_Safe <code>__init__</code> overhead vs nested object creation?</li>
<li>
<p>Is there reflection/introspection happening on every construction?</p>
</li>
<li>
<p><strong>Can Type_Safe cache type annotations?</strong></p>
</li>
<li>Parsing annotations on every <code>__init__</code> is expensive</li>
<li>
<p>Class-level caching could help</p>
</li>
<li>
<p><strong>Is there a way to support "fast construction" mode?</strong></p>
</li>
<li>Skip validation during construction</li>
<li>
<p>Validate on first attribute access or explicit call</p>
</li>
<li>
<p><strong>Can we detect and avoid creating "duplicate" objects?</strong></p>
</li>
<li>If the same Type_Safe class appears multiple times in a tree</li>
<li>
<p>Create once, share references</p>
</li>
<li>
<p><strong>What's the minimal change for maximum impact?</strong></p>
</li>
<li>We need a solution that works with existing code</li>
<li>Ideally opt-in without breaking existing behavior</li>
</ol>
<hr />
<h2 id="success-criteria">Success Criteria<a class="headerlink" href="#success-criteria" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Metric</th>
<th>Current</th>
<th>Target</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MGraph__Index()</code> construction</td>
<td>1.9ms</td>
<td>&lt;200µs</td>
</tr>
<tr>
<td>6 index constructions</td>
<td>~11.4ms</td>
<td>&lt;1.2ms</td>
</tr>
<tr>
<td>Total document setup</td>
<td>~15ms</td>
<td>&lt;5ms</td>
</tr>
<tr>
<td>Simple HTML total time</td>
<td>~45ms</td>
<td>&lt;20ms</td>
</tr>
</tbody>
</table>
<p><strong>10× improvement</strong> in index construction would make it negligible in the overall pipeline.</p>
<hr />
<h2 id="appendix-full-object-serialization">Appendix: Full Object Serialization<a class="headerlink" href="#appendix-full-object-serialization" title="Permanent link">&para;</a></h2>
<p>The actual output of <code>MGraph__Index().obj()</code> showing all nested objects created:</p>
<pre><code class="language-python">__(index_config=None,
   index_data=__(edges=__(edges_to_nodes=__(),
                          nodes_to_outgoing_edges=__(),
                          nodes_to_incoming_edges=__()),
                 labels=__(edges_predicates=__(),
                           edges_by_predicate=__(),
                           edges_incoming_labels=__(),
                           edges_by_incoming_label=__(),
                           edges_outgoing_labels=__(),
                           edges_by_outgoing_label=__()),
                 paths=__(nodes_by_path=__(), edges_by_path=__()),
                 types=__(nodes_types=__(),
                          nodes_by_type=__(),
                          edges_types=__(),
                          edges_by_type=__(),
                          nodes_to_incoming_edges_by_type=__(),
                          nodes_to_outgoing_edges_by_type=__())),
   edges_index=__(data=__(edges_to_nodes=__(),
                          nodes_to_outgoing_edges=__(),
                          nodes_to_incoming_edges=__())),
   edit_index=__(edges_index=__(data=__(edges_to_nodes=__(),
                                        nodes_to_outgoing_edges=__(),
                                        nodes_to_incoming_edges=__())),
                 labels_index=__(enabled=True,
                                 data=__(edges_predicates=__(),
                                         edges_by_predicate=__(),
                                         edges_incoming_labels=__(),
                                         edges_by_incoming_label=__(),
                                         edges_outgoing_labels=__(),
                                         edges_by_outgoing_label=__())),
                 paths_index=__(enabled=True,
                                data=__(nodes_by_path=__(), edges_by_path=__())),
                 types_index=__(enabled=True,
                                data=__(nodes_types=__(),
                                        nodes_by_type=__(),
                                        edges_types=__(),
                                        edges_by_type=__(),
                                        nodes_to_incoming_edges_by_type=__(),
                                        nodes_to_outgoing_edges_by_type=__())),
                 values_index=__(enabled=True,
                                 index_data=__(hash_to_node=__(),
                                               node_to_hash=__(),
                                               values_by_type=__(),
                                               type_by_value=__())),
                 resolver=__(mgraph_defaults=__(...))),
   labels_index=__(enabled=True,
                   data=__(edges_predicates=__(),
                           edges_by_predicate=__(),
                           edges_incoming_labels=__(),
                           edges_by_incoming_label=__(),
                           edges_outgoing_labels=__(),
                           edges_by_outgoing_label=__())),
   paths_index=__(enabled=True,
                  data=__(nodes_by_path=__(), edges_by_path=__())),
   query_index=__(edges_index=__(data=__(...)),
                  labels_index=__(enabled=True, data=__(...)),
                  types_index=__(enabled=True, data=__(...)),
                  values_index=__(enabled=True, index_data=__(...))),
   stats_index=__(edges_index=__(data=__(...)),
                  labels_index=__(enabled=True, data=__(...)),
                  paths_index=__(enabled=True, data=__(...)),
                  types_index=__(enabled=True, data=__(...))),
   types_index=__(enabled=True,
                  data=__(nodes_types=__(),
                          nodes_by_type=__(),
                          edges_types=__(),
                          edges_by_type=__(),
                          nodes_to_incoming_edges_by_type=__(),
                          nodes_to_outgoing_edges_by_type=__())),
   values_index=__(enabled=True,
                   index_data=__(hash_to_node=__(),
                                 node_to_hash=__(),
                                 values_by_type=__(),
                                 type_by_value=__())),
   resolver=__(mgraph_defaults=__(...)))
</code></pre>
<p>Note the <strong>massive duplication</strong>:
- <code>edges_index</code> structure appears 5 times
- <code>labels_index</code> structure appears 4 times
- <code>types_index</code> structure appears 4 times
- <code>values_index</code> structure appears 3 times
- <code>resolver</code> structure appears 2 times</p>
<p>All of these duplicates are created, then immediately discarded when <code>_sync_index_data()</code> reassigns references.</p>
<hr />
<h2 id="reference-documents">Reference Documents<a class="headerlink" href="#reference-documents" title="Permanent link">&para;</a></h2>
<ul>
<li><code>v3_1_1__osbot-utils__type-safe__and__python-formatting__guidance.md</code> - Type_Safe framework documentation</li>
<li><code>v1_10_6__mGraph-db__llm_briefing.md</code> - MGraph-DB architecture</li>
<li><code>v1_4_0__html-graph-service__llm-brief.md</code> - Html_MGraph service overview</li>
<li><code>v3_59_2__timestamp-capture__llm-usage-brief.md</code> - Profiling methodology used</li>
</ul>
<hr />
<p><em>This brief was generated from a performance investigation session that identified Type_Safe object construction as a critical optimization target.</em></p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="../../../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../../../..";</script>
    <script src="../../../../js/theme_extra.js"></script>
    <script src="../../../../js/theme.js"></script>
      <script src="../../../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
