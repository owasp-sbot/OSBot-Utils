# Git Worktrees: Multiple Working Directories, One Repository

**version**: v3.72.1

## Executive Summary

`git worktree` allows you to check out **multiple branches (or commits) at the same time**, each into its **own directory**, while sharing a **single Git repository and object database**.

This solves a long-standing pain in Git workflows:  
> *“I want to work on two branches at once without stashing, context switching, or cloning the repo again.”*

Worktrees are not a hack, a plugin, or a special mode — they are a **natural extension of Git’s core architecture**. Git’s distributed, content-addressed design makes this feature not only possible, but *clean, safe, and extremely efficient*.

---

## The Problem Worktrees Solve

Classic Git usage assumes:

- One repository
- One working directory
- One checked-out branch at a time

This creates friction when you need to:

- Work on a feature while a hotfix is required
- Review a PR without touching your current work
- Maintain long-lived release branches
- Compare two branches side by side
- Avoid constant `git stash` / `git stash pop`

The usual workaround is **multiple clones**, which leads to:

- Duplicated disk usage
- Repeated network fetches
- Fragmented local state
- Higher cognitive overhead

Git worktrees solve this **without changing how Git works**.

---

## What a Worktree Is (Conceptually)

A **worktree** is:

- A directory on disk
- With its own checked-out branch (or commit)
- Its own working files
- Its own staging area (index)
- Its own `HEAD`

All worktrees share:

- The same Git object database
- The same commits, trees, blobs
- The same refs, tags, and remotes

In other words:

> **Multiple working directories, one Git repository.**

---

## The Key Mental Model

Git already separates **history** from **working state**.

Worktrees simply expose this separation.

### Isolated per worktree
- Working directory files
- Staging area (index)
- Checked-out branch / HEAD
- Uncommitted changes

### Shared across all worktrees
- Commit history
- Object database (`.git/objects`)
- Tags
- Remote tracking branches
- Fetches

This is why:
- Uncommitted changes never leak between worktrees
- Committed changes instantly become visible everywhere
- Disk usage stays minimal

---

## Why Git’s Architecture Makes This Easy

Git is fundamentally:

- **Distributed**: every clone has the full history
- **Content-addressed**: commits are immutable objects
- **Decoupled**: history ≠ working directory
- **Ref-based**: branches are movable pointers, not containers

Because of this:

- Commits do not belong to a working directory
- Branches are just refs pointing to commits
- A working directory is just a *view* of a commit

Worktrees take advantage of this by allowing:
- Multiple `HEAD`s
- Multiple indexes
- One shared object store

No duplication. No synchronization. No special cases.

This is not bolted on — it’s a **direct consequence of Git’s design**.

---

## Creating and Using a Worktree

### Create a worktree for an existing branch
```bash
git worktree add ../feature-x feature-x
````

### Create a worktree and a new branch

```bash
git worktree add -b feature-x ../feature-x
```

### List active worktrees

```bash
git worktree list
```

Each worktree behaves like a full repository checkout — just faster and lighter.

---

## Branch Safety Guarantees

Git enforces an important rule:

> **A branch may only be checked out in one worktree at a time**

This prevents:

* Concurrent rebases
* Conflicting working states
* Silent corruption

Detached HEAD worktrees *are* allowed and useful for:

* Debugging old commits
* Code archaeology
* Bisecting

---

## Committing, Merging, and Pull Requests

A branch checked out in a worktree is a **normal branch**.

You can:

* Commit in the worktree
* Merge it into another branch
* Push it to a remote
* Open a Pull Request
* Delete it when done

Example:

```bash
# in the worktree
git commit -m "Implement feature"

# in main repo
git checkout dev
git merge feature-x
```

Or:

```bash
git push origin feature-x
```

From Git’s perspective, nothing unusual happened.

---

## Cleaning Up

When a worktree is no longer needed:

```bash
git worktree remove ../feature-x
git branch -d feature-x
```

If directories were removed manually:

```bash
git worktree prune
```

---

## Why Worktrees Are Better Than Multiple Clones

| Aspect            | Multiple Clones | Worktrees |
| ----------------- | --------------- | --------- |
| Disk usage        | High            | Minimal   |
| Fetching          | Repeated        | Shared    |
| Branch safety     | Manual          | Enforced  |
| Context switching | High            | Low       |
| Mental overhead   | High            | Low       |

Worktrees give you the benefits of multiple clones **without the cost**.

---

## When to Use Worktrees

Worktrees shine when you:

* Work on multiple branches in parallel
* Maintain release or hotfix branches
* Review PRs locally
* Want zero-friction context switching
* Value clean, predictable Git state

If you only ever work on one branch at a time, they may be unnecessary — but they never get in the way.

---

## Final Takeaway

`git worktree` doesn’t change Git’s model — it **reveals it**.

By separating *history* from *working state*, Git makes it trivial to have:

* Many working directories
* One shared truth
* Zero duplication
* Strong safety guarantees

Once you internalize this, worktrees stop feeling like a feature —
they start feeling like **the obvious way Git should be used**.