# Trace Call - LLM Usage Brief

**Version**: v3.59.2  
**Purpose**: Guide for LLMs and developers on using the call tracing/profiling system  
**Location**: `osbot_utils.helpers.trace`  
**Repo**: https://github.com/owasp-sbot/OSBot-Utils  
**Install**: `pip install osbot-utils`

---

## What is Trace_Call?

**Trace_Call is a powerful runtime introspection system that lets you see exactly what your Python code is doing‚Äîevery function call, every return, every line executed‚Äîwithout modifying a single line of the code you're investigating.**

Think of it as an X-ray machine for Python execution. You point it at any code‚Äîyours, a third-party library, or even the standard library‚Äîand it reveals the complete call hierarchy, timing information, variable states, and execution flow in real-time.

### The Problem It Solves

When working with Python code, developers frequently face these challenges:

1. **"What is this code actually doing?"** ‚Äî You're using a library or inherited codebase and need to understand its internal behavior without reading thousands of lines of source code.

2. **"Where is the time going?"** ‚Äî Your application is slow, but profilers give you flat lists of functions. You need to see the *call tree* to understand which path through the code is expensive.

3. **"What was the state when this broke?"** ‚Äî A bug occurs deep in a call stack, and you need to know what values variables had at each step leading to the failure.

4. **"How do different inputs change execution?"** ‚Äî You want to compare what code paths are taken for different inputs without manually adding print statements everywhere.

5. **"I can't modify this code"** ‚Äî The code you need to debug is in a third-party package, a compiled module, or a production system where changes aren't allowed.

Traditional debugging approaches‚Äîprint statements, breakpoints, logging‚Äîrequire you to *modify* the code and *know in advance* where to look. Trace_Call requires neither.

### How It Works

Trace_Call leverages Python's built-in `sys.settrace()` mechanism‚Äîthe same hook that debuggers and profilers use. When activated, Python's interpreter calls your trace function on every:

- **`call`** ‚Äî A function is about to execute
- **`return`** ‚Äî A function is about to return
- **`line`** ‚Äî A new line is about to execute
- **`exception`** ‚Äî An exception has been raised

Trace_Call intercepts these events and:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                           Python Interpreter                                 ‚îÇ
‚îÇ                                                                             ‚îÇ
‚îÇ    your_code()  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫  sys.settrace() hook  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫  Trace_Call          ‚îÇ
‚îÇ         ‚îÇ                       ‚îÇ                           ‚îÇ               ‚îÇ
‚îÇ         ‚îÇ                       ‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ         ‚ñº                       ‚îÇ                    ‚îÇ   Filter    ‚îÇ        ‚îÇ
‚îÇ    library_code()               ‚îÇ                    ‚îÇ  (include/  ‚îÇ        ‚îÇ
‚îÇ         ‚îÇ                       ‚îÇ                    ‚îÇ   exclude)  ‚îÇ        ‚îÇ
‚îÇ         ‚ñº                       ‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îÇ    deep_function()              ‚îÇ                           ‚îÇ               ‚îÇ
‚îÇ         ‚îÇ                       ‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ         ‚ñº                       ‚îÇ                    ‚îÇ Stack Tree  ‚îÇ        ‚îÇ
‚îÇ      returns                    ‚îÇ                    ‚îÇ  Builder    ‚îÇ        ‚îÇ
‚îÇ                                 ‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îÇ                                 ‚îÇ                           ‚îÇ               ‚îÇ
‚îÇ                                 ‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ                                 ‚îÇ                    ‚îÇ  Capture:   ‚îÇ        ‚îÇ
‚îÇ                                 ‚îÇ                    ‚îÇ  - Duration ‚îÇ        ‚îÇ
‚îÇ                                 ‚îÇ                    ‚îÇ  - Locals   ‚îÇ        ‚îÇ
‚îÇ                                 ‚îÇ                    ‚îÇ  - Source   ‚îÇ        ‚îÇ
‚îÇ                                 ‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îÇ                                 ‚îÇ                           ‚îÇ               ‚îÇ
‚îÇ                                 ‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ                                 ‚îÇ                    ‚îÇ   Output    ‚îÇ        ‚îÇ
‚îÇ                                 ‚îÇ                    ‚îÇ  (tree/     ‚îÇ        ‚îÇ
‚îÇ                                 ‚îÇ                    ‚îÇ   table)    ‚îÇ        ‚îÇ
‚îÇ                                 ‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**The key insight**: Because tracing happens at the interpreter level, it works on *any* Python code‚Äîyour code, libraries, frameworks‚Äîwithout requiring source access or modifications.

### The Power of Trace_Call

#### 1. Zero-Instrumentation Observability

```python
# You don't need to add ANY code to the library you're investigating
with Trace_Call() as trace:
    trace.config.trace_capture_start_with = ['requests']
    
    requests.get('https://api.example.com')  # Trace everything requests does internally
```

This traces the entire internal execution of the `requests` library‚ÄîHTTP connection handling, redirect logic, cookie processing‚Äîwithout touching its source.

#### 2. Hierarchical Call Trees (Not Flat Lists)

Unlike flat profilers that show "function X took 500ms," Trace_Call shows *why*:

```
üì¶  Trace Session
‚îÇ   ‚îî‚îÄ‚îÄ üîóÔ∏è process_request                                    523.45ms
‚îÇ       ‚îú‚îÄ‚îÄ üß©Ô∏è validate_input                                  12.34ms
‚îÇ       ‚îú‚îÄ‚îÄ üîóÔ∏è fetch_data                                     456.78ms
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üîóÔ∏è db_query                                   234.56ms
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üß©Ô∏è execute_sql                            230.12ms  ‚Üê THE BOTTLENECK
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ üîóÔ∏è api_call                                   220.11ms
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ üß©Ô∏è http_request                           218.90ms
‚îÇ       ‚îî‚îÄ‚îÄ üß©Ô∏è format_response                                 54.33ms
```

Now you can *see* that `execute_sql` inside `db_query` is the actual bottleneck, not just that `process_request` is slow.

#### 3. Surgical Filtering

The real world is noisy. A simple function call might trigger hundreds of internal calls through logging, caching, ORMs, and framework code. Trace_Call's filtering system lets you focus:

```python
trace.config.trace_capture_start_with = ['my_app.services']     # Only my code
trace.config.trace_ignore_start_with = ['my_app.services.cache'] # But not caching
trace.config.trace_up_to_depth = 5                               # Only 5 levels deep
trace.config.with_duration_bigger_than = 0.001                   # Only calls > 1ms
```

#### 4. Time-Travel Debugging via Local Capture

When you enable `capture_locals`, Trace_Call snapshots the local variables at each function call:

```
‚îÇ   ‚îú‚îÄ‚îÄ üîóÔ∏è process_order
‚îÇ          üîñ order_id   = 12345
‚îÇ          üîñ customer   = Customer(id=67, name='Alice')
‚îÇ          üîñ items      = [Item(sku='A1'), Item(sku='B2')]
‚îÇ          üîñ total      = 299.99
```

This is like having a debugger breakpoint at *every* function call, but captured automatically and reviewable after execution.

#### 5. Line-by-Line Execution Tracing

For the deepest debugging, enable line tracing to see exactly which lines executed:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ #   ‚îÇ Line ‚îÇ Source code                     ‚îÇ Method                   ‚îÇ Depth ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1   ‚îÇ   45 ‚îÇ   def process(self, data):     ‚îÇ Processor.process        ‚îÇ     1 ‚îÇ
‚îÇ 2   ‚îÇ   46 ‚îÇ       if data is None:         ‚îÇ Processor.process        ‚îÇ     1 ‚îÇ
‚îÇ 3   ‚îÇ   48 ‚îÇ       validated = self._val()  ‚îÇ Processor.process        ‚îÇ     1 ‚îÇ
‚îÇ 4   ‚îÇ   23 ‚îÇ     def _validate(self):       ‚îÇ Processor._validate      ‚îÇ     2 ‚îÇ
‚îÇ 5   ‚îÇ   24 ‚îÇ         return self.rules.check‚îÇ Processor._validate      ‚îÇ     2 ‚îÇ
```

This shows you the actual execution path, including which branches were taken.

#### 6. Production-Safe Design

Trace_Call can remain in your codebase with minimal risk:

```python
@trace_calls(include=['my_app'], enabled=DEBUG_MODE)  # Only traces when DEBUG_MODE=True
def critical_function():
    pass
```

When disabled, the decorator adds negligible overhead (~microseconds). This means you can leave tracing decorators in place and activate them only when needed.

### When to Use Trace_Call

| Situation | Trace_Call Approach |
|-----------|---------------------|
| Understanding unfamiliar code | `trace_capture_start_with=['unknown_lib']` + `trace_up_to_depth=4` |
| Finding performance bottlenecks | `capture_duration=True` + `with_duration_bigger_than=0.01` |
| Debugging variable state | `capture_locals=True` + `deep_copy_locals=True` |
| Comparing execution paths | Run twice with different inputs, compare `view_data()` |
| Understanding test failures | `@trace_calls` decorator on test methods |
| Reverse-engineering APIs | Trace the library while making API calls |

### Architecture Overview

```
Trace_Call (entry point)
    ‚îÇ
    ‚îú‚îÄ‚îÄ Trace_Call__Config        # 30+ configuration options
    ‚îÇ
    ‚îú‚îÄ‚îÄ Trace_Call__Handler       # sys.settrace() callback, event routing
    ‚îÇ       ‚îÇ
    ‚îÇ       ‚îú‚îÄ‚îÄ Trace_Call__Stack      # Call stack management
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ Trace_Call__Stack_Node  # Individual call records
    ‚îÇ       ‚îÇ
    ‚îÇ       ‚îî‚îÄ‚îÄ Trace_Call__Stats      # Call/return/line counters
    ‚îÇ
    ‚îú‚îÄ‚îÄ Trace_Call__View_Model    # Transforms stack into display format
    ‚îÇ
    ‚îú‚îÄ‚îÄ Trace_Call__Print_Traces  # Tree output (üì¶ üîóÔ∏è üß©Ô∏è)
    ‚îÇ
    ‚îî‚îÄ‚îÄ Trace_Call__Print_Lines   # Table output (line-by-line)
```

---

## Quick Start

### 1. Using the Context Manager

```python
from osbot_utils.helpers.trace.Trace_Call import Trace_Call

with Trace_Call() as trace:
    trace.config.trace_capture_start_with = ['my_module']  # Filter what to capture
    trace.config.print_traces_on_exit = True               # Auto-print on exit
    
    result = my_function()  # Your code here
```

### 2. Using the Decorator

```python
from osbot_utils.helpers.trace.Trace_Call import trace_calls

@trace_calls(include=['my_module'], print_traces=True)
def my_function():
    do_something()
    do_something_else()
    return result

my_function()  # Traces printed automatically
```

### 3. That's It

The tracer intercepts all Python function calls via `sys.settrace()`, filters based on your criteria, and builds a call tree you can inspect or print.

---

## Core Concepts

### How It Works

Trace_Call uses Python's `sys.settrace()` to intercept every function call, return, and line execution. It:

1. **Filters** calls based on module/function name patterns
2. **Builds** a tree structure representing the call hierarchy
3. **Captures** optional data (locals, duration, source code)
4. **Outputs** a visual tree or detailed line-by-line trace

### The Filtering Model

Traces capture EVERYTHING by default when `trace_capture_all=True`, or selectively using:

```python
# Capture methods in modules starting with these prefixes
config.trace_capture_start_with = ['my_app', 'my_lib']

# Capture methods containing these strings (module OR function name)
config.trace_capture_contains = ['process', 'handle']

# Ignore methods in modules/functions starting with these
config.trace_ignore_start_with = ['logging', 'debug_']

# Ignore methods containing these strings
config.trace_ignore_contains = ['_internal', '_cache']
```

**Filter Logic:**
1. Check `trace_capture_start_with` OR `trace_capture_contains` ‚Üí must match at least one
2. Check `trace_ignore_start_with` AND `trace_ignore_contains` ‚Üí must NOT match any
3. If `trace_show_internals=False`, skip functions starting with `_`

### Stack Tracking

The tracer maintains a stack of `Trace_Call__Stack_Node` objects. Each node contains:

- `name` - Full qualified name (e.g., `my_module.MyClass.my_method`)
- `func_name` - Just the function name
- `module` - Module name
- `children` - List of child nodes (calls made from this function)
- `locals` - Captured local variables (if enabled)
- `call_duration` - Execution time (if enabled)
- `source_code` - The actual source line (if enabled)

---

## Import Reference

```python
# Main tracer (context manager)
from osbot_utils.helpers.trace.Trace_Call import Trace_Call

# Decorator
from osbot_utils.helpers.trace.Trace_Call import trace_calls

# Configuration (usually accessed via trace.config)
from osbot_utils.helpers.trace.Trace_Call__Config import Trace_Call__Config

# For programmatic access to trace data
from osbot_utils.helpers.trace.Trace_Call__Handler import Trace_Call__Handler
from osbot_utils.helpers.trace.Trace_Call__Stack import Trace_Call__Stack
from osbot_utils.helpers.trace.Trace_Call__Stack_Node import Trace_Call__Stack_Node

# For custom output formatting
from osbot_utils.helpers.trace.Trace_Call__View_Model import Trace_Call__View_Model
from osbot_utils.helpers.trace.Trace_Call__Print_Traces import Trace_Call__Print_Traces
from osbot_utils.helpers.trace.Trace_Call__Print_Lines import Trace_Call__Print_Lines

# Statistics
from osbot_utils.helpers.trace.Trace_Call__Stats import Trace_Call__Stats
```

---

## Configuration Reference

### Basic Filtering Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `trace_capture_all` | bool | `False` | Capture ALL calls (ignores start_with/contains filters) |
| `trace_capture_start_with` | list | `[]` | Capture modules starting with these prefixes |
| `trace_capture_contains` | list | `[]` | Capture modules/functions containing these strings |
| `trace_ignore_start_with` | list | `[]` | Ignore modules/functions starting with these |
| `trace_ignore_contains` | list | `[]` | Ignore modules/functions containing these |
| `trace_show_internals` | bool | `False` | Include functions starting with `_` |
| `trace_up_to_depth` | int | `0` | Max call depth to capture (0 = unlimited) |
| `trace_enabled` | bool | `True` | Master switch to enable/disable tracing |

### Duration & Performance Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `capture_duration` | bool | `False` | Record execution time for each call |
| `print_duration` | bool | `False` | Show duration in output |
| `with_duration_bigger_than` | float | `0.0` | Only show calls taking longer than N seconds |
| `print_padding_duration` | int | `100` | Column width for duration display |

### Local Variables Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `capture_locals` | bool | `False` | Capture local variables at call time |
| `print_locals` | bool | `False` | Show locals in output |
| `deep_copy_locals` | bool | `False` | Deep copy locals (safer but slower) |
| `print_max_string_length` | int | `100` | Truncate strings longer than this |

### Source Code Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `trace_capture_source_code` | bool | `False` | Capture the source code line |
| `trace_capture_lines` | bool | `False` | Capture line-by-line execution |
| `show_source_code_path` | bool | `False` | Show file path in output |

### Output Formatting Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `print_traces_on_exit` | bool | `False` | Auto-print tree on context exit |
| `print_lines_on_exit` | bool | `False` | Auto-print line table on context exit |
| `show_method_class` | bool | `True` | Show `ClassName.method` format |
| `show_parent_info` | bool | `False` | Show full parent path |
| `print_padding_parent_info` | int | `60` | Column width for parent info |
| `title` | str | `''` | Custom title for trace session |

### Advanced Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `capture_frame` | bool | `True` | Store frame object in node |
| `capture_frame_stats` | bool | `False` | Collect raw frame statistics |
| `capture_extra_data` | bool | `False` | Capture return values |

---

## Usage Patterns

### Pattern 1: Trace Specific Modules

```python
from osbot_utils.helpers.trace.Trace_Call import Trace_Call

with Trace_Call() as trace:
    trace.config.trace_capture_start_with = ['my_app.services', 'my_app.models']
    trace.config.print_traces_on_exit = True
    
    result = my_app.services.process_request(data)

# Output shows only calls within my_app.services and my_app.models
```

### Pattern 2: Trace Everything Up to Depth N

```python
with Trace_Call() as trace:
    trace.config.trace_capture_all = True      # Capture everything
    trace.config.trace_up_to_depth = 3         # But only 3 levels deep
    trace.config.print_traces_on_exit = True
    
    complex_operation()
```

### Pattern 3: Duration Profiling

```python
with Trace_Call() as trace:
    trace.config.trace_capture_start_with = ['my_app']
    trace.config.capture_duration = True
    trace.config.print_duration = True
    trace.config.with_duration_bigger_than = 0.001  # Only show calls > 1ms
    trace.config.print_traces_on_exit = True
    
    slow_operation()
```

### Pattern 4: Capture Local Variables

```python
with Trace_Call() as trace:
    trace.config.trace_capture_start_with = ['my_app']
    trace.config.capture_locals = True
    trace.config.print_locals = True
    trace.config.print_traces_on_exit = True
    
    debug_this_function()

# Output shows local variables at each call site
```

### Pattern 5: Line-by-Line Tracing

```python
with Trace_Call() as trace:
    trace.config.trace_capture_start_with = ['my_app']
    trace.config.trace_capture_lines = True
    trace.config.print_lines_on_exit = True
    
    step_through_this()

# Output shows each line executed with line numbers
```

### Pattern 6: Using the Decorator

```python
from osbot_utils.helpers.trace.Trace_Call import trace_calls

# Full options via decorator
@trace_calls(
    include=['my_app'],           # trace_capture_start_with
    contains=['process'],         # trace_capture_contains
    ignore=['cache'],             # trace_ignore_start_with
    print_traces=True,            # print_traces_on_exit
    show_duration=True,           # capture_duration + print_duration
    show_locals=True,             # capture_locals + print_locals
    show_lines=True,              # trace_capture_lines
    trace_depth=5,                # trace_up_to_depth
    show_internals=False,         # trace_show_internals
    enabled=True                  # trace_enabled
)
def my_complex_function():
    # All calls from here are traced
    pass
```

### Pattern 7: Using Config Fluent API

```python
with Trace_Call() as trace:
    trace.config.all(up_to_depth=3, print_traces=True)  # Capture all, depth 3
    trace.config.duration(bigger_than=0.001)             # With timing > 1ms
    trace.config.locals()                                 # With local variables
    
    my_function()
```

### Pattern 8: Programmatic Access to Trace Data

```python
with Trace_Call() as trace:
    trace.config.trace_capture_start_with = ['my_app']
    my_function()

# Access the trace tree
view_data = trace.view_data()  # List of trace entries

for entry in view_data:
    print(f"{entry['method_name']}: {entry['duration']:.3f}s")

# Access statistics
stats = trace.stats()
print(f"Total calls: {stats['calls']}")
print(f"Calls captured: {stats['calls'] - stats['calls_skipped']}")
```

### Pattern 9: Filter by Contains (Module OR Function)

```python
with Trace_Call() as trace:
    # Captures any call where module OR function name contains 'save' or 'load'
    trace.config.trace_capture_contains = ['save', 'load']
    trace.config.print_traces_on_exit = True
    
    data_processor.run()  # Will trace any save/load operations
```

### Pattern 10: Combining Filters

```python
with Trace_Call() as trace:
    # Capture my_app modules, but ignore caching and logging
    trace.config.trace_capture_start_with = ['my_app']
    trace.config.trace_ignore_start_with = ['my_app.cache', 'my_app.logging']
    trace.config.trace_ignore_contains = ['_debug', '_trace']
    trace.config.trace_show_internals = False  # Skip _private methods
    trace.config.print_traces_on_exit = True
    
    my_app.run()
```

---

## Output Interpretation

### Tree Output (print_traces)

```
--------- CALL TRACER ----------
Here are the 6 traces captured

üì¶  Trace Session
‚îÇ   ‚îú‚îÄ‚îÄ üîóÔ∏è MyClass.process
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üß©Ô∏è MyClass._parse
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üîóÔ∏è MyClass._transform
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ üß©Ô∏è Helper.convert
‚îÇ   ‚îî‚îÄ‚îÄ üß©Ô∏è MyClass._output
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ üß©Ô∏è final_cleanup
```

**Emoji Meanings:**

| Emoji | Meaning |
|-------|---------|
| üì¶ | Root node (trace session start) |
| üîóÔ∏è | Node with children (made calls to other traced functions) |
| üß©Ô∏è | Leaf node (no children, or children not captured) |

**Tree Structure:**

- `‚îÇ` - Vertical line showing hierarchy
- `‚îú‚îÄ‚îÄ` - Branch to sibling (more siblings follow)
- `‚îî‚îÄ‚îÄ` - Last branch (no more siblings)

### Line Output (print_lines)

```
--------- CALL TRACER (Lines)----------
Here are the 13 lines captured

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ #   ‚îÇ Line ‚îÇ Source code                     ‚îÇ Method Class and Name        ‚îÇ Self object ‚îÇ Depth ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1   ‚îÇ   25 ‚îÇ   def process(self, data):     ‚îÇ my_module.MyClass.process    ‚îÇ MyClass     ‚îÇ     1 ‚îÇ
‚îÇ 2   ‚îÇ   26 ‚îÇ       parsed = self._parse()   ‚îÇ my_module.MyClass.process    ‚îÇ MyClass     ‚îÇ     1 ‚îÇ
‚îÇ 3   ‚îÇ   42 ‚îÇ     def _parse(self):          ‚îÇ my_module.MyClass._parse     ‚îÇ MyClass     ‚îÇ     2 ‚îÇ
...
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Columns:**

| Column | Description |
|--------|-------------|
| # | Sequential line index |
| Line | Line number in source file |
| Source code | The actual code (indented by depth) |
| Method Class and Name | `module.class.method` |
| Self object | Class name of `self` if present |
| Depth | Call stack depth |

### Duration Output

When `print_duration=True`:

```
üì¶  Trace Session
‚îÇ   ‚îú‚îÄ‚îÄ üîóÔ∏è MyClass.process                                           125.432ms
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üß©Ô∏è MyClass._parse                                         45.123ms
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üîóÔ∏è MyClass._transform                                     78.901ms
```

### Locals Output

When `print_locals=True`:

```
‚îÇ   ‚îú‚îÄ‚îÄ üîóÔ∏è MyClass.process
‚îÇ          üîñ data     = {'key': 'value'}
‚îÇ          üîñ options  = ProcessOptions
‚îÇ          üîñ timeout  = 30
```

---

## Best Practices

### DO: Use Specific Filters

```python
# ‚úÖ Good - specific module prefix
trace.config.trace_capture_start_with = ['my_app.services.payment']

# ‚ùå Bad - too broad, will capture everything
trace.config.trace_capture_all = True
```

### DO: Limit Depth for Exploratory Tracing

```python
# ‚úÖ Good - manageable output
trace.config.trace_capture_all = True
trace.config.trace_up_to_depth = 3

# ‚ùå Bad - overwhelming output for complex code
trace.config.trace_capture_all = True
# trace_up_to_depth = 0 (unlimited)
```

### DO: Use Duration Filtering for Performance Analysis

```python
# ‚úÖ Good - focus on slow calls
trace.config.capture_duration = True
trace.config.with_duration_bigger_than = 0.01  # Only show > 10ms

# ‚ùå Less useful - shows everything including micro-calls
trace.config.capture_duration = True
trace.config.with_duration_bigger_than = 0  # Shows all
```

### DO: Ignore Noisy Modules

```python
# ‚úÖ Good - clean output
trace.config.trace_capture_start_with = ['my_app']
trace.config.trace_ignore_start_with = ['my_app.logging', 'my_app.metrics']

# ‚ùå Bad - log and metric calls clutter the trace
trace.config.trace_capture_start_with = ['my_app']
```

### DON'T: Leave Tracing Enabled in Production

```python
# ‚úÖ Good - conditional tracing
@trace_calls(include=['my_app'], enabled=DEBUG_MODE)
def production_function():
    pass

# ‚ùå Bad - always tracing
@trace_calls(include=['my_app'], enabled=True)  # In production code
def production_function():
    pass
```

### DON'T: Capture Locals in Performance-Sensitive Code

```python
# ‚úÖ Good for debugging - captures locals
trace.config.capture_locals = True
trace.config.deep_copy_locals = True  # Safe but slow

# ‚úÖ Good for performance profiling - skip locals
trace.config.capture_duration = True
trace.config.capture_locals = False  # Faster
```

### DON'T: Use trace_capture_all Without Depth Limit

```python
# ‚ùå Dangerous - can produce gigabytes of output
trace.config.trace_capture_all = True

# ‚úÖ Safe - bounded output
trace.config.trace_capture_all = True
trace.config.trace_up_to_depth = 5
```

---

## Common Integration Scenarios

### Scenario: Understanding Unfamiliar Code

```python
from osbot_utils.helpers.trace.Trace_Call import Trace_Call

def explore_library(input_data):
    """Trace a library to understand its call flow."""
    
    with Trace_Call() as trace:
        trace.config.trace_capture_start_with = ['unknown_library']
        trace.config.trace_up_to_depth = 4
        trace.config.show_method_class = True
        trace.config.print_traces_on_exit = True
        
        result = unknown_library.process(input_data)
    
    return result

# Now you can see exactly what unknown_library.process() does internally
```

### Scenario: Finding Performance Bottlenecks

```python
def profile_slow_operation():
    """Find which functions are taking the most time."""
    
    with Trace_Call() as trace:
        trace.config.trace_capture_start_with = ['my_app']
        trace.config.capture_duration = True
        trace.config.print_duration = True
        trace.config.with_duration_bigger_than = 0.005  # Show > 5ms only
        trace.config.print_traces_on_exit = True
        
        my_app.slow_operation()
    
    # Output shows only slow calls with their durations
```

### Scenario: Debugging Variable State

```python
def debug_unexpected_behavior():
    """Capture local variables to understand state at each call."""
    
    with Trace_Call() as trace:
        trace.config.trace_capture_start_with = ['my_app.buggy_module']
        trace.config.capture_locals = True
        trace.config.print_locals = True
        trace.config.deep_copy_locals = True  # Capture state at call time
        trace.config.print_traces_on_exit = True
        
        my_app.buggy_module.process(data)
    
    # Output shows variable values at each function call
```

### Scenario: Tracing Test Execution

```python
from osbot_utils.helpers.trace.Trace_Call import trace_calls

class TestMyFeature:
    
    @trace_calls(include=['my_app'], print_traces=True, trace_depth=3)
    def test_complex_feature(self):
        """Test with automatic call tracing."""
        result = my_app.complex_feature()
        assert result.is_valid()
    
    # Trace is printed after test completes (pass or fail)
```

### Scenario: Comparing Execution Paths

```python
def compare_code_paths(input_a, input_b):
    """Compare what gets called for different inputs."""
    
    # Trace path A
    with Trace_Call() as trace_a:
        trace_a.config.trace_capture_start_with = ['my_app']
        my_app.process(input_a)
    
    # Trace path B
    with Trace_Call() as trace_b:
        trace_b.config.trace_capture_start_with = ['my_app']
        my_app.process(input_b)
    
    # Compare
    methods_a = {entry['method_name'] for entry in trace_a.view_data()}
    methods_b = {entry['method_name'] for entry in trace_b.view_data()}
    
    only_in_a = methods_a - methods_b
    only_in_b = methods_b - methods_a
    
    print(f"Only called with input_a: {only_in_a}")
    print(f"Only called with input_b: {only_in_b}")
```

### Scenario: Generating Call Statistics

```python
def analyze_call_patterns():
    """Get statistics about call patterns."""
    
    with Trace_Call() as trace:
        trace.config.trace_capture_start_with = ['my_app']
        trace.config.capture_frame_stats = True
        
        my_app.run_batch_job()
    
    # Get raw statistics
    stats = trace.stats()
    print(f"Total calls intercepted: {stats['calls']}")
    print(f"Calls captured: {stats['calls'] - stats['calls_skipped']}")
    print(f"Return events: {stats['returns']}")
    print(f"Line events: {stats['lines']}")
    
    # Get detailed frame stats (if capture_frame_stats=True)
    handler = trace.trace_call_handler
    frame_stats = handler.stats.frames_stats()
    # Returns nested dict: module -> class -> method -> count
```

---

## Troubleshooting

### Problem: No Traces Captured

**Cause 1**: Filter doesn't match any modules

```python
# ‚ùå Wrong module name
trace.config.trace_capture_start_with = ['myapp']  # Missing underscore

# ‚úÖ Correct module name
trace.config.trace_capture_start_with = ['my_app']
```

**Cause 2**: Tracing disabled

```python
# Check these aren't blocking capture
assert trace.config.trace_enabled == True
assert trace.started == True  # After entering context
```

**Cause 3**: All calls filtered by ignore rules

```python
# Check ignore lists aren't too broad
print(trace.config.trace_ignore_start_with)
print(trace.config.trace_ignore_contains)
```

### Problem: Too Much Output

**Solution 1**: Add depth limit

```python
trace.config.trace_up_to_depth = 3
```

**Solution 2**: Add ignore patterns

```python
trace.config.trace_ignore_start_with = ['logging', 'metrics', 'cache']
```

**Solution 3**: Use duration filter

```python
trace.config.capture_duration = True
trace.config.with_duration_bigger_than = 0.001  # Only > 1ms
```

### Problem: Missing Internal/Private Methods

**Cause**: `trace_show_internals` is False (default)

```python
# ‚úÖ Include methods starting with _
trace.config.trace_show_internals = True
```

### Problem: Locals Show Wrong Values

**Cause**: Locals captured by reference, values changed later

```python
# ‚úÖ Deep copy locals at capture time
trace.config.capture_locals = True
trace.config.deep_copy_locals = True
```

### Problem: Trace Interferes with Debugger

**Cause**: Both use `sys.settrace()`

**Solution**: Disable tracing when debugging

```python
@trace_calls(include=['my_app'], enabled=not_debugging())
def my_function():
    pass

def not_debugging():
    import sys
    return sys.gettrace() is None
```

### Problem: High Overhead

**Cause**: Tracing everything or capturing too much data

**Solution**: Be selective

```python
# ‚ùå Expensive
trace.config.trace_capture_all = True
trace.config.capture_locals = True
trace.config.deep_copy_locals = True
trace.config.trace_capture_lines = True

# ‚úÖ Lean
trace.config.trace_capture_start_with = ['my_app.target_module']
trace.config.trace_up_to_depth = 3
```

### Problem: "TypeError" or Serialization Errors in Locals

**Cause**: Some local variables can't be printed/copied

**Solution**: The tracer handles errors gracefully, but you can also:

```python
# Skip locals capture if causing issues
trace.config.capture_locals = False

# Or increase string truncation
trace.config.print_max_string_length = 50
```

---

## Summary Checklist

When adding call tracing to investigate code:

- [ ] Import `Trace_Call` or `trace_calls` decorator
- [ ] Choose filtering strategy:
  - [ ] `trace_capture_start_with` for specific modules
  - [ ] `trace_capture_contains` for pattern matching
  - [ ] `trace_capture_all` + `trace_up_to_depth` for exploration
- [ ] Add ignore patterns for noisy modules (`logging`, `cache`, etc.)
- [ ] Set `trace_show_internals=True` if you need `_private` methods
- [ ] For performance profiling:
  - [ ] Enable `capture_duration` and `print_duration`
  - [ ] Set `with_duration_bigger_than` to filter noise
- [ ] For debugging:
  - [ ] Enable `capture_locals` and `print_locals`
  - [ ] Use `deep_copy_locals=True` for accurate snapshots
- [ ] For detailed analysis:
  - [ ] Enable `trace_capture_lines` for line-by-line
  - [ ] Use `view_data()` for programmatic access
- [ ] Remember:
  - [ ] `trace_up_to_depth` prevents overwhelming output
  - [ ] Decorator is convenient; context manager offers more control
  - [ ] Tracing adds overhead; disable in production
  - [ ] Can't run alongside debugger (both use `sys.settrace`)
