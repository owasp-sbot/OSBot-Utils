# AST Helpers - LLM Usage Brief

**Version**: v3.63.0  
**Purpose**: Guide for LLMs and developers on using the Python AST parsing and manipulation toolkit  
**Location**: `osbot_utils.helpers.ast`  
**Repo**: https://github.com/owasp-sbot/OSBot-Utils  
**Install**: `pip install osbot-utils`

---

## What is the AST Helpers Toolkit?

**The AST helpers toolkit is a clean, object-oriented wrapper around Python's `ast` module that transforms raw AST nodes into a navigable, type-safe object graph.** Instead of wrestling with Python's native AST API (which returns generic node objects requiring constant type-checking and attribute access), you get strongly-typed wrapper classes with intuitive methods for each AST node type.

### The Problem It Solves

Python's built-in `ast` module is powerful but awkward:

```python
# Standard library - verbose and error-prone
import ast

source = "def add(a, b): return a + b"
tree = ast.parse(source)

# What type is this node? Have to check manually
func_node = tree.body[0]
if isinstance(func_node, ast.FunctionDef):
    # Access raw attributes - easy to get wrong
    func_name = func_node.name
    args = func_node.args.args  # Wait, is it .args.args or just .args?
    
    # Walking the tree? Manual recursion
    for node in ast.walk(tree):
        if isinstance(node, ast.Call):
            # More type checking...
            pass

# Dumping for debugging is clunky
print(ast.dump(tree, indent=4))

# JSON serialization? You're on your own
```

**With OSBot-Utils AST helpers:**

```python
from osbot_utils.helpers.ast import Ast_Module

source = "def add(a, b): return a + b"
module = Ast_Module(source)

# Strongly-typed access
func = module.body()[0]                    # Returns Ast_Function_Def
print(func.name())                         # 'add'
print(func.args())                         # Returns Ast_Arguments

# JSON-friendly data structures
print(module.json())                       # Clean dict output

# Execute and inspect
result = module.execute_code()             # {'status': 'ok', 'locals': {...}}

# Visitor pattern built in
from osbot_utils.helpers.ast.Ast_Visit import Ast_Visit
with Ast_Visit(module) as visitor:
    visitor.capture_functions()
    visitor.capture_calls()
    visitor.visit()
    print(visitor.stats())                 # {'Ast_Function_Def': 1, 'Ast_Call': 0}
```

### Design Philosophy

1. **One class per AST node type** — `Ast_Call`, `Ast_Function_Def`, `Ast_If` etc. wrap their native counterparts
2. **Automatic type resolution** — The `Type_Registry` maps `ast.FunctionDef` → `Ast_Function_Def` automatically
3. **Consistent interface** — Every wrapper has `.info()` for structured data, `.json()` for serialization
4. **Source code round-trip** — Parse, modify, regenerate valid Python via `.source_code()`
5. **Visitor pattern support** — `Ast_Visit` captures specific node types with callbacks

### Key Capabilities

#### 1. Parse Anything

```python
from osbot_utils.helpers.ast import Ast_Module

# From source code string
module = Ast_Module("x = 42")

# From a file path
module = Ast_Module("/path/to/file.py")

# From a Python object (class, function, etc.)
module = Ast_Module(MyClass)
```

#### 2. Navigate with Type Safety

```python
func = module.body()[0]                    # Ast_Function_Def
print(type(func).__name__)                 # 'Ast_Function_Def'
print(func.args())                         # Ast_Arguments
print(func.body())                         # [Ast_Return, ...]

# Each node type exposes its relevant attributes as methods
if_stmt = Ast_If(some_if_node)
print(if_stmt.test())                      # The condition
print(if_stmt.body())                      # True branch
print(if_stmt.orelse())                    # Else branch
```

#### 3. Serialize to JSON

```python
data = module.json()
# {
#   'Ast_Module': {
#     'body': [
#       {'Ast_Assign': {'targets': [...], 'value': {...}}}
#     ]
#   }
# }
```

#### 4. Execute Dynamically

```python
result = Ast_Module("x = 42").execute_code()
print(result['locals']['x'])               # 42
print(result['status'])                    # 'ok'

# Even functions
code = "def greet(name): return f'Hello {name}'"
result = Ast_Module(code).execute_code()
greet = result['locals']['greet']
print(greet('World'))                      # 'Hello World'
```

#### 5. Visit and Capture Nodes

```python
from osbot_utils.helpers.ast.Ast_Visit import Ast_Visit

with Ast_Visit("/path/to/file.py") as visitor:
    visitor.capture_imports()
    visitor.capture_functions()
    visitor.capture_calls()
    visitor.visit()
    
    captured = visitor.captured_nodes()
    print(f"Found {len(captured['Ast_Import'])} imports")
    print(f"Found {len(captured['Ast_Function_Def'])} functions")
```

---

## Quick Start

### Basic Parsing and Inspection

```python
from osbot_utils.helpers.ast import Ast_Module

# Parse source code
source = """
def calculate(x, y):
    result = x + y
    return result
"""
module = Ast_Module(source)

# Get the function definition
func = module.body()[0]
print(func.name())                         # 'calculate'

# Inspect arguments
args = func.args()
print(args.args())                         # [Ast_Argument, Ast_Argument]

# Get structured info
print(func.json())

# Regenerate source code
print(module.source_code())
```

### Visiting and Collecting Nodes

```python
from osbot_utils.helpers.ast.Ast_Visit import Ast_Visit

# Parse and visit
with Ast_Visit("import os\nimport sys\ndef main(): pass") as v:
    v.capture_imports()
    v.capture_functions()
    v.visit()
    
    imports = v.captured_nodes()['Ast_Import']
    functions = v.captured_nodes()['Ast_Function_Def']
    print(f"Imports: {len(imports)}, Functions: {len(functions)}")
```

### Loading Multiple Files

```python
from osbot_utils.helpers.ast.Ast_Load import Ast_Load

loader = Ast_Load()
loader.load_files(['/path/file1.py', '/path/file2.py'])

stats = loader.stats()
print(f"Visited {stats['node_count']} nodes")
print(f"Found {stats['nodes'].get('Ast_Class_Def', 0)} classes")
print(f"Found {stats['nodes'].get('Ast_Function_Def', 0)} functions")
```

### Merging AST Modules

```python
from osbot_utils.helpers.ast.Ast_Merge import Ast_Merge
from osbot_utils.helpers.ast import Ast_Module

merger = Ast_Merge()
merger.merge_module(Ast_Module("a = 1"))
merger.merge_module(Ast_Module("b = 2"))
merger.merge_module(Ast_Module("def add(): return a + b"))

print(merger.source_code())
# a = 1
# 
# b = 2
# 
# def add(): return a + b
```

---

## Import Reference

### Core Classes

```python
# Main entry point - parse source/file/object into AST
from osbot_utils.helpers.ast.nodes.Ast_Module import Ast_Module

# Base class for all AST wrappers
from osbot_utils.helpers.ast.Ast_Base import Ast_Base

# Generic node wrapper (used when specific type not registered)
from osbot_utils.helpers.ast.Ast_Node import Ast_Node

# Visitor pattern implementation
from osbot_utils.helpers.ast.Ast_Visit import Ast_Visit

# Multi-file loading with statistics
from osbot_utils.helpers.ast.Ast_Load import Ast_Load

# Merge multiple AST modules
from osbot_utils.helpers.ast.Ast_Merge import Ast_Merge

# High-level convenience class
from osbot_utils.helpers.ast.Ast import Ast
```

### Node Type Wrappers

All node types are automatically registered and resolved. Import from the package:

```python
from osbot_utils.helpers.ast import (
    # Statements
    Ast_Module, Ast_Function_Def, Ast_Class_Def,
    Ast_If, Ast_For, Ast_While, Ast_With, Ast_Try,
    Ast_Assign, Ast_Aug_Assign, Ast_Return, Ast_Raise,
    Ast_Import, Ast_Import_From, Ast_Pass, Ast_Break, Ast_Continue,
    
    # Expressions
    Ast_Call, Ast_Attribute, Ast_Subscript, Ast_Name,
    Ast_Constant, Ast_List, Ast_Dict, Ast_Set, Ast_Tuple,
    Ast_Bin_Op, Ast_Unary_Op, Ast_Bool_Op, Ast_Compare,
    Ast_Lambda, Ast_If_Exp, Ast_List_Comp, Ast_Generator_Exp,
    
    # Operators
    Ast_Add, Ast_Sub, Ast_Mult, Ast_Mod, Ast_Pow,
    Ast_Eq, Ast_Not_Eq, Ast_Lt, Ast_LtE, Ast_Gt, Ast_GtE,
    Ast_And, Ast_Or, Ast_Not, Ast_In, Ast_Not_In, Ast_Is, Ast_Is_Not,
    
    # Components
    Ast_Arguments, Ast_Argument, Ast_Keyword, Ast_Alias,
    Ast_Except_Handler, Ast_With_Item, Ast_Comprehension,
    
    # Contexts
    Ast_Load, Ast_Store,
)
```

---

## API Reference by Category

### Ast_Module (Entry Point)

| Method | Description | Returns |
|--------|-------------|---------|
| `Ast_Module(target)` | Parse source string, file path, or Python object | `Ast_Module` |
| `.body()` | Get top-level statements | `List[Ast_Node]` |
| `.info()` | Get structured representation | `dict` |
| `.json()` | Get JSON-serializable dict | `dict` |
| `.source_code()` | Regenerate Python source | `str` |
| `.execute_code(exec_locals, exec_namespace)` | Execute the code | `dict` with status/locals |
| `.dump()` | Get `ast.dump()` output | `str` |
| `.all_ast_nodes()` | Walk all nodes in tree | `List[Ast_Node]` |
| `.stats()` | Get node type statistics | `dict` |

### Ast_Visit (Visitor Pattern)

| Method | Description | Returns |
|--------|-------------|---------|
| `Ast_Visit(target)` | Create visitor for module/source/path | `Ast_Visit` |
| `.capture(node_type, callback)` | Capture specific node type | `self` |
| `.capture_calls(callback)` | Capture `Ast_Call` nodes | `self` |
| `.capture_imports(callback)` | Capture import nodes | `self` |
| `.capture_functions(callback)` | Capture function definitions | `self` |
| `.capture_modules(callback)` | Capture modules | `self` |
| `.register_node_handler(type, handler)` | Register callback for node type | `self` |
| `.visit()` | Execute the visit | `self` |
| `.captured_nodes()` | Get captured nodes by type | `dict` |
| `.stats()` | Get capture statistics | `dict` |

### Ast_Load (Multi-File Loading)

| Method | Description | Returns |
|--------|-------------|---------|
| `Ast_Load()` | Create loader instance | `Ast_Load` |
| `.load_file(path)` | Load single file | `bool` |
| `.load_files(paths)` | Load multiple files | `None` |
| `.load_target(target)` | Load from Python object path | `bool` |
| `.stats()` | Get loading statistics | `dict` |

### Ast_Merge (Module Merging)

| Method | Description | Returns |
|--------|-------------|---------|
| `Ast_Merge()` | Create empty merge container | `Ast_Merge` |
| `.merge_file(path)` | Merge file into container | `bool` |
| `.merge_module(ast_module)` | Merge Ast_Module | `bool` |
| `.source_code()` | Get merged source code | `str` |
| `.module` | Access underlying Ast_Module | `Ast_Module` |

### Common Node Methods

All `Ast_Node` subclasses inherit these methods:

| Method | Description | Returns |
|--------|-------------|---------|
| `.info()` | Structured representation of node | `dict` |
| `.json()` | JSON-serializable representation | `dict` |
| `.source_code()` | Regenerate source for this node | `str` |
| `.dump()` | AST dump output | `str` |
| `.node` | Access underlying `ast.*` node | `ast.AST` |
| `.key()` | Node's class name | `str` |

### Node-Specific Accessors

Each node type provides accessors for its fields:

```python
# Ast_Function_Def
func.name()                                # str - function name
func.args()                                # Ast_Arguments
func.body()                                # List[Ast_Node]

# Ast_Class_Def
cls.name                                   # str - class name
cls.bases()                                # List[Ast_Node] - base classes
cls.body()                                 # List[Ast_Node] - class body

# Ast_Call
call.func()                                # Ast_Node - callable
call.args()                                # List[Ast_Node] - positional args
call.keywords()                            # List[Ast_Keyword] - keyword args
call.name()                                # str or None - resolved name

# Ast_If
if_stmt.test()                             # Ast_Node - condition
if_stmt.body()                             # List[Ast_Node] - true branch
if_stmt.orelse()                           # List[Ast_Node] - else branch

# Ast_For
for_stmt.target()                          # Ast_Node - loop variable
for_stmt.iter()                            # Ast_Node - iterable
for_stmt.body()                            # List[Ast_Node]
for_stmt.orelse()                          # List[Ast_Node]

# Ast_Assign
assign.targets()                           # List[Ast_Node] - assignment targets
assign.value()                             # Ast_Node - assigned value

# Ast_Import_From
import_from.module()                       # str - module name
import_from.names()                        # List[Ast_Alias]
import_from.level()                        # int - relative import level
```

---

## Usage Patterns

### Pattern 1: Analyze Function Signatures

```python
from osbot_utils.helpers.ast import Ast_Module

def analyze_functions(source_path):
    module = Ast_Module(source_path)
    results = []
    
    for node in module.body():
        if type(node).__name__ == 'Ast_Function_Def':
            args = node.args()
            arg_names = [arg.node.arg for arg in args.args()]
            results.append({
                'name': node.name(),
                'args': arg_names,
                'body_lines': len(node.body())
            })
    
    return results
```

### Pattern 2: Extract All Imports

```python
from osbot_utils.helpers.ast.Ast_Visit import Ast_Visit

def get_imports(source):
    with Ast_Visit(source) as visitor:
        visitor.capture_imports()
        visitor.visit()
        
        imports = []
        for node in visitor.captured_nodes().get('Ast_Import', []):
            for alias in node.names():
                imports.append(alias.node.name)
        
        for node in visitor.captured_nodes().get('Ast_Import_From', []):
            module = node.module()
            for alias in node.names():
                imports.append(f"{module}.{alias.node.name}")
        
        return imports
```

### Pattern 3: Find Function Calls

```python
from osbot_utils.helpers.ast.Ast_Visit import Ast_Visit

def find_calls_to(source, function_name):
    """Find all calls to a specific function."""
    calls = []
    
    with Ast_Visit(source) as visitor:
        def on_call(node):
            if node.name() == function_name:
                calls.append({
                    'args': len(node.args()),
                    'kwargs': [kw.node.arg for kw in node.keywords()]
                })
        
        visitor.register_node_handler('Ast_Call', on_call)
        visitor.visit()
    
    return calls
```

### Pattern 4: Code Generation via Merging

```python
from osbot_utils.helpers.ast.Ast_Merge import Ast_Merge
from osbot_utils.helpers.ast import Ast_Module

def generate_test_file(class_source):
    """Generate test skeleton from class definition."""
    merger = Ast_Merge()
    
    # Add imports
    merger.merge_module(Ast_Module("import unittest"))
    merger.merge_module(Ast_Module("from unittest.mock import patch, MagicMock"))
    
    # Parse class and generate test methods
    cls_module = Ast_Module(class_source)
    class_def = cls_module.body()[0]
    
    test_class = f"""
class Test_{class_def.node.name}(unittest.TestCase):
    def setUp(self):
        self.instance = {class_def.node.name}()
"""
    
    for node in class_def.body():
        if type(node).__name__ == 'Ast_Function_Def':
            method_name = node.name()
            if not method_name.startswith('_'):
                test_class += f"""
    def test_{method_name}(self):
        # TODO: implement test
        pass
"""
    
    merger.merge_module(Ast_Module(test_class))
    return merger.source_code()
```

### Pattern 5: Dynamic Code Execution

```python
from osbot_utils.helpers.ast import Ast_Module

def run_sandboxed(code, provided_locals=None):
    """Execute code with controlled namespace."""
    module = Ast_Module(code)
    
    # Restricted namespace (no builtins by default is too restrictive)
    namespace = {'__builtins__': {'print': print, 'len': len, 'range': range}}
    locals_dict = provided_locals or {}
    
    result = module.execute_code(
        exec_locals=locals_dict,
        exec_namespace=namespace
    )
    
    if result['status'] == 'error':
        raise RuntimeError(f"Execution failed: {result['error']}")
    
    return result['locals']
```

### Pattern 6: Codebase Statistics

```python
from osbot_utils.helpers.ast.Ast_Load import Ast_Load
from osbot_utils.utils.Files import files_list

def analyze_codebase(root_path):
    """Get comprehensive stats for a Python codebase."""
    py_files = files_list(root_path, pattern='*.py')
    
    loader = Ast_Load()
    loader.load_files(py_files)
    
    stats = loader.stats()
    return {
        'files': len(stats['files_visited']),
        'total_nodes': stats['node_count'],
        'classes': stats['nodes'].get('Ast_Class_Def', 0),
        'functions': stats['nodes'].get('Ast_Function_Def', 0),
        'imports': stats['nodes'].get('Ast_Import', 0) + 
                   stats['nodes'].get('Ast_Import_From', 0),
        'calls': stats['nodes'].get('Ast_Call', 0),
    }
```

### Pattern 7: Transform Source Code

```python
from osbot_utils.helpers.ast import Ast_Module

def add_docstring_to_functions(source):
    """Add placeholder docstrings to functions without them."""
    module = Ast_Module(source)
    
    for node in module.all_ast_nodes():
        if type(node).__name__ == 'Ast_Function_Def':
            body = node.body()
            # Check if first statement is a docstring
            if body and type(body[0]).__name__ != 'Ast_Expr':
                # Would need to modify the actual ast.node to add docstring
                # This pattern shows inspection - modification requires
                # working with the underlying node.node object
                pass
    
    return module.source_code()
```

---

## Common Recipes

### Recipe: Check if Code Has Specific Pattern

```python
from osbot_utils.helpers.ast.Ast_Visit import Ast_Visit

def has_recursive_call(func_source):
    """Check if function calls itself."""
    module = Ast_Visit(func_source)
    module.capture_functions()
    module.capture_calls()
    module.visit()
    
    functions = module.captured_nodes()['Ast_Function_Def']
    calls = module.captured_nodes()['Ast_Call']
    
    if not functions:
        return False
    
    func_name = functions[0].name()
    return any(call.name() == func_name for call in calls)
```

### Recipe: Get Complexity Metrics

```python
from osbot_utils.helpers.ast import Ast_Module

def count_branches(source):
    """Count branching statements (simple complexity metric)."""
    module = Ast_Module(source)
    
    branch_types = {'Ast_If', 'Ast_For', 'Ast_While', 'Ast_Try', 'Ast_With'}
    count = 0
    
    for node in module.all_ast_nodes():
        if type(node).__name__ in branch_types:
            count += 1
    
    return count
```

### Recipe: Extract String Literals

```python
from osbot_utils.helpers.ast import Ast_Module

def get_all_strings(source):
    """Extract all string literals from source."""
    module = Ast_Module(source)
    strings = []
    
    for node in module.all_ast_nodes():
        if type(node).__name__ == 'Ast_Constant':
            value = node.value()
            if isinstance(value, str):
                strings.append(value)
    
    return strings
```

### Recipe: Compare AST Structures

```python
from osbot_utils.helpers.ast import Ast_Module

def ast_equals(source1, source2):
    """Check if two sources have identical AST structure."""
    json1 = Ast_Module(source1).json()
    json2 = Ast_Module(source2).json()
    return json1 == json2

# Formatting differences don't matter:
assert ast_equals("x=1+2", "x = 1 + 2")  # True
assert ast_equals("a=1", "b=1")          # False (different variable name)
```

### Recipe: Find Unused Imports

```python
from osbot_utils.helpers.ast.Ast_Visit import Ast_Visit

def find_unused_imports(source):
    """Find imports that are never used."""
    visitor = Ast_Visit(source)
    visitor.capture_imports()
    visitor.capture('Ast_Name', None)
    visitor.visit()
    
    captured = visitor.captured_nodes()
    
    # Collect imported names
    imported = set()
    for imp in captured.get('Ast_Import', []):
        for alias in imp.names():
            name = alias.node.asname or alias.node.name
            imported.add(name.split('.')[0])
    
    for imp in captured.get('Ast_Import_From', []):
        for alias in imp.names():
            name = alias.node.asname or alias.node.name
            imported.add(name)
    
    # Collect used names
    used = set()
    for name_node in captured.get('Ast_Name', []):
        used.add(name_node.id())
    
    return imported - used
```

---

## Best Practices

### DO: Use Ast_Module as Entry Point

```python
# ✅ Good - handles strings, paths, and objects
from osbot_utils.helpers.ast import Ast_Module

module = Ast_Module("x = 1")           # String
module = Ast_Module("/path/to/file.py") # File path
module = Ast_Module(MyClass)            # Python object
```

### DO: Use Ast_Visit for Node Collection

```python
# ✅ Good - clean visitor pattern
from osbot_utils.helpers.ast.Ast_Visit import Ast_Visit

with Ast_Visit(source) as v:
    v.capture_functions()
    v.capture_calls()
    v.visit()
    # Access v.captured_nodes()
```

### DO: Check Node Types by Class Name

```python
# ✅ Good - string comparison is reliable
if type(node).__name__ == 'Ast_Function_Def':
    process_function(node)

# ✅ Also good - isinstance works too
from osbot_utils.helpers.ast.nodes.Ast_Function_Def import Ast_Function_Def
if isinstance(node, Ast_Function_Def):
    process_function(node)
```

### DO: Use .json() for Serialization

```python
# ✅ Good - clean, JSON-serializable output
import json
data = module.json()
json.dumps(data)  # Works perfectly
```

### DON'T: Access .node Attributes Directly (Usually)

```python
# ❌ Avoid when possible - bypasses wrappers
raw_name = node.node.name

# ✅ Better - use provided methods
name = node.name()
```

### DON'T: Forget to Call .visit()

```python
# ❌ Wrong - nothing captured
visitor = Ast_Visit(source)
visitor.capture_functions()
nodes = visitor.captured_nodes()  # Empty!

# ✅ Correct - visit() executes the traversal
visitor = Ast_Visit(source)
visitor.capture_functions()
visitor.visit()  # Must call this!
nodes = visitor.captured_nodes()
```

### DON'T: Modify AST Without Understanding Implications

```python
# ❌ Risky - direct modification can break things
node.node.body.append(new_node)

# ✅ Better - use Ast_Merge for combining code
merger = Ast_Merge()
merger.merge_module(original)
merger.merge_module(additions)
```

### DON'T: Expect Comments in Source Code Round-Trip

```python
# ❌ Comments are NOT preserved
source = "x = 1  # this is lost"
module = Ast_Module(source)
print(module.source_code())  # "x = 1" - comment gone

# This is a fundamental limitation of Python's AST
# Use LibCST or parso if you need comment preservation
```

---

## Troubleshooting

### Problem: SyntaxError When Parsing

**Cause**: Invalid Python syntax in source

```python
# Check your source is valid Python
from osbot_utils.helpers.ast import Ast_Module

try:
    module = Ast_Module("import ...")  # Invalid syntax
except Exception as e:
    print(e)
    # [SyntaxError] 
    # Error parsing code: invalid syntax in <unknown> at line 1 column 8
```

**Solution**: Validate source first or catch the exception

### Problem: Node Method Returns None

**Cause**: Accessing optional field that isn't present

```python
# Some fields are optional
assign = module.body()[0]
if hasattr(assign.node, 'type_comment'):
    tc = assign.node.type_comment  # May be None
```

**Solution**: Check for None or use hasattr

### Problem: Type Registry Returns Ast_Node Instead of Specific Type

**Cause**: Unregistered node type (rare, but possible with very new Python versions)

```python
# Check if you're getting the generic wrapper
node = some_method()
if type(node).__name__ == 'Ast_Node':
    # This is the fallback type
    print(f"Unregistered: {node.node.__class__}")
```

**Solution**: Most node types are registered. If you find a missing one, wrap it manually or contribute to the project.

### Problem: execute_code() Returns Error

**Cause**: Code has runtime errors or needs imports/context

```python
result = Ast_Module("print(undefined_var)").execute_code()
print(result['status'])  # 'error'
print(result['error'])   # "name 'undefined_var' is not defined"
```

**Solution**: Provide required context via exec_locals or exec_namespace

```python
result = Ast_Module("x + 1").execute_code(exec_locals={'x': 41})
print(result['locals'])  # No error
```

### Problem: Ast_Visit Doesn't Find Expected Nodes

**Cause 1**: Wrong capture type name

```python
# ❌ Wrong - must use Ast_* wrapper name
visitor.capture('FunctionDef', callback)

# ✅ Correct
visitor.capture('Ast_Function_Def', callback)
```

**Cause 2**: Forgot to call visit()

```python
# ❌ Missing visit()
visitor.capture_functions()
nodes = visitor.captured_nodes()  # Empty

# ✅ Must visit
visitor.capture_functions()
visitor.visit()
nodes = visitor.captured_nodes()  # Has data
```

### Problem: source_code() Output Differs from Original

**Cause**: AST normalizes formatting and loses comments

```python
original = '''
x = 1 + \
    2  # multiline
'''
module = Ast_Module(original)
print(module.source_code())  # "x = 1 + 2" - normalized
```

**Solution**: This is expected behavior. For formatting-preserving transforms, use LibCST.

---

## Type Registry System

The AST helpers use a `Type_Registry` to automatically resolve native `ast.*` types to wrapper classes:

```python
from osbot_utils.helpers.Type_Registry import type_registry

# How it works internally:
import ast
type_registry.resolve(ast.FunctionDef)  # Returns Ast_Function_Def class

# All mappings are registered in osbot_utils/helpers/ast/__init__.py
ast_types = {
    ast.FunctionDef: Ast_Function_Def,
    ast.ClassDef: Ast_Class_Def,
    ast.Call: Ast_Call,
    # ... 60+ mappings
}
```

This enables seamless conversion when navigating the AST:

```python
# When you call body(), targets(), etc., the return values are
# automatically wrapped in the appropriate Ast_* class
func = module.body()[0]  # Returns Ast_Function_Def, not ast.FunctionDef
```

---

## Summary Checklist

When working with OSBot-Utils AST helpers:

- [ ] Import from `osbot_utils.helpers.ast`
- [ ] Use `Ast_Module(target)` as the entry point for parsing
- [ ] `Ast_Module` accepts: source strings, file paths, Python objects
- [ ] Use `.body()`, `.args()`, etc. to navigate - returns typed wrappers
- [ ] Use `.info()` for structured dict, `.json()` for serialization
- [ ] Use `.source_code()` to regenerate Python code
- [ ] Use `.execute_code()` for dynamic execution
- [ ] Use `Ast_Visit` with `.capture_*()` methods for collecting nodes
- [ ] Always call `.visit()` on `Ast_Visit` to execute the traversal
- [ ] Use `Ast_Load` for multi-file analysis with statistics
- [ ] Use `Ast_Merge` to combine multiple modules
- [ ] Check node types via `type(node).__name__`
- [ ] Remember: comments are NOT preserved (fundamental AST limitation)
- [ ] For stats, use `.stats()` on `Ast_Module` or `Ast_Load`
- [ ] Use `.all_ast_nodes()` to walk the entire tree
- [ ] Access underlying native node via `.node` property when needed
