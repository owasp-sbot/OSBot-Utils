# Semantic Graphs - LLM Usage Brief

**Version**: v3.70.x  
**Purpose**: Guide for LLMs and developers on building and working with semantic graphs (knowledge graphs)  
**Location**: `osbot_utils.helpers.semantic_graphs`  
**Repo**: https://github.com/owasp-sbot/OSBot-Utils  
**Install**: `pip install osbot-utils`

---

## What are Semantic Graphs?

**Semantic Graphs is a comprehensive, type-safe framework for building, validating, and projecting knowledge graphs in Python.** It provides a rigorous schema layer for defining graph structures (nodes, edges, properties), ontologies that constrain what's valid, taxonomies for categorizing concepts, and business logic utilities that operate on this data.

Instead of building ad-hoc graph structures with dictionaries, writing custom validation code, and manually tracking relationships, you get a complete system with runtime type safety, automatic validation against ontology rules, and human-readable projections for debugging and export.

### The Problem It Solves

When building knowledge graphs or semantic models, you typically need to:
- Define what kinds of nodes and relationships are valid
- Enforce type constraints on graph structure
- Validate that edges follow domain rules (e.g., "methods can call functions, but not packages")
- Add properties to nodes and edges with type validation
- Generate human-readable outputs for debugging
- Maintain referential integrity between IDs

Without a framework, this leads to fragile, error-prone code:

```python
# Without Semantic Graphs - ad-hoc and dangerous
graph = {
    'nodes': [
        {'id': 'n1', 'type': 'class', 'name': 'MyClass'},
        {'id': 'n2', 'type': 'methd', 'name': 'foo'},  # Typo: 'methd'
    ],
    'edges': [
        {'from': 'n1', 'to': 'n2', 'rel': 'contains'},
        {'from': 'n1', 'to': 'n99', 'rel': 'calls'},   # n99 doesn't exist!
    ]
}

# No validation, no type safety, no constraints
# Errors discovered deep in processing, not at creation time
```

**With Semantic Graphs:**

```python
from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Builder   import Semantic_Graph__Builder
from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Validator import Semantic_Graph__Validator
from osbot_utils.helpers.semantic_graphs.ontology.Ontology__Registry     import Ontology__Registry

# Build graph with type-safe builder
builder = Semantic_Graph__Builder()
builder.with_ontology_id(my_ontology.ontology_id)
builder.add_node_with_seed(node_type_id = nt_class_id                    ,
                           name         = Safe_Str__Id      ('MyClass')  ,
                           seed         = Safe_Str__Id__Seed('my-class' ))
builder.add_node_with_seed(node_type_id = nt_method_id                   ,
                           name         = Safe_Str__Id      ('foo')      ,
                           seed         = Safe_Str__Id__Seed('my-method'))

graph = builder.build()

# Validate against ontology rules
validator = Semantic_Graph__Validator()
result    = validator.validate(graph, ontology)
if result.valid is False:
    print(result.errors)  # Clear error messages
```

### Design Philosophy

1. **Schemas are pure data** — Schema classes contain only type annotations, never methods
2. **Business logic is separate** — Utils, Validators, and Builders contain all operations
3. **IDs vs Refs** — Internal identifiers (IDs) for integrity, human-readable labels (Refs) for display
4. **Deterministic reproducibility** — Generate consistent IDs from seeds for testing and versioning
5. **Ontology-driven validation** — Edge rules define what's valid; validators enforce it
6. **Type-safe throughout** — Runtime type checking on every operation via Type_Safe
7. **Projections for humans** — Transform internal schemas to human-readable formats

### Key Capabilities

- **Schema-based graph modeling** — Type-safe nodes, edges, and properties
- **Ontology definitions** — Define valid node types, predicates, and edge rules
- **Taxonomy hierarchies** — Categorize node types into hierarchical structures
- **Rule sets** — Enforce cardinality, transitivity, and required property rules
- **Fluent builder API** — Construct graphs with method chaining
- **Deterministic IDs** — Generate reproducible identifiers from seeds
- **Validation engine** — Validate graphs against ontology constraints
- **Human-readable projections** — Transform IDs to refs for export and debugging
- **Property support** — Attach typed key-value properties to nodes and edges

---

## How It Works: System Architecture

### High-Level Component Overview

The Semantic Graphs framework consists of five major subsystems that work together:

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           SEMANTIC GRAPHS FRAMEWORK                             │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐              │
│  │    TAXONOMY     │    │    ONTOLOGY     │    │    RULE SET     │              │
│  │   (Categories)  │◄───│  (Vocabulary)   │───►│  (Constraints)  │              │
│  │                 │    │                 │    │                 │              │
│  │ • Category tree │    │ • Node types    │    │ • Cardinality   │              │
│  │ • Hierarchies   │    │ • Predicates    │    │ • Transitivity  │              │
│  │ • Inheritance   │    │ • Edge rules    │    │ • Required props│              │
│  └────────┬────────┘    │ • Properties    │    └────────┬────────┘              │
│           │             └────────┬────────┘             │                       │
│           │                      │                      │                       │
│           ▼                      ▼                      ▼                       │
│  ┌────────────────────────────────────────────────────────────────────┐         │
│  │                      SEMANTIC GRAPH                                │         │
│  │                      (Instance Data)                               │         │
│  │                                                                    │         │
│  │   ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐         │         │
│  │   │  Node   │───►│  Edge   │───►│  Node   │    │Properties│        │         │
│  │   │ (class) │    │(contains│    │(method) │    │(metadata)│        │         │
│  │   └─────────┘    └─────────┘    └─────────┘    └─────────┘         │         │
│  └────────────────────────────────────────────────────────────────────┘         │
│                                      │                                          │
│                                      ▼                                          │
│  ┌────────────────────────────────────────────────────────────────────┐         │
│  │                        PROJECTION                                  │         │
│  │                   (Human-Readable View)                            │         │
│  │                                                                    │         │
│  │   IDs ──────► Refs    │    Internal ──────► Export-Ready           │         │
│  │   abc123 ──► "class"  │    Schema__ ──────► Projected__            │         │
│  └────────────────────────────────────────────────────────────────────┘         │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### The Four Pillars

```
┌───────────────────────────────────────────────────────────────────────────────┐
│                         THE FOUR PILLARS                                      │
├───────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│   TAXONOMY              ONTOLOGY              GRAPH                PROJECTION │
│   ════════              ════════              ═════                ══════════ │
│                                                                               │
│   Categories            Vocabulary            Instance Data        Human View │
│   ──────────            ──────────            ─────────────        ────────── │
│   "What kinds          "What terms           "The actual          "Readable   │
│    of things            exist in our          nodes, edges,        format for │
│    exist?"              domain?"              and data"            export"    │
│                                                                               │
│   ┌───────────┐        ┌─────────┐          ┌─────────┐          ┌─────────┐  │
│   │code_elem  │        │ class   │          │ MyClass │          │ "class" │  │
│   │    │      │        │ method  │          │   │     │          │"MyClass"│  │
│   │ ┌──┴──┐   │        │ func    │          │   ▼     │          │    │    │  │
│   │ │     │   │        │contains │          │  foo    │          │    ▼    │  │
│   │call  cont │        │ calls   │          │  bar    │          │"method" │  │
│   │able  ainer│        │ uses    │          └─────────┘          │ "foo"   │  │
│   └───────────┘        └─────────┘                               └─────────┘  │
│                                                                               │
│   Taxonomy__           Ontology__            Semantic_Graph__     Projector   │
│   Registry             Registry              Builder/Utils        project()   │
│                                                                               │
└───────────────────────────────────────────────────────────────────────────────┘
```

### Data Flow: From Definition to Projection

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           DATA FLOW OVERVIEW                                    │
└─────────────────────────────────────────────────────────────────────────────────┘

     DEFINITION PHASE                    BUILD PHASE                 OUTPUT PHASE
     ════════════════                    ═══════════                 ════════════

  ┌──────────────────┐              ┌──────────────────┐         ┌──────────────────┐
  │  1. TAXONOMY     │              │  4. GRAPH        │         │  6. VALIDATION   │
  │                  │              │     BUILDER      │         │                  │
  │  Define category │              │                  │         │  Check graph     │
  │  hierarchies     │              │  Construct nodes │         │  against ontology│
  │                  │              │  and edges       │         │  edge rules      │
  └────────┬─────────┘              └────────┬─────────┘         └────────┬─────────┘
           │                                 │                            │
           ▼                                 ▼                            ▼
  ┌──────────────────┐              ┌──────────────────┐         ┌──────────────────┐
  │  2. ONTOLOGY     │              │  5. SCHEMA       │         │  7. PROJECTION   │
  │                  │─────────────►│     GRAPH        │────────►│                  │
  │  Define node     │  references  │                  │         │  Transform IDs   │
  │  types, preds,   │              │  Type-safe       │         │  to human-       │
  │  edge rules      │              │  instance data   │         │  readable refs   │
  └────────┬─────────┘              └──────────────────┘         └────────┬─────────┘
           │                                                              │
           ▼                                                              ▼
  ┌──────────────────┐                                           ┌──────────────────┐
  │  3. RULE SET     │                                           │  8. EXPORT       │
  │                  │                                           │                  │
  │  Define property │                                           │  JSON, Vis.js,   │
  │  requirements,   │                                           │  Cytoscape,      │
  │  cardinality     │                                           │  Mermaid, etc.   │
  └──────────────────┘                                           └──────────────────┘
```

### The ID/Ref Duality System

A core concept in Semantic Graphs is the separation between internal IDs and human-readable Refs:

```
┌────────────────────────────────────────────────────────────────────────────────────┐
│                            ID vs REF DUALITY                                       │
├────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                    │
│                    ID (Internal)                    REF (Human)                    │
│                    ═════════════                    ═══════════                    │
│                                                                                    │
│   Node_Type_Id     "a7b3c9d2e1f4..."               Node_Type_Ref    "class"        │
│   Predicate_Id     "x8y2z6w4v5u3..."               Predicate_Ref    "contains"     │
│   Category_Id      "m1n2o3p4q5r6..."               Category_Ref     "callable"     │
│   Ontology_Id      "i9j8k7l6m5n4..."               Ontology_Ref     "code_analysis"│
│                                                                                    │
│   ┌─────────────────────────────────────────────────────────────────────────────┐  │
│   │                                                                             │  │
│   │   SCHEMA__ (Internal Storage)          PROJECTED__ (Human Output)           │  │
│   │   ─────────────────────────           ───────────────────────────           │  │
│   │                                                                             │  │
│   │   node_type_id: "a7b3c9d2..."    ───►    ref: "class"                       │  │
│   │   predicate_id: "x8y2z6w4..."    ───►    ref: "contains"                    │  │
│   │   from_node_id: "node123..."     ───►    from_name: "MyClass"               │  │
│   │   to_node_id:   "node456..."     ───►    to_name: "process"                 │  │
│   │                                                                             │  │
│   └─────────────────────────────────────────────────────────────────────────────┘  │
│                                                                                    │
│   WHY TWO SYSTEMS?                                                                 │
│   ────────────────                                                                 │
│                                                                                    │
│   • IDs: Guaranteed unique, enable foreign keys, support versioning                │
│   • Refs: Human-readable, used in config files, shown in exports                   │
│   • Deterministic IDs: Same seed → same ID (reproducible builds)                   │
│   • Projector: Transforms ID-based schemas to ref-based output                     │
│                                                                                    │
└────────────────────────────────────────────────────────────────────────────────────┘
```

### Schema vs Logic Separation

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                       SCHEMA vs LOGIC SEPARATION                                │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│   ┌─────────────────────────────┐    ┌─────────────────────────────┐            │
│   │      SCHEMA CLASSES         │    │      LOGIC CLASSES          │            │
│   │      (Pure Data)            │    │      (Operations)           │            │
│   ├─────────────────────────────┤    ├─────────────────────────────┤            │
│   │                             │    │                             │            │
│   │ Schema__Semantic_Graph      │    │ Semantic_Graph__Builder     │            │
│   │   • graph_id                │    │   • add_node()              │            │
│   │   • ontology_id             │    │   • add_edge()              │            │
│   │   • nodes                   │    │   • build()                 │            │
│   │   • edges                   │    │                             │            │
│   │                             │    │ Semantic_Graph__Utils       │            │
│   │ Schema__Ontology            │    │   • get_node()              │            │
│   │   • node_types              │    │   • neighbors()             │            │
│   │   • predicates              │    │   • has_edge()              │            │
│   │   • edge_rules              │    │                             │            │
│   │                             │    │ Semantic_Graph__Validator   │            │
│   │ Schema__Taxonomy            │    │   • validate()              │            │
│   │   • categories              │    │   • validate_edges()        │            │
│   │   • root_id                 │    │                             │            │
│   │                             │    │ Ontology__Utils             │            │
│   │                             │    │   • create_node_type()      │            │
│   │   ❌ NO METHODS!            │    │   • is_valid_edge()         │            │
│   │                             │    │                             │            │
│   └─────────────────────────────┘    └─────────────────────────────┘            │
│                                                                                 │
│   WHY SEPARATE?                                                                 │
│   ─────────────                                                                 │
│                                                                                 │
│   • Schemas serialize cleanly to JSON (no method baggage)                       │
│   • Single Responsibility: schemas describe, logic operates                     │
│   • Easy to swap logic implementations without changing data                    │
│   • Testable: logic classes can be unit tested independently                    │
│   • Type_Safe enforces this at runtime                                          │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### Complete Workflow: Building a Code Analysis Graph

```
┌────────────────────────────────────────────────────────────────────────────────────┐
│              COMPLETE WORKFLOW: CODE ANALYSIS GRAPH                                │
├────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                    │
│   STEP 1: Define Taxonomy (Category Hierarchy)                                     │
│   ═══════════════════════════════════════════                                      │
│                                                                                    │
│                        code_element (root)                                         │
│                              │                                                     │
│              ┌───────────────┼───────────────┐                                     │
│              ▼               ▼               ▼                                     │
│          callable       container          data                                    │
│           │   │            │   │            │                                      │
│           ▼   ▼            ▼   ▼            ▼                                      │
│       method function   class module    variable                                   │
│                                                                                    │
│   STEP 2: Define Ontology (Vocabulary + Rules)                                     │
│   ════════════════════════════════════════════                                     │
│                                                                                    │
│   Node Types:    class, method, function, module, variable                         │
│   Predicates:    contains/contained_by, calls/called_by, uses/used_by              │
│   Properties:    line_number (int), is_async (bool), docstring (str)               │
│                                                                                    │
│   Edge Rules:                                                                      │
│   ┌────────────┬────────────┬────────────┐                                         │
│   │  Source    │  Predicate │  Target    │                                         │
│   ├────────────┼────────────┼────────────┤                                         │
│   │  module    │  contains  │  class     │                                         │
│   │  module    │  contains  │  function  │                                         │
│   │  class     │  contains  │  method    │                                         │
│   │  method    │  calls     │  function  │                                         │
│   │  method    │  calls     │  method    │                                         │
│   │  function  │  uses      │  variable  │                                         │
│   └────────────┴────────────┴────────────┘                                         │
│                                                                                    │
│   STEP 3: Build Graph Instance                                                     │
│   ════════════════════════════                                                     │
│                                                                                    │
│   builder = Semantic_Graph__Builder()                                              │
│   builder.with_ontology_id(ontology.ontology_id)                                   │
│                                                                                    │
│   # Add nodes with properties                                                      │
│   builder.add_node_with_seed(nt_module, "main",    seed_1, props={line: 1})        │
│   builder.add_node_with_seed(nt_class,  "Parser",  seed_2, props={line: 10})       │
│   builder.add_node_with_seed(nt_method, "parse",   seed_3, props={line: 15})       │
│   builder.add_node_with_seed(nt_func,   "helper",  seed_4, props={line: 50})       │
│                                                                                    │
│   # Add edges                                                                      │
│   builder.add_edge(main_id,   contains_id, parser_id)                              │
│   builder.add_edge(parser_id, contains_id, parse_id)                               │
│   builder.add_edge(parse_id,  calls_id,    helper_id)                              │
│                                                                                    │
│   graph = builder.build()                                                          │
│                                                                                    │
│   RESULT:                                                                          │
│   ┌─────────────────────────────────────────────────────────────┐                  │
│   │                                                             │                  │
│   │    ┌──────────┐                                             │                  │
│   │    │  main    │ (module)                                    │                  │
│   │    │  line: 1 │                                             │                  │
│   │    └────┬─────┘                                             │                  │
│   │         │ contains                                          │                  │
│   │         ▼                                                   │                  │
│   │    ┌──────────┐         ┌──────────┐                        │                  │
│   │    │  Parser  │ ──────► │  helper  │                        │                  │
│   │    │ (class)  │ contains│(function)│                        │                  │
│   │    │ line: 10 │         │ line: 50 │                        │                  │
│   │    └────┬─────┘         └────▲─────┘                        │                  │
│   │         │ contains              │ calls                     │                  │
│   │         ▼                       │                           │                  │
│   │    ┌──────────┐                 │                           │                  │
│   │    │  parse   │─────────────────┘                           │                  │
│   │    │ (method) │                                             │                  │
│   │    │ line: 15 │                                             │                  │
│   │    └──────────┘                                             │                  │
│   │                                                             │                  │
│   └─────────────────────────────────────────────────────────────┘                  │
│                                                                                    │
│   STEP 4: Validate                                                                 │
│   ════════════════                                                                 │
│                                                                                    │
│   validator = Semantic_Graph__Validator()                                          │
│   result = validator.validate(graph, ontology)                                     │
│                                                                                    │
│   ✓ All node types exist in ontology                                               │
│   ✓ All predicates exist in ontology                                               │
│   ✓ All edges match edge rules                                                     │
│   ✓ result.valid == True                                                           │
│                                                                                    │
│   STEP 5: Project for Export                                                       │
│   ══════════════════════════                                                       │
│                                                                                    │
│   projector = Semantic_Graph__Projector(ontology_registry, taxonomy_registry)      │
│   projection = projector.project(graph)                                            │
│                                                                                    │
│   OUTPUT (Human-Readable):                                                         │
│   {                                                                                │
│     "projection": {                                                                │
│       "nodes": [                                                                   │
│         {"ref": "module",   "name": "main",   "properties": {"line_number": "1"}}, │
│         {"ref": "class",    "name": "Parser", "properties": {"line_number": "10"}},│
│         {"ref": "method",   "name": "parse",  "properties": {"line_number": "15"}},│
│         {"ref": "function", "name": "helper", "properties": {"line_number": "50"}} │
│       ],                                                                           │
│       "edges": [                                                                   │
│         {"from_name": "main",   "ref": "contains", "to_name": "Parser"},           │
│         {"from_name": "Parser", "ref": "contains", "to_name": "parse"},            │
│         {"from_name": "parse",  "ref": "calls",    "to_name": "helper"}            │
│       ]                                                                            │
│     },                                                                             │
│     "taxonomy": {                                                                  │
│       "node_type_categories": {"class": "container", "method": "callable", ...},   │
│       "category_parents": {"callable": "code_element", "container": "code_element"}│
│     }                                                                              │
│   }                                                                                │
│                                                                                    │
└────────────────────────────────────────────────────────────────────────────────────┘
```

### Validation Flow Detail

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                          VALIDATION FLOW                                        │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│                    ┌───────────────────────┐                                    │
│                    │   Semantic_Graph__    │                                    │
│                    │     Validator         │                                    │
│                    └───────────┬───────────┘                                    │
│                                │                                                │
│              ┌─────────────────┼─────────────────┐                              │
│              ▼                 ▼                 ▼                              │
│   ┌───────────────────┐ ┌───────────────────┐ ┌───────────────────┐             │
│   │  validate_nodes() │ │  validate_edges() │ │  validate_edges   │             │
│   │                   │ │                   │ │  _against_rules() │             │
│   └─────────┬─────────┘ └─────────┬─────────┘ └─────────┬─────────┘             │
│             │                     │                     │                       │
│             ▼                     ▼                     ▼                       │
│   ┌───────────────────┐ ┌───────────────────┐ ┌───────────────────┐             │
│   │ For each node:    │ │ For each edge:    │ │ For each edge:    │             │
│   │                   │ │                   │ │                   │             │
│   │ • node_type_id    │ │ • from_node_id    │ │ • Get source type │             │
│   │   exists in       │ │   exists?         │ │ • Get target type │             │
│   │   ontology?       │ │ • to_node_id      │ │ • Check edge_rules│             │
│   │                   │ │   exists?         │ │   for match       │             │
│   │ Error if not:     │ │ • predicate_id    │ │                   │             │
│   │ "Unknown          │ │   exists in       │ │ Error if not:     │             │
│   │  node_type_id"    │ │   ontology?       │ │ "Invalid edge:    │             │
│   │                   │ │                   │ │  class --[calls]  │             │
│   │                   │ │ Error if not:     │ │  --> package"     │             │
│   │                   │ │ "Unknown          │ │                   │             │
│   │                   │ │  predicate_id"    │ │                   │             │
│   └───────────────────┘ └───────────────────┘ └───────────────────┘             │
│                                                                                 │
│                                    │                                            │
│                                    ▼                                            │
│                    ┌───────────────────────────────┐                            │
│                    │   Schema__Validation_Result   │                            │
│                    │                               │                            │
│                    │   valid: bool                 │                            │
│                    │   errors: List[str]           │                            │
│                    └───────────────────────────────┘                            │
│                                                                                 │
│   EDGE RULE MATCHING:                                                           │
│   ──────────────────                                                            │
│                                                                                 │
│   Edge: method --[calls]--> function                                            │
│                                                                                 │
│   Check: Does any rule in ontology.edge_rules match?                            │
│                                                                                 │
│   Rule 1: class  --[contains]--> method    ❌ No match                          │
│   Rule 2: method --[calls]   --> method    ❌ No match (target differs)         │
│   Rule 3: method --[calls]   --> function  ✓ MATCH!                             │
│                                                                                 │
│   Result: Edge is valid                                                         │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### Projection Transformation Flow

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                       PROJECTION TRANSFORMATION                                 │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│   INPUT: Schema__Semantic_Graph (ID-based)                                      │
│   ════════════════════════════════════════                                      │
│                                                                                 │
│   graph.nodes = {                                                               │
│     Node_Id("abc123"): Schema__Semantic_Graph__Node(                            │
│       node_id      = Node_Id("abc123"),                                         │
│       node_type_id = Node_Type_Id("xyz789"),     ◄── ID, not human-readable     │
│       name         = "MyClass",                                                 │
│       properties   = {Property_Name_Id("prop1"): "42"}                          │
│     )                                                                           │
│   }                                                                             │
│                                                                                 │
│   graph.edges = [                                                               │
│     Schema__Semantic_Graph__Edge(                                               │
│       from_node_id = Node_Id("abc123"),          ◄── ID                         │
│       predicate_id = Predicate_Id("def456"),     ◄── ID                         │
│       to_node_id   = Node_Id("ghi789")           ◄── ID                         │
│     )                                                                           │
│   ]                                                                             │
│                                                                                 │
│                              │                                                  │
│                              │  Semantic_Graph__Projector.project()             │
│                              │                                                  │
│                              │  1. Build ID → Ref lookup maps from ontology     │
│                              │  2. Build Node_Id → name lookup from graph       │
│                              │  3. Transform each node (type_id → type_ref)     │
│                              │  4. Transform each edge (node_ids → names)       │
│                              │  5. Build filtered references (only used refs)   │
│                              │  6. Build taxonomy section                       │
│                              ▼                                                  │
│                                                                                 │
│   OUTPUT: Schema__Projected__Semantic_Graph (Ref-based)                         │
│   ═════════════════════════════════════════════════════                         │
│                                                                                 │
│   projection.projection.nodes = [                                               │
│     Schema__Projected__Node(                                                    │
│       ref        = Node_Type_Ref("class"),       ◄── Human-readable!            │
│       name       = "MyClass",                                                   │
│       properties = {Property_Name_Ref("line_number"): "42"}                     │
│     )                                                                           │
│   ]                                                                             │
│                                                                                 │
│   projection.projection.edges = [                                               │
│     Schema__Projected__Edge(                                                    │
│       from_name = "MyClass",                     ◄── Name, not ID!              │
│       ref       = Predicate_Ref("contains"),     ◄── Human-readable!            │
│       to_name   = "process"                      ◄── Name, not ID!              │
│     )                                                                           │
│   ]                                                                             │
│                                                                                 │
│   projection.references = {                      ◄── Correlation table          │
│     node_types: {"class": "xyz789", "method": "uvw123"},                        │
│     predicates: {"contains": "def456", "calls": "stu987"}                       │
│   }                                                                             │
│                                                                                 │
│   projection.taxonomy = {                        ◄── Category mapping           │
│     node_type_categories: {"class": "container", "method": "callable"},         │
│     category_parents: {"container": "code_element", "callable": "code_element"} │
│   }                                                                             │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### Registry Pattern

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                          REGISTRY PATTERN                                       │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│   Registries provide dual-indexed storage for domain objects:                   │
│                                                                                 │
│   ┌──────────────────────────────────────────────────────────────────────────┐  │
│   │                     Ontology__Registry                                   │  │
│   │                                                                          │  │
│   │   ontologies_by_id:   Dict[Ontology_Id, Schema__Ontology]                │  │
│   │   ontologies_by_ref:  Dict[Ontology_Ref, Schema__Ontology]               │  │
│   │                                                                          │  │
│   │   ┌─────────────────────────────────────────────────────────────────┐    │  │
│   │   │                        DUAL INDEX                                │   │  │
│   │   │                                                                  │   │  │
│   │   │   by_id["a7b3c9..."] ───┐                                        │   │  │
│   │   │                         ├───► Schema__Ontology(...)              │   │  │
│   │   │   by_ref["code_analysis"] ──┘                                    │   │  │
│   │   │                                                                  │   │  │
│   │   │   get_by_id(Ontology_Id("a7b3c9..."))   → Schema__Ontology       │   │  │
│   │   │   get_by_ref(Ontology_Ref("code_analysis")) → Schema__Ontology   │   │  │
│   │   │                                                                  │   │  │
│   │   └──────────────────────────────────────────────────────────────────┘   │  │
│   │                                                                          │  │
│   │   Factory Methods:                                                       │  │
│   │   ─────────────────                                                      │  │
│   │   create_with__random_id(ref, ...)        → Random Obj_Id                │  │
│   │   create_with__deterministic_id(ref, seed, ...) → Obj_Id.from_seed()     │  │
│   │   create_with__explicit_id(ref, id, ...)  → Use provided ID              │  │
│   │                                                                          │  │
│   └──────────────────────────────────────────────────────────────────────────┘  │
│                                                                                 │
│   Same pattern for: Taxonomy__Registry, Rule__Engine                            │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### Property System Architecture

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                        PROPERTY SYSTEM                                          │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│   Properties allow attaching typed key-value data to nodes and edges.           │
│                                                                                 │
│   ONTOLOGY DEFINES:                                                             │
│   ═════════════════                                                             │
│                                                                                 │
│   Property Types (how values are interpreted):                                  │
│   ┌─────────────────────────────────────────┐                                   │
│   │ property_type_id │ property_type_ref    │                                   │
│   ├─────────────────────────────────────────┤                                   │
│   │ "pt001..."       │ "integer"            │                                   │
│   │ "pt002..."       │ "boolean"            │                                   │
│   │ "pt003..."       │ "string"             │                                   │
│   └─────────────────────────────────────────┘                                   │
│                                                                                 │
│   Property Names (what properties exist):                                       │
│   ┌──────────────────────────────────────────────────────────┐                  │
│   │ property_name_id │ property_name_ref │ property_type_id  │                  │
│   ├──────────────────────────────────────────────────────────┤                  │
│   │ "pn001..."       │ "line_number"     │ "pt001..." (int)  │                  │
│   │ "pn002..."       │ "is_async"        │ "pt002..." (bool) │                  │
│   │ "pn003..."       │ "docstring"       │ "pt003..." (str)  │                  │
│   └──────────────────────────────────────────────────────────┘                  │
│                                                                                 │
│   GRAPH INSTANCE USES:                                                          │
│   ════════════════════                                                          │
│                                                                                 │
│   Node with properties:                                                         │
│   ┌─────────────────────────────────────────────────────────────┐               │
│   │ Schema__Semantic_Graph__Node                                 │              │
│   │                                                              │              │
│   │   node_id:      Node_Id("node123...")                        │              │
│   │   node_type_id: Node_Type_Id("method...")                    │              │
│   │   name:         "process"                                    │              │
│   │   properties:   Dict__Node_Properties {                      │              │
│   │                   Property_Name_Id("pn001"): "42"   ◄── Values are strings  │
│   │                   Property_Name_Id("pn002"): "true"     (type in ontology)  │
│   │                 }                                            │              │
│   └─────────────────────────────────────────────────────────────┘               │
│                                                                                 │
│   PROJECTION TRANSFORMS:                                                        │
│   ══════════════════════                                                        │
│                                                                                 │
│   Property_Name_Id("pn001")  ───►  Property_Name_Ref("line_number")             │
│                                                                                 │
│   Projected node:                                                               │
│   { "ref": "method", "name": "process", "properties": {"line_number": "42"} }   │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

---

## Quick Start

### Creating an Ontology

```python
from osbot_utils.helpers.semantic_graphs.ontology.Ontology__Registry                  import Ontology__Registry
from osbot_utils.helpers.semantic_graphs.ontology.Ontology__Utils                     import Ontology__Utils
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Ontology_Ref              import Ontology_Ref
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Node_Type_Ref             import Node_Type_Ref
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Predicate_Ref             import Predicate_Ref
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Id__Seed import Safe_Str__Id__Seed

# Create registry and utils
registry = Ontology__Registry()
utils    = Ontology__Utils()

# Create node types
nt_class  = utils.create_node_type(node_type_ref = Node_Type_Ref('class') ,
                                   seed          = Safe_Str__Id__Seed('nt-class'))
nt_method = utils.create_node_type(node_type_ref = Node_Type_Ref('method'),
                                   seed          = Safe_Str__Id__Seed('nt-method'))

# Create predicates
pred_contains, pred_contained_by = utils.create_predicate_pair(
    predicate_ref = Predicate_Ref('contains')   ,
    inverse_ref   = Predicate_Ref('contained_by'),
    seed          = Safe_Str__Id__Seed('pred-contains'),
    inverse_seed  = Safe_Str__Id__Seed('pred-contained-by'))

# Create edge rule: class --contains--> method
edge_rule = utils.create_edge_rule(source_type_id = nt_class.node_type_id ,
                                   predicate_id   = pred_contains.predicate_id,
                                   target_type_id = nt_method.node_type_id)

# Register ontology
ontology = registry.create_with__deterministic_id(
    ontology_ref = Ontology_Ref('code_analysis'),
    seed         = Safe_Str__Id__Seed('ontology-code'))
ontology.node_types[nt_class.node_type_id]       = nt_class
ontology.node_types[nt_method.node_type_id]      = nt_method
ontology.predicates[pred_contains.predicate_id]  = pred_contains
ontology.edge_rules.append(edge_rule)
```

### Building a Graph

```python
from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Builder          import Semantic_Graph__Builder
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Id import Safe_Str__Id

# Create builder
builder = Semantic_Graph__Builder()
builder.with_ontology_id(ontology.ontology_id)
builder.with_deterministic_graph_id(Safe_Str__Id__Seed('my-graph'))

# Add nodes
builder.add_node_with_seed(node_type_id = nt_class.node_type_id        ,
                           name         = Safe_Str__Id('MyClass')      ,
                           seed         = Safe_Str__Id__Seed('node-class'))

builder.add_node_with_seed(node_type_id = nt_method.node_type_id       ,
                           name         = Safe_Str__Id('process')      ,
                           seed         = Safe_Str__Id__Seed('node-method'))

# Get node IDs for edges
from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id import Obj_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Node_Id import Node_Id

class_node_id  = Node_Id(Obj_Id.from_seed(Safe_Str__Id__Seed('node-class')))
method_node_id = Node_Id(Obj_Id.from_seed(Safe_Str__Id__Seed('node-method')))

# Add edge
builder.add_edge(from_node_id = class_node_id             ,
                 predicate_id = pred_contains.predicate_id,
                 to_node_id   = method_node_id            )

# Build the graph
graph = builder.build()
```

### Validating a Graph

```python
from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Validator import Semantic_Graph__Validator

validator = Semantic_Graph__Validator()
result    = validator.validate(graph, ontology)

if result.valid:
    print("Graph is valid!")
else:
    for error in result.errors:
        print(f"Validation error: {error}")
```

### Creating a Projection

```python
from osbot_utils.helpers.semantic_graphs.projector.Semantic_Graph__Projector import Semantic_Graph__Projector

projector  = Semantic_Graph__Projector(ontology_registry = registry)
projection = projector.project(graph)

# Human-readable output
for node in projection.projection.nodes:
    print(f"Node: {node.ref} - {node.name}")

for edge in projection.projection.edges:
    print(f"Edge: {edge.from_name} --[{edge.ref}]--> {edge.to_name}")
```

---

## Core Concepts

### ID vs Ref: The Dual Identity System

Every entity in Semantic Graphs has two identifiers:

| Type | Purpose | Example | Usage |
|------|---------|---------|-------|
| **ID** | Unique instance identifier | `Node_Type_Id('abc123...')` | Internal references, foreign keys |
| **Ref** | Human-readable label | `Node_Type_Ref('class')` | Display, configuration, debugging |

```python
# ID: Machine-readable, unique per instance
node_type.node_type_id = Node_Type_Id(Obj_Id())           # Random: 'a1b2c3d4...'
node_type.node_type_id = Node_Type_Id(Obj_Id.from_seed('my-seed'))  # Deterministic

# Ref: Human-readable, defined once
node_type.node_type_ref = Node_Type_Ref('class')          # Display name

# Why both?
# - IDs provide referential integrity (foreign keys)
# - Refs enable human-readable projections
# - Deterministic IDs enable reproducible builds
```

### Schema vs Business Logic Separation

**CRITICAL**: Schemas are pure data containers. All logic lives in Utils/Builders/Validators.

```python
# ✗ WRONG - Logic in schema
class Schema__Ontology(Type_Safe):
    node_types : Dict__Node_Types__By_Id
    
    def is_valid_edge(self, source, pred, target):  # NO! Move to utils
        pass

# ✓ CORRECT - Schema is pure data
class Schema__Ontology(Type_Safe):
    node_types : Dict__Node_Types__By_Id
    predicates : Dict__Predicates__By_Id
    edge_rules : List__Edge_Rules

# ✓ CORRECT - Logic in separate utils class
class Ontology__Utils(Type_Safe):
    
    @type_safe
    def is_valid_edge(self                         ,
                      ontology       : Schema__Ontology,
                      source_type_id : Node_Type_Id    ,
                      predicate_id   : Predicate_Id    ,
                      target_type_id : Node_Type_Id    ) -> bool:
        for rule in ontology.edge_rules:
            if (rule.source_type_id == source_type_id and
                rule.predicate_id   == predicate_id   and
                rule.target_type_id == target_type_id):
                return True
        return False
```

### Deterministic ID Generation

Generate reproducible IDs from seed strings for testing and versioning:

```python
from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id import Obj_Id
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Id__Seed import Safe_Str__Id__Seed

# Random ID - different each time
random_id = Obj_Id()                                      # 'a1b2c3d4...' (random)

# Deterministic ID - same seed = same ID
seed = Safe_Str__Id__Seed('my-stable-seed')
det_id_1 = Obj_Id.from_seed(seed)                         # 'x7y8z9...'
det_id_2 = Obj_Id.from_seed(seed)                         # Same: 'x7y8z9...'

# Use cases:
# - Reproducible test data
# - Version-controlled ontologies
# - Idempotent graph construction
```

### Property System

Nodes and edges can have typed properties:

```python
from osbot_utils.helpers.semantic_graphs.schemas.collection.Dict__Node_Properties import Dict__Node_Properties
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Property_Name_Id import Property_Name_Id
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Text import Safe_Str__Text

# Create property on a node
node_props = Dict__Node_Properties()
node_props[pn_line_number_id] = Safe_Str__Text('42')
node_props[pn_is_async_id]    = Safe_Str__Text('false')

builder.add_node_with_seed(node_type_id = nt_method_id             ,
                           name         = Safe_Str__Id('my_method'),
                           seed         = Safe_Str__Id__Seed('nm') ,
                           properties   = node_props               )

# Query properties
from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Utils import Semantic_Graph__Utils

utils = Semantic_Graph__Utils()
line  = utils.get_node_property(graph, node_id, pn_line_number_id)  # '42'
```

### Edge Rules and Validation

Ontologies define which edges are valid:

```python
# Edge rule: class --contains--> method
rule = Schema__Ontology__Edge_Rule(source_type_id = nt_class_id ,
                                   predicate_id   = pred_contains_id,
                                   target_type_id = nt_method_id)
ontology.edge_rules.append(rule)

# Validator checks all edges against rules
validator = Semantic_Graph__Validator()
result    = validator.validate(graph, ontology)

# Error example: "Invalid edge: class --[calls]--> package"
```

### Projections: Schema to Human-Readable

Projections transform internal IDs to human-readable refs:

```python
# Schema__ (internal)
{
    "nodes": {"abc123...": {"node_type_id": "xyz789...", "name": "MyClass"}},
    "edges": [{"from_node_id": "abc123...", "predicate_id": "def456...", ...}]
}

# Projected__ (human-readable)
{
    "projection": {
        "nodes": [{"ref": "class", "name": "MyClass"}],
        "edges": [{"from_name": "MyClass", "ref": "contains", "to_name": "process"}]
    },
    "references": {
        "node_types": {"class": "xyz789..."},
        "predicates": {"contains": "def456..."}
    }
}
```

---

## Architecture Overview

### Layer Structure

```
┌─────────────────────────────────────────────────────────────────┐
│                         Testing Layer                            │
│  QA__Semantic_Graphs__Test_Data                                  │
├─────────────────────────────────────────────────────────────────┤
│                       Business Logic Layer                       │
│  Semantic_Graph__Builder    │  Ontology__Utils                  │
│  Semantic_Graph__Utils      │  Ontology__Registry               │
│  Semantic_Graph__Validator  │  Taxonomy__Utils                  │
│  Semantic_Graph__Projector  │  Taxonomy__Registry               │
│                             │  Rule__Engine / Rule_Set__Utils   │
├─────────────────────────────────────────────────────────────────┤
│                         Schema Layer                             │
│  Schema__Semantic_Graph     │  Schema__Ontology                 │
│  Schema__Semantic_Graph__Node│ Schema__Ontology__Node_Type      │
│  Schema__Semantic_Graph__Edge│ Schema__Ontology__Predicate      │
│  Schema__Validation_Result  │  Schema__Ontology__Edge_Rule      │
│                             │  Schema__Taxonomy                 │
│                             │  Schema__Rule_Set                 │
├─────────────────────────────────────────────────────────────────┤
│                       Identifier Layer                           │
│  Node_Id, Edge_Id, Graph_Id │  Node_Type_Id, Node_Type_Ref      │
│  Ontology_Id, Ontology_Ref  │  Predicate_Id, Predicate_Ref      │
│  Taxonomy_Id, Taxonomy_Ref  │  Property_Name_Id, Property_Name_Ref│
│  Category_Id, Category_Ref  │  Property_Type_Id, Property_Type_Ref│
├─────────────────────────────────────────────────────────────────┤
│                       Collection Layer                           │
│  Dict__Nodes__By_Id         │  List__Semantic_Graph__Edges      │
│  Dict__Node_Types__By_Id    │  List__Edge_Rules                 │
│  Dict__Predicates__By_Id    │  List__Validation_Errors          │
│  Dict__Categories__By_Id    │  Dict__Node_Properties            │
└─────────────────────────────────────────────────────────────────┘
```

### Key Classes by Purpose

| Purpose | Class | Description |
|---------|-------|-------------|
| **Graph Building** | `Semantic_Graph__Builder` | Fluent API for constructing graphs |
| **Graph Queries** | `Semantic_Graph__Utils` | Query nodes, edges, neighbors, properties |
| **Graph Validation** | `Semantic_Graph__Validator` | Validate against ontology rules |
| **Graph Projection** | `Semantic_Graph__Projector` | Transform Schema__ to Projected__ |
| **Ontology Management** | `Ontology__Registry` | Register and lookup ontologies |
| **Ontology Operations** | `Ontology__Utils` | Create node types, predicates, rules |
| **Taxonomy Management** | `Taxonomy__Registry` | Register and lookup taxonomies |
| **Taxonomy Operations** | `Taxonomy__Utils` | Navigate category hierarchies |
| **Rule Management** | `Rule__Engine` | Register and lookup rule sets |
| **Rule Validation** | `Rule_Set__Utils` | Validate property requirements |
| **Test Data** | `QA__Semantic_Graphs__Test_Data` | Factory for test fixtures |

---

## Import Reference

### Core Graph Classes

```python
from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Builder   import Semantic_Graph__Builder
from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Utils     import Semantic_Graph__Utils
from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Validator import Semantic_Graph__Validator
```

### Ontology Classes

```python
from osbot_utils.helpers.semantic_graphs.ontology.Ontology__Registry     import Ontology__Registry
from osbot_utils.helpers.semantic_graphs.ontology.Ontology__Utils        import Ontology__Utils
```

### Taxonomy Classes

```python
from osbot_utils.helpers.semantic_graphs.taxonomy.Taxonomy__Registry     import Taxonomy__Registry
from osbot_utils.helpers.semantic_graphs.taxonomy.Taxonomy__Utils        import Taxonomy__Utils
```

### Rule Classes

```python
from osbot_utils.helpers.semantic_graphs.rule.Rule__Engine               import Rule__Engine
from osbot_utils.helpers.semantic_graphs.rule.Rule_Set__Utils            import Rule_Set__Utils
```

### Projector

```python
from osbot_utils.helpers.semantic_graphs.projector.Semantic_Graph__Projector import Semantic_Graph__Projector
```

### Graph Schemas

```python
from osbot_utils.helpers.semantic_graphs.schemas.graph.Schema__Semantic_Graph       import Schema__Semantic_Graph
from osbot_utils.helpers.semantic_graphs.schemas.graph.Schema__Semantic_Graph__Node import Schema__Semantic_Graph__Node
from osbot_utils.helpers.semantic_graphs.schemas.graph.Schema__Semantic_Graph__Edge import Schema__Semantic_Graph__Edge
from osbot_utils.helpers.semantic_graphs.schemas.graph.Schema__Validation_Result    import Schema__Validation_Result
```

### Ontology Schemas

```python
from osbot_utils.helpers.semantic_graphs.schemas.ontology.Schema__Ontology              import Schema__Ontology
from osbot_utils.helpers.semantic_graphs.schemas.ontology.Schema__Ontology__Node_Type   import Schema__Ontology__Node_Type
from osbot_utils.helpers.semantic_graphs.schemas.ontology.Schema__Ontology__Predicate   import Schema__Ontology__Predicate
from osbot_utils.helpers.semantic_graphs.schemas.ontology.Schema__Ontology__Edge_Rule   import Schema__Ontology__Edge_Rule
from osbot_utils.helpers.semantic_graphs.schemas.ontology.Schema__Ontology__Property_Name import Schema__Ontology__Property_Name
from osbot_utils.helpers.semantic_graphs.schemas.ontology.Schema__Ontology__Property_Type import Schema__Ontology__Property_Type
```

### Taxonomy Schemas

```python
from osbot_utils.helpers.semantic_graphs.schemas.taxonomy.Schema__Taxonomy             import Schema__Taxonomy
from osbot_utils.helpers.semantic_graphs.schemas.taxonomy.Schema__Taxonomy__Category   import Schema__Taxonomy__Category
```

### Rule Schemas

```python
from osbot_utils.helpers.semantic_graphs.schemas.rule.Schema__Rule_Set                     import Schema__Rule_Set
from osbot_utils.helpers.semantic_graphs.schemas.rule.Schema__Rule__Cardinality            import Schema__Rule__Cardinality
from osbot_utils.helpers.semantic_graphs.schemas.rule.Schema__Rule__Transitivity           import Schema__Rule__Transitivity
from osbot_utils.helpers.semantic_graphs.schemas.rule.Schema__Rule__Required_Node_Property import Schema__Rule__Required_Node_Property
from osbot_utils.helpers.semantic_graphs.schemas.rule.Schema__Rule__Required_Edge_Property import Schema__Rule__Required_Edge_Property
```

### Projected Schemas

```python
from osbot_utils.helpers.semantic_graphs.schemas.projected.Schema__Projected__Semantic_Graph import Schema__Projected__Semantic_Graph
from osbot_utils.helpers.semantic_graphs.schemas.projected.Schema__Projected__Node           import Schema__Projected__Node
from osbot_utils.helpers.semantic_graphs.schemas.projected.Schema__Projected__Edge           import Schema__Projected__Edge
from osbot_utils.helpers.semantic_graphs.schemas.projected.Schema__Projected__Data           import Schema__Projected__Data
from osbot_utils.helpers.semantic_graphs.schemas.projected.Schema__Projected__References     import Schema__Projected__References
from osbot_utils.helpers.semantic_graphs.schemas.projected.Schema__Projected__Taxonomy       import Schema__Projected__Taxonomy
```

### Identifier Types

```python
# Instance IDs (unique per object)
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Ontology_Id      import Ontology_Id
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Taxonomy_Id      import Taxonomy_Id
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Node_Type_Id     import Node_Type_Id
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Predicate_Id     import Predicate_Id
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Category_Id      import Category_Id
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Property_Name_Id import Property_Name_Id
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Property_Type_Id import Property_Type_Id
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Rule_Set_Id      import Rule_Set_Id

# Human-readable Refs (labels)
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Ontology_Ref      import Ontology_Ref
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Taxonomy_Ref      import Taxonomy_Ref
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Node_Type_Ref     import Node_Type_Ref
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Predicate_Ref     import Predicate_Ref
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Category_Ref      import Category_Ref
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Property_Name_Ref import Property_Name_Ref
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Property_Type_Ref import Property_Type_Ref
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Rule_Set_Ref      import Rule_Set_Ref

# ID source tracking
from osbot_utils.helpers.semantic_graphs.schemas.identifier.Schema__Id__Source import Schema__Id__Source
from osbot_utils.helpers.semantic_graphs.schemas.enum.Enum__Id__Source_Type    import Enum__Id__Source_Type
```

### Collection Types

```python
# Node/Edge collections
from osbot_utils.helpers.semantic_graphs.schemas.collection.Dict__Nodes__By_Id          import Dict__Nodes__By_Id
from osbot_utils.helpers.semantic_graphs.schemas.collection.List__Semantic_Graph__Edges import List__Semantic_Graph__Edges
from osbot_utils.helpers.semantic_graphs.schemas.collection.List__Node_Ids              import List__Node_Ids

# Ontology collections
from osbot_utils.helpers.semantic_graphs.schemas.collection.Dict__Node_Types__By_Id     import Dict__Node_Types__By_Id
from osbot_utils.helpers.semantic_graphs.schemas.collection.Dict__Predicates__By_Id     import Dict__Predicates__By_Id
from osbot_utils.helpers.semantic_graphs.schemas.collection.Dict__Property_Names__By_Id import Dict__Property_Names__By_Id
from osbot_utils.helpers.semantic_graphs.schemas.collection.Dict__Property_Types__By_Id import Dict__Property_Types__By_Id
from osbot_utils.helpers.semantic_graphs.schemas.collection.List__Edge_Rules            import List__Edge_Rules

# Property collections
from osbot_utils.helpers.semantic_graphs.schemas.collection.Dict__Node_Properties       import Dict__Node_Properties
from osbot_utils.helpers.semantic_graphs.schemas.collection.Dict__Edge_Properties       import Dict__Edge_Properties
```

### Test Data Factory

```python
from osbot_utils.helpers.semantic_graphs.testing.QA__Semantic_Graphs__Test_Data import QA__Semantic_Graphs__Test_Data
```

### Supporting Types

```python
from osbot_utils.type_safe.Type_Safe                                                  import Type_Safe
from osbot_utils.type_safe.type_safe_core.decorators.type_safe                        import type_safe
from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id                      import Obj_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Node_Id                     import Node_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Edge_Id                     import Edge_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Graph_Id                    import Graph_Id
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Id       import Safe_Str__Id
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Id__Seed import Safe_Str__Id__Seed
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Text          import Safe_Str__Text
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Version       import Safe_Str__Version
```

---

## API Reference by Category

### Semantic_Graph__Builder Methods

| Method | Description | Returns |
|--------|-------------|---------|
| `with_ontology_id(id)` | Set ontology for this graph | `self` (fluent) |
| `with_registry(registry)` | Set registry for ref resolution | `self` (fluent) |
| `with_graph_id(id, source)` | Set explicit graph ID | `self` (fluent) |
| `with_deterministic_graph_id(seed)` | Set deterministic graph ID | `self` (fluent) |
| `add_node(type_id, name, ...)` | Add node with ID | `self` (fluent) |
| `add_node_by_ref(type_ref, name, ...)` | Add node, resolving type ref | `self` (fluent) |
| `add_node_with_seed(type_id, name, seed, ...)` | Add node with deterministic ID | `self` (fluent) |
| `add_node_property(node_id, prop_id, value)` | Add property to existing node | `self` (fluent) |
| `add_edge(from_id, pred_id, to_id, ...)` | Add edge with IDs | `self` (fluent) |
| `add_edge_by_ref(from_id, pred_ref, to_id, ...)` | Add edge, resolving predicate ref | `self` (fluent) |
| `add_edge_with_seed(from_id, pred_id, to_id, seed, ...)` | Add edge with deterministic ID | `self` (fluent) |
| `add_edge_property(edge_id, prop_id, value)` | Add property to existing edge | `self` (fluent) |
| `build()` | Return completed graph | `Schema__Semantic_Graph` |

### Semantic_Graph__Utils Methods

| Method | Description | Returns |
|--------|-------------|---------|
| `get_node(graph, node_id)` | Get node by ID | `Schema__Semantic_Graph__Node` |
| `has_node(graph, node_id)` | Check if node exists | `bool` |
| `all_node_ids(graph)` | All node IDs | `List__Node_Ids` |
| `node_count(graph)` | Number of nodes | `int` |
| `edge_count(graph)` | Number of edges | `int` |
| `nodes_by_type(graph, type_id)` | Nodes of specific type | `List__Node_Ids` |
| `outgoing_edges(graph, node_id)` | Edges from node | `List__Semantic_Graph__Edges` |
| `incoming_edges(graph, node_id)` | Edges to node | `List__Semantic_Graph__Edges` |
| `edges_with_predicate(graph, pred_id)` | Edges with predicate | `List__Semantic_Graph__Edges` |
| `neighbors(graph, node_id)` | Adjacent nodes (both directions) | `List__Node_Ids` |
| `outgoing_neighbors(graph, node_id)` | Nodes this node points to | `List__Node_Ids` |
| `incoming_neighbors(graph, node_id)` | Nodes pointing to this node | `List__Node_Ids` |
| `has_edge(graph, from_id, pred_id, to_id)` | Check if edge exists | `bool` |
| `find_edge(graph, from_id, pred_id, to_id)` | Find specific edge | `Schema__Semantic_Graph__Edge` |
| `get_node_property(graph, node_id, prop_id)` | Get property from node | `Safe_Str__Text` |
| `has_node_property(graph, node_id, prop_id)` | Check if node has property | `bool` |
| `nodes_with_property(graph, prop_id)` | All nodes with property | `List__Node_Ids` |
| `get_edge_property(edge, prop_id)` | Get property from edge | `Safe_Str__Text` |
| `has_edge_property(edge, prop_id)` | Check if edge has property | `bool` |
| `edges_with_property(graph, prop_id)` | All edges with property | `List__Semantic_Graph__Edges` |

### Ontology__Registry Methods

| Method | Description | Returns |
|--------|-------------|---------|
| `create_with__random_id(ref, ...)` | Create ontology with random ID | `Schema__Ontology` |
| `create_with__deterministic_id(ref, seed, ...)` | Create ontology with deterministic ID | `Schema__Ontology` |
| `create_with__explicit_id(ref, id, ...)` | Create ontology with explicit ID | `Schema__Ontology` |
| `register(ontology)` | Register ontology in indexes | `Schema__Ontology` |
| `get_by_id(id)` | Lookup by instance ID | `Schema__Ontology` |
| `get_by_ref(ref)` | Lookup by reference name | `Schema__Ontology` |
| `has_id(id)` | Check if ID exists | `bool` |
| `has_ref(ref)` | Check if ref exists | `bool` |
| `all_ids()` | All registered IDs | `List__Ontology_Ids` |
| `all_refs()` | All registered refs | `List__Ontology_Refs` |
| `get_node_type_by_id(ont_id, type_id)` | Get node type by ID | `Schema__Ontology__Node_Type` |
| `get_node_type_by_ref(ont_id, type_ref)` | Get node type by ref | `Schema__Ontology__Node_Type` |
| `get_predicate_by_id(ont_id, pred_id)` | Get predicate by ID | `Schema__Ontology__Predicate` |
| `get_predicate_by_ref(ont_id, pred_ref)` | Get predicate by ref | `Schema__Ontology__Predicate` |
| `get_property_name_by_id(ont_id, prop_id)` | Get property name by ID | `Schema__Ontology__Property_Name` |
| `get_property_type_by_id(ont_id, type_id)` | Get property type by ID | `Schema__Ontology__Property_Type` |

### Ontology__Utils Methods

| Method | Description | Returns |
|--------|-------------|---------|
| `create_node_type(ref, category_id, seed)` | Create node type | `Schema__Ontology__Node_Type` |
| `create_predicate(ref, inverse_id, seed)` | Create predicate | `Schema__Ontology__Predicate` |
| `create_predicate_pair(ref, inverse_ref, ...)` | Create linked predicate pair | `tuple` |
| `create_property_name(ref, type_id, seed)` | Create property name | `Schema__Ontology__Property_Name` |
| `create_property_type(ref, seed)` | Create property type | `Schema__Ontology__Property_Type` |
| `create_edge_rule(source_id, pred_id, target_id)` | Create edge rule | `Schema__Ontology__Edge_Rule` |
| `get_node_type(ontology, id)` | Get node type by ID | `Schema__Ontology__Node_Type` |
| `has_node_type(ontology, id)` | Check if node type exists | `bool` |
| `get_predicate(ontology, id)` | Get predicate by ID | `Schema__Ontology__Predicate` |
| `has_predicate(ontology, id)` | Check if predicate exists | `bool` |
| `get_inverse_predicate(ontology, id)` | Get inverse predicate | `Schema__Ontology__Predicate` |
| `is_valid_edge(ontology, src_id, pred_id, tgt_id)` | Check if edge is valid per rules | `bool` |
| `valid_targets_for(ontology, src_id, pred_id)` | Get valid target types | `List__Node_Type_Ids` |
| `valid_predicates_for(ontology, src_id)` | Get valid predicates from source | `List__Predicate_Ids` |

### Taxonomy__Utils Methods

| Method | Description | Returns |
|--------|-------------|---------|
| `get_category(taxonomy, id)` | Get category by ID | `Schema__Taxonomy__Category` |
| `get_category_by_ref(taxonomy, ref)` | Get category by ref | `Schema__Taxonomy__Category` |
| `has_category(taxonomy, id)` | Check if category exists | `bool` |
| `all_category_ids(taxonomy)` | All category IDs | `List__Category_Ids` |
| `get_root_category(taxonomy)` | Get root category | `Schema__Taxonomy__Category` |
| `get_parent(taxonomy, id)` | Get parent category | `Schema__Taxonomy__Category` |
| `get_children(taxonomy, id)` | Get child IDs | `List__Category_Ids` |
| `get_ancestors(taxonomy, id)` | All ancestor IDs (to root) | `List__Category_Ids` |
| `get_descendants(taxonomy, id)` | All descendant IDs (recursive) | `List__Category_Ids` |
| `is_ancestor_of(taxonomy, cat_id, child_id)` | Check if category is ancestor | `bool` |
| `depth(taxonomy, id)` | Depth in tree (root = 0) | `int` |

---

## Common Patterns

### Pattern 1: Complete Graph Construction

```python
from osbot_utils.helpers.semantic_graphs.testing.QA__Semantic_Graphs__Test_Data import QA__Semantic_Graphs__Test_Data

# Use test data factory for quick setup
test_data = QA__Semantic_Graphs__Test_Data()
fixture   = test_data.create_complete_fixture()

ontology_registry = fixture['ontology_registry']
taxonomy_registry = fixture['taxonomy_registry']
graph             = fixture['graph']
projection        = fixture['projection']
```

### Pattern 2: Custom Ontology from Scratch

```python
from osbot_utils.helpers.semantic_graphs.ontology.Ontology__Registry import Ontology__Registry
from osbot_utils.helpers.semantic_graphs.ontology.Ontology__Utils    import Ontology__Utils

registry = Ontology__Registry()
utils    = Ontology__Utils()

# Create node types
person  = utils.create_node_type(Node_Type_Ref('person') , seed=Safe_Str__Id__Seed('nt-person'))
company = utils.create_node_type(Node_Type_Ref('company'), seed=Safe_Str__Id__Seed('nt-company'))

# Create predicates with inverses
works_at, employs = utils.create_predicate_pair(Predicate_Ref('works_at'),
                                                Predicate_Ref('employs') ,
                                                seed        = Safe_Str__Id__Seed('pred-works'),
                                                inverse_seed= Safe_Str__Id__Seed('pred-employs'))

# Create edge rule: person --works_at--> company
rule = utils.create_edge_rule(person.node_type_id, works_at.predicate_id, company.node_type_id)

# Create ontology with all components
ontology = registry.create_with__deterministic_id(ontology_ref = Ontology_Ref('hr_domain'),
                                                  seed         = Safe_Str__Id__Seed('ont-hr'))
ontology.node_types[person.node_type_id]    = person
ontology.node_types[company.node_type_id]   = company
ontology.predicates[works_at.predicate_id]  = works_at
ontology.predicates[employs.predicate_id]   = employs
ontology.edge_rules.append(rule)
```

### Pattern 3: Graph with Properties

```python
from osbot_utils.helpers.semantic_graphs.schemas.collection.Dict__Node_Properties import Dict__Node_Properties

# Define property names in ontology
pn_salary = utils.create_property_name(Property_Name_Ref('salary'),
                                       property_type_id = pt_integer_id)
ontology.property_names[pn_salary.property_name_id] = pn_salary

# Build graph with properties
builder = Semantic_Graph__Builder()
builder.with_ontology_id(ontology.ontology_id)

props = Dict__Node_Properties()
props[pn_salary.property_name_id] = Safe_Str__Text('100000')

builder.add_node_with_seed(node_type_id = person.node_type_id     ,
                           name         = Safe_Str__Id('Alice')   ,
                           seed         = Safe_Str__Id__Seed('n1'),
                           properties   = props                   )
```

### Pattern 4: Validation Workflow

```python
from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Validator import Semantic_Graph__Validator
from osbot_utils.helpers.semantic_graphs.rule.Rule_Set__Utils            import Rule_Set__Utils

# Validate against ontology edge rules
validator = Semantic_Graph__Validator()
result    = validator.validate(graph, ontology)

if result.valid is False:
    for error in result.errors:
        print(f"Edge rule violation: {error}")

# Validate required properties
rule_utils = Rule_Set__Utils()
violations = rule_utils.validate_all_properties(rule_set, graph)

if len(violations) > 0:
    for v in violations:
        print(f"Missing property {v['missing_property']} on {v['node_id']}")
```

### Pattern 5: Projection for Export

```python
from osbot_utils.helpers.semantic_graphs.projector.Semantic_Graph__Projector import Semantic_Graph__Projector

projector  = Semantic_Graph__Projector(ontology_registry = registry        ,
                                       taxonomy_registry = taxonomy_registry)
projection = projector.project(graph)

# Export to JSON-friendly format
export_data = {
    'nodes': [{'type': n.ref, 'name': n.name, 'properties': dict(n.properties or {})}
              for n in projection.projection.nodes],
    'edges': [{'from': e.from_name, 'relation': e.ref, 'to': e.to_name}
              for e in projection.projection.edges],
    'taxonomy': {
        'node_categories': dict(projection.taxonomy.node_type_categories),
        'category_hierarchy': dict(projection.taxonomy.category_parents)
    }
}
```

---

## Best Practices

### DO: Use Deterministic IDs for Reproducibility

```python
# ✓ Correct - deterministic IDs for test fixtures
builder.add_node_with_seed(node_type_id = nt_class_id                    ,
                           name         = Safe_Str__Id('MyClass')        ,
                           seed         = Safe_Str__Id__Seed('test-class'))

# ✓ Correct - same seed = same ID every time
id_1 = Obj_Id.from_seed(Safe_Str__Id__Seed('stable-seed'))
id_2 = Obj_Id.from_seed(Safe_Str__Id__Seed('stable-seed'))
assert id_1 == id_2
```

### DO: Keep Schemas Pure Data

```python
# ✓ Correct - schema is pure data
class Schema__MyGraph(Type_Safe):
    graph_id    : Graph_Id
    ontology_id : Ontology_Id
    nodes       : Dict__Nodes__By_Id

# ✓ Correct - logic in separate class
class MyGraph__Utils(Type_Safe):
    
    @type_safe
    def count_nodes_by_type(self, graph: Schema__MyGraph, type_id: Node_Type_Id) -> int:
        count = 0
        for node in graph.nodes.values():
            if node.node_type_id == type_id:
                count += 1
        return count
```

### DO: Validate Before Processing

```python
# ✓ Correct - validate first, then process
validator = Semantic_Graph__Validator()
result    = validator.validate(graph, ontology)

if result.valid is False:
    return None  # or raise appropriate error

# Safe to process validated graph
return process_graph(graph)
```

### DO: Use Fluent Builder Pattern

```python
# ✓ Correct - chain builder calls
graph = (Semantic_Graph__Builder()
         .with_ontology_id(ontology.ontology_id)
         .with_deterministic_graph_id(Safe_Str__Id__Seed('my-graph'))
         .add_node_with_seed(nt_class_id, Safe_Str__Id('A'), Safe_Str__Id__Seed('a'))
         .add_node_with_seed(nt_class_id, Safe_Str__Id('B'), Safe_Str__Id__Seed('b'))
         .build())
```

### DON'T: Put Logic in Schemas

```python
# ✗ Wrong - method in schema
class Schema__Ontology(Type_Safe):
    node_types : Dict__Node_Types__By_Id
    
    def get_node_type(self, id):                         # NO!
        return self.node_types.get(id)
```

### DON'T: Use Raw Strings for IDs/Refs

```python
# ✗ Wrong - raw strings
ontology_id = 'abc123'
node_type   = 'class'

# ✓ Correct - typed identifiers
ontology_id = Ontology_Id(Obj_Id())
node_type   = Node_Type_Ref('class')
```

### DON'T: Mix IDs and Refs

```python
# ✗ Wrong - using ref where ID expected
edge = Schema__Semantic_Graph__Edge(from_node_id = 'node-1',           # String!
                                    predicate_id = Predicate_Ref('calls'),  # Ref not ID!
                                    to_node_id   = node_2.node_id)

# ✓ Correct - proper ID types
edge = Schema__Semantic_Graph__Edge(from_node_id = node_1.node_id     ,
                                    predicate_id = pred_calls.predicate_id,
                                    to_node_id   = node_2.node_id     )
```

### DON'T: Forget Edge Rules

```python
# ✗ Wrong - adding edges without rules
builder.add_edge(class_id, calls_id, package_id)  # Will fail validation!

# ✓ Correct - ensure rule exists in ontology first
rule = utils.create_edge_rule(nt_class_id, pred_calls_id, nt_method_id)
ontology.edge_rules.append(rule)
# Now edge is valid
builder.add_edge(class_id, pred_calls_id, method_id)
```

---

## Troubleshooting

### Problem: "Unknown node_type_id" Validation Error

**Cause**: Node type not registered in ontology

```python
# ✗ Error: Node 'n1' has unknown node_type_id: abc123...
builder.add_node(node_type_id = Node_Type_Id('abc123'),  # Not in ontology!
                 name         = Safe_Str__Id('test'))

# ✓ Solution: Register node type first
nt_test = utils.create_node_type(Node_Type_Ref('test'))
ontology.node_types[nt_test.node_type_id] = nt_test

builder.add_node(node_type_id = nt_test.node_type_id,
                 name         = Safe_Str__Id('test'))
```

### Problem: "Invalid edge" Validation Error

**Cause**: No edge rule allows this combination

```python
# ✗ Error: Invalid edge: class --[calls]--> package
# No rule permits class to call package

# ✓ Solution: Add edge rule or use correct types
rule = utils.create_edge_rule(nt_class_id, pred_calls_id, nt_method_id)
ontology.edge_rules.append(rule)
```

### Problem: "Registry required to resolve ref" Error

**Cause**: Using `*_by_ref` method without registry

```python
# ✗ Error: Registry required to resolve node_type_ref to node_type_id
builder.add_node_by_ref(Node_Type_Ref('class'), Safe_Str__Id('A'))

# ✓ Solution: Set registry first
builder.with_registry(ontology_registry)
builder.add_node_by_ref(Node_Type_Ref('class'), Safe_Str__Id('A'))
```

### Problem: Node/Edge Not Found

**Cause**: Wrong ID or ID not in graph

```python
# Check if node exists before accessing
if utils.has_node(graph, node_id):
    node = utils.get_node(graph, node_id)
else:
    print(f"Node {node_id} not found")

# Use find_edge which returns None if not found
edge = utils.find_edge(graph, from_id, pred_id, to_id)
if edge is None:
    print("Edge not found")
```

### Problem: Empty Projection

**Cause**: Ontology not found in registry

```python
# ✗ Empty projection - ontology_id not in registry
projector  = Semantic_Graph__Projector(ontology_registry = Ontology__Registry())
projection = projector.project(graph)  # projection.projection.nodes is empty

# ✓ Solution: Ensure ontology is registered
registry.register(ontology)
projector  = Semantic_Graph__Projector(ontology_registry = registry)
projection = projector.project(graph)
```

### Problem: Deterministic IDs Don't Match

**Cause**: Different seeds or seed string variations

```python
# These produce DIFFERENT IDs
id_1 = Obj_Id.from_seed(Safe_Str__Id__Seed('my-node'))
id_2 = Obj_Id.from_seed(Safe_Str__Id__Seed('my_node'))   # Different seed!
id_3 = Obj_Id.from_seed(Safe_Str__Id__Seed('My-Node'))   # Case matters!

# ✓ Use consistent seed naming conventions
SEED_MY_NODE = Safe_Str__Id__Seed('my-node')
id_1 = Obj_Id.from_seed(SEED_MY_NODE)
id_2 = Obj_Id.from_seed(SEED_MY_NODE)  # Same!
```

### Problem: Property Value Type Mismatch

**Cause**: Properties store `Safe_Str__Text`, not native types

```python
# ✗ Wrong - storing int directly
node.properties[prop_id] = 42  # Type error!

# ✓ Correct - convert to Safe_Str__Text
node.properties[prop_id] = Safe_Str__Text('42')

# Reading: parse string value as needed
line_number = int(str(utils.get_node_property(graph, node_id, pn_line_number_id)))
```

---

## Summary Checklist

When working with Semantic Graphs:

**Schema Design:**
- [ ] Schemas are PURE DATA - no methods
- [ ] All attributes have type annotations
- [ ] Use Dict__ and List__ typed collections
- [ ] Use ID types for internal references (Node_Id, Edge_Id, etc.)
- [ ] Use Ref types for human-readable labels (Node_Type_Ref, Predicate_Ref, etc.)

**Ontology Setup:**
- [ ] Create node types with `Ontology__Utils.create_node_type()`
- [ ] Create predicate pairs with `Ontology__Utils.create_predicate_pair()`
- [ ] Define edge rules for all valid edge combinations
- [ ] Register ontology with `Ontology__Registry.register()`
- [ ] Define property names and types if using properties

**Graph Building:**
- [ ] Use `Semantic_Graph__Builder` for construction
- [ ] Call `with_ontology_id()` before adding nodes/edges
- [ ] Use `*_with_seed()` methods for deterministic IDs
- [ ] Use `*_by_ref()` methods with registry for human-friendly building
- [ ] Call `build()` to get final graph

**Validation:**
- [ ] Validate graphs with `Semantic_Graph__Validator.validate()`
- [ ] Check `result.valid` before processing
- [ ] Use `Rule_Set__Utils.validate_all_properties()` for property rules
- [ ] Handle validation errors gracefully

**Projection:**
- [ ] Create projector with ontology and taxonomy registries
- [ ] Use `Semantic_Graph__Projector.project()` for human-readable output
- [ ] Access `projection.projection.nodes` and `projection.projection.edges`
- [ ] Use `projection.references` to map refs back to IDs

**ID Management:**
- [ ] Use `Obj_Id()` for random IDs
- [ ] Use `Obj_Id.from_seed()` for deterministic IDs
- [ ] Store seeds as constants for reproducibility
- [ ] Track ID sources with `Schema__Id__Source` when needed

**Testing:**
- [ ] Use `QA__Semantic_Graphs__Test_Data` for test fixtures
- [ ] Use deterministic seeds for reproducible tests
- [ ] Create complete fixtures with `create_complete_fixture()`
- [ ] Access pre-generated IDs with `get_*_id__*()` methods
