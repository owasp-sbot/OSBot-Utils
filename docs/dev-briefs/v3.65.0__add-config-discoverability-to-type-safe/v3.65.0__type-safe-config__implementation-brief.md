# Type_Safe__Config - LLM Usage Brief

**Version**: v3.65.0  
**Status**: Design validated, ready for implementation  
**Purpose**: Unified configuration object for controlling Type_Safe behavior via stack context  
**Location**: `osbot_utils.type_safe.Type_Safe__Config`  
**Repo**: https://github.com/owasp-sbot/OSBot-Utils  
**Install**: `pip install osbot-utils`

---

## What is Type_Safe__Config?

**Type_Safe__Config is a unified configuration object that controls Type_Safe behavior through stack context, eliminating the need for per-feature magic variables and instance attribute pollution.**

### The Problem

Each Type_Safe feature currently requires its own plumbing:

```python
# Fast mode: magic stack variable
_type_safe_fast_mode_ = type_safe_fast_mode()
with _type_safe_fast_mode_:
    ...

# On-demand: pollutes every instance with internal attributes
class Type_Safe__On_Demand(Type_Safe):
    def __init__(self, **kwargs):
        object.__setattr__(self, '_on_demand__init_complete', False)
        object.__setattr__(self, '_on_demand__types', {})
        ...

# Immutability: would need more instance variables
_immutable__locked = True

# Each feature adds its own complexity!
```

### The Solution

One config object, one stack variable, controls everything:

```python
_type_safe_config_ = Type_Safe__Config(skip_validation = True ,
                                       on_demand_nested = True ,
                                       immutable        = False)
with _type_safe_config_:
    graph = MGraph(...)                                                          # All nested objects inherit config
```

---

## Type_Safe__Config Class

```python
class Type_Safe__Config(Type_Safe):
    
    # ═══════════════════════════════════════════════════════════════════════════
    # Init Step Controls - Granular control over __init__ code paths
    # ═══════════════════════════════════════════════════════════════════════════
    skip_mro_walk      : bool = False                                            # Skip MRO annotation walking (use cached)
    skip_defaults      : bool = False                                            # Skip default value creation
    skip_conversion    : bool = False                                            # Skip type coercion (str → Safe_Id)
    skip_validation    : bool = False                                            # Skip type checking on assignment
    skip_setattr       : bool = False                                            # Use object.__setattr__ directly
    
    # ═══════════════════════════════════════════════════════════════════════════
    # On-Demand Creation - Defer nested object creation until access
    # ═══════════════════════════════════════════════════════════════════════════
    on_demand_nested   : bool = False                                            # Create nested Type_Safe on first access
    
    # ═══════════════════════════════════════════════════════════════════════════
    # Immutability - Prevent modification after creation
    # ═══════════════════════════════════════════════════════════════════════════
    immutable          : bool = False                                            # Block all __setattr__ after init
    freeze_after_init  : bool = False                                            # Become immutable after __init__ completes
    
    # ═══════════════════════════════════════════════════════════════════════════
    # Validation Strictness
    # ═══════════════════════════════════════════════════════════════════════════
    strict_types       : bool = True                                             # Require exact type matches
    allow_extra_attrs  : bool = False                                            # Allow attributes not in annotations
    
    # ═══════════════════════════════════════════════════════════════════════════
    # Debugging / Metrics
    # ═══════════════════════════════════════════════════════════════════════════
    trace_creation     : bool = False                                            # Log object creation
    collect_metrics    : bool = False                                            # Track creation counts/times
    
    # ═══════════════════════════════════════════════════════════════════════════
    # Context Manager Support
    # ═══════════════════════════════════════════════════════════════════════════
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        return False
```

---

## Stack Discovery

Type_Safe__Config uses the **Stack Variable Discovery** pattern (see separate brief) to propagate configuration through the call stack:

```python
TYPE_SAFE__CONFIG__VAR_NAME    = '_type_safe_config_'
TYPE_SAFE__CONFIG__CHECKED_VAR = '_type_safe_config__checked_'

def find_type_safe_config() -> Optional[Type_Safe__Config]:
    frame           = inspect.currentframe()
    previous_frames = []
    
    for _ in range(MAX_DEPTH):
        frame = frame.f_back
        if frame is None:
            break
        
        config = frame.f_locals.get(TYPE_SAFE__CONFIG__VAR_NAME)
        
        if isinstance(config, Type_Safe__Config):                                # Found config
            for previous_frame in previous_frames:
                previous_frame.f_locals[TYPE_SAFE__CONFIG__VAR_NAME] = config
            return config
        
        if frame.f_locals.get(TYPE_SAFE__CONFIG__CHECKED_VAR):                   # Already checked, no config
            return None
        
        previous_frames.append(frame)
    
    for previous_frame in previous_frames:
        previous_frame.f_locals[TYPE_SAFE__CONFIG__CHECKED_VAR] = True
    
    return None
```

### Performance

| Call | Frames Walked |
|------|---------------|
| First call in stack | O(depth to config) |
| All subsequent calls | **O(1-2)** |

The frame injection ensures `find_type_safe_config()` can be called liberally throughout Type_Safe code with minimal overhead.

---

## Incremental __init__ Optimization

The key insight: Type_Safe `__init__` has distinct steps, each with measurable cost. Config flags let us disable them one by one:

### Current __init__ Steps

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  Type_Safe.__init__(self, **kwargs)                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│  Step 1: MRO Walk            ~2-3 μs    → get_cls_kwargs()                  │
│  Step 2: Default Creation    ~1-5 μs    → create nested Type_Safe, colls   │
│  Step 3: Type Conversion     ~1-2 μs    → str → Safe_Id, etc.               │
│  Step 4: Validation          ~1-2 μs    → isinstance checks                 │
│  Step 5: __setattr__         ~2-3 μs    → per-attribute validation          │
├─────────────────────────────────────────────────────────────────────────────┤
│  Total:                      ~10-15 μs  (simple object)                     │
│                              ~40-100 μs (complex with nesting)              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Config-Controlled __init__

```python
class Type_Safe:
    def __init__(self, **kwargs):
        config = find_type_safe_config()                                         # ~300ns (cached)
        
        # ───────────────────────────────────────────────────────────────────────
        # Step 1: MRO Walk - collect class annotations
        # ───────────────────────────────────────────────────────────────────────
        if config and config.skip_mro_walk:
            cls_kwargs = self.__cls_kwargs__cached__()                            # Use class-level cache
        else:
            cls_kwargs = self.__cls_kwargs__(kwargs)                              # Full MRO walk
        
        # ───────────────────────────────────────────────────────────────────────
        # Step 2: Default Value Creation
        # ───────────────────────────────────────────────────────────────────────
        if config and config.skip_defaults:
            pass                                                                  # Caller must provide all values
        elif config and config.on_demand_nested:
            self.__setup_on_demand__(cls_kwargs)                                  # Defer nested Type_Safe
        else:
            self.__create_defaults__(cls_kwargs)                                  # Create all defaults now
        
        # ───────────────────────────────────────────────────────────────────────
        # Step 3: Type Conversion
        # ───────────────────────────────────────────────────────────────────────
        if config and config.skip_conversion:
            converted = kwargs                                                    # Use values as-is
        else:
            converted = self.__convert_types__(kwargs, cls_kwargs)                # str → Safe_Id, etc.
        
        # ───────────────────────────────────────────────────────────────────────
        # Step 4 & 5: Validation and Assignment
        # ───────────────────────────────────────────────────────────────────────
        if config and config.skip_setattr:
            for name, value in converted.items():
                object.__setattr__(self, name, value)                             # Direct, no validation
        elif config and config.skip_validation:
            for name, value in converted.items():
                object.__setattr__(self, name, value)                             # Direct, no validation
        else:
            for name, value in converted.items():
                setattr(self, name, value)                                        # Full __setattr__ path
        
        # ───────────────────────────────────────────────────────────────────────
        # Post-init: Freeze if configured
        # ───────────────────────────────────────────────────────────────────────
        if config and config.freeze_after_init:
            object.__setattr__(self, '_type_safe__frozen', True)
```

### Incremental Profiling Strategy

| Step | Config Flag | Disable & Measure | Expected Savings |
|------|-------------|-------------------|------------------|
| 1 | `skip_mro_walk` | Profile with/without | ~2-3 μs |
| 2 | `skip_defaults` | Profile with/without | ~1-5 μs |
| 2b | `on_demand_nested` | Profile with/without | ~1-5 μs (deferred) |
| 3 | `skip_conversion` | Profile with/without | ~1-2 μs |
| 4+5 | `skip_validation` / `skip_setattr` | Profile with/without | ~3-5 μs |

### Benchmarking Each Step

```python
class test_Init_Step_Profiling(TestCase):

    @classmethod
    def setUpClass(cls):
        cls.session = Perf(assert_enabled=False)
    
    def test__step_1__mro_walk_cost(self):
        # Baseline: full init
        _type_safe_config_ = Type_Safe__Config()
        with _type_safe_config_:
            with self.session as _:
                _.measure(lambda: Schema__Test(name="test")).print()
                baseline = _.result.raw_score
        
        # With skip_mro_walk
        _type_safe_config_ = Type_Safe__Config(skip_mro_walk=True)
        with _type_safe_config_:
            with self.session as _:
                _.measure(lambda: Schema__Test(name="test")).print()
                optimized = _.result.raw_score
        
        savings = baseline - optimized
        print(f"    → MRO walk cost: {savings:,.0f} ns")
    
    def test__step_2__defaults_cost(self):
        # Similar pattern for skip_defaults
        ...
    
    def test__step_3__conversion_cost(self):
        # Similar pattern for skip_conversion
        ...
    
    def test__step_4_5__validation_cost(self):
        # Similar pattern for skip_validation
        ...
```

### Progressive Optimization Levels

```python
# Level 0: Full validation (current behavior)
_type_safe_config_ = Type_Safe__Config()

# Level 1: Skip expensive setattr validation
_type_safe_config_ = Type_Safe__Config(skip_setattr=True)

# Level 2: Skip type conversion too
_type_safe_config_ = Type_Safe__Config(skip_setattr    = True ,
                                       skip_conversion = True )

# Level 3: Skip default creation (caller provides all)
_type_safe_config_ = Type_Safe__Config(skip_setattr    = True ,
                                       skip_conversion = True ,
                                       skip_defaults   = True )

# Level 4: Maximum speed (use cached MRO)
_type_safe_config_ = Type_Safe__Config(skip_setattr    = True ,
                                       skip_conversion = True ,
                                       skip_defaults   = True ,
                                       skip_mro_walk   = True )

# Alternative: On-demand for nested objects
_type_safe_config_ = Type_Safe__Config(skip_setattr     = True ,
                                       skip_conversion  = True ,
                                       on_demand_nested = True )
```

### Expected Performance After Full Optimization

| Config Level | Time per Object | vs Baseline |
|--------------|-----------------|-------------|
| Level 0 (baseline) | ~12,000 ns | 1x |
| Level 1 (skip_setattr) | ~8,000 ns | 1.5x |
| Level 2 (+skip_conversion) | ~6,000 ns | 2x |
| Level 3 (+skip_defaults) | ~3,000 ns | 4x |
| Level 4 (+skip_mro_walk) | ~1,000 ns | **12x** |
| With on_demand_nested | ~500 ns | **24x** |

Target: **~500-1,000 ns per object** (within 2-3x of plain Python class)

---

## Quick Start

### Basic Fast Mode

```python
from osbot_utils.type_safe.Type_Safe__Config import Type_Safe__Config

_type_safe_config_ = Type_Safe__Config(skip_validation=True)
with _type_safe_config_:
    nodes = [Schema__Node(**d) for d in data_list]                               # ~20x faster
```

### Combined Modes

```python
_type_safe_config_ = Type_Safe__Config(skip_validation = True ,
                                       on_demand_nested = True )
with _type_safe_config_:
    graph = MGraph__Index()                                                      # Fast + on-demand
```

### Immutable Objects

```python
_type_safe_config_ = Type_Safe__Config(freeze_after_init=True)
with _type_safe_config_:
    config = App__Config(host="localhost", port=8080)
    config.port = 9090                                                           # Raises TypeError!
```

---

## Integration Points

### Type_Safe.__init__

```python
class Type_Safe:
    def __init__(self, **kwargs):
        config = find_type_safe_config()
        
        if config and config.skip_validation:
            self.__init_fast__(kwargs)
        elif config and config.on_demand_nested:
            self.__init_on_demand__(kwargs)
        else:
            self.__init_normal__(kwargs)
        
        if config and config.freeze_after_init:
            object.__setattr__(self, '_type_safe__frozen', True)
```

### Type_Safe.__setattr__

```python
class Type_Safe:
    def __setattr__(self, name, value):
        config = find_type_safe_config()
        
        # Check immutability
        if getattr(self, '_type_safe__frozen', False):
            raise TypeError(f"Cannot modify frozen {type(self).__name__}")
        
        if config and config.immutable:
            raise TypeError(f"Cannot modify immutable {type(self).__name__}")
        
        # Fast path - skip validation
        if config and config.skip_validation:
            object.__setattr__(self, name, value)
            return
        
        # Normal validation path
        ...
```

### Type_Safe__List Operations

```python
class Type_Safe__List:
    def append(self, item):
        config = find_type_safe_config()
        
        if config and config.skip_validation:
            self.data.append(item)                                               # Direct append
        else:
            self._validate_and_append(item)                                      # Normal path
```

---

## Feature Behaviors

### skip_mro_walk = True

| Operation | Normal | With skip_mro_walk |
|-----------|--------|---------------------|
| `__init__` | Walk MRO for annotations | Use class-level cache |
| First object | Full walk | Full walk (populates cache) |
| Subsequent | Full walk | Cache hit |

**Requirement**: Class-level cache must be populated (first object or explicit call).

### skip_defaults = True

| Operation | Normal | With skip_defaults |
|-----------|--------|--------------------|
| Unset attributes | Create default value | Left as None |
| Nested Type_Safe | Created recursively | Not created |
| Collections | Created (Type_Safe__List) | Not created |

**Requirement**: Caller must provide all attribute values explicitly.

### skip_conversion = True

| Operation | Normal | With skip_conversion |
|-----------|--------|----------------------|
| `node_id = "abc"` | `Safe_Id("abc")` | `"abc"` (stays str) |
| `count = "5"` | `int("5")` | `"5"` (stays str) |
| `items = [1,2]` | `Type_Safe__List([1,2])` | `[1,2]` (stays list) |

**Requirement**: Caller provides correctly-typed values.

### skip_validation = True

| Operation | Normal | With skip_validation |
|-----------|--------|----------------------|
| `obj.attr = value` | `isinstance()` check | No check |
| Wrong type | Raises TypeError | Silently accepts |

**Requirement**: Caller ensures type correctness.

### skip_setattr = True

| Operation | Normal | With skip_setattr |
|-----------|--------|-------------------|
| `obj.attr = value` | Through `__setattr__` | `object.__setattr__` |
| Custom __setattr__ logic | Executed | Bypassed |

**Requirement**: No custom `__setattr__` logic needed.

### on_demand_nested = True

| Operation | Normal | With on_demand_nested |
|-----------|--------|----------------------|
| `__init__` | Creates all nested Type_Safe | Defers creation |
| First access | Already created | Creates on access |
| Unused attrs | Memory allocated | No memory until used |

### immutable = True / freeze_after_init = True

| Operation | Normal | With immutable |
|-----------|--------|----------------|
| `__init__` | Normal | Normal |
| `obj.attr = x` after init | Allowed | Raises TypeError |
| `del obj.attr` | Allowed | Raises TypeError |

---

## Usage Patterns

### Pattern 1: Bulk Graph Loading

```python
def load_graph(data: dict) -> MGraph:
    _type_safe_config_ = Type_Safe__Config(skip_validation=True)
    with _type_safe_config_:
        nodes = [Schema__Node(**n) for n in data['nodes']]
        edges = [Schema__Edge(**e) for e in data['edges']]
    return MGraph(nodes=nodes, edges=edges)
```

### Pattern 2: High-Performance Index

```python
def create_index() -> MGraph__Index:
    _type_safe_config_ = Type_Safe__Config(skip_validation  = True ,
                                           on_demand_nested = True )
    with _type_safe_config_:
        return MGraph__Index()                                                   # ~90μs vs ~1800μs
```

### Pattern 3: Immutable Configuration

```python
def load_config() -> App__Config:
    _type_safe_config_ = Type_Safe__Config(freeze_after_init=True)
    with _type_safe_config_:
        return App__Config.from_json(config_data)                                # Frozen after creation
```

### Pattern 4: Debug Mode

```python
def debug_creation():
    _type_safe_config_ = Type_Safe__Config(trace_creation  = True ,
                                           collect_metrics = True )
    with _type_safe_config_:
        graph = MGraph(...)
    
    print(f"Objects created: {_type_safe_config_.metrics.object_count}")
```

---

## Migration Guide

### From Type_Safe__On_Demand

**Before:**
```python
class Schema__Data(Type_Safe__On_Demand):                                        # Special subclass
    edges : Dict[str, str]
    
class MGraph__Index(Type_Safe__On_Demand):                                       # Special subclass
    data: Schema__Data
```

**After:**
```python
class Schema__Data(Type_Safe):                                                   # Normal Type_Safe
    edges : Dict[str, str]

class MGraph__Index(Type_Safe):                                                  # Normal Type_Safe
    data: Schema__Data

# On-demand via config context
_type_safe_config_ = Type_Safe__Config(on_demand_nested=True)
with _type_safe_config_:
    index = MGraph__Index()
```

### From Fast Mode Marker

**Before:**
```python
_type_safe_fast_mode_ = type_safe_fast_mode()
with _type_safe_fast_mode_:
    nodes = [Schema__Node(**d) for d in data]
```

**After:**
```python
_type_safe_config_ = Type_Safe__Config(skip_validation=True)
with _type_safe_config_:
    nodes = [Schema__Node(**d) for d in data]
```

---

## Implementation Phases

### Phase 1: Core Infrastructure

- [ ] Create `Type_Safe__Config` class with all flags
- [ ] Implement `find_type_safe_config()` with frame injection
- [ ] Add `config = find_type_safe_config()` to `Type_Safe.__init__`
- [ ] Add `config = find_type_safe_config()` to `Type_Safe.__setattr__`
- [ ] Verify no regression (config=None behaves like current code)

### Phase 2: Baseline Measurement

- [ ] Create benchmark suite for each __init__ step
- [ ] Measure current Type_Safe costs:
  - [ ] MRO walk time
  - [ ] Default creation time
  - [ ] Type conversion time
  - [ ] Validation time
  - [ ] __setattr__ time
- [ ] Document baseline in tests

### Phase 3: Incremental Optimization (One Flag at a Time)

**Step 3a: skip_setattr**
- [ ] Implement `skip_setattr` flag
- [ ] Benchmark: measure savings
- [ ] Test: verify objects created correctly
- [ ] Document: actual savings vs expected

**Step 3b: skip_validation**
- [ ] Implement `skip_validation` flag
- [ ] Benchmark: measure savings
- [ ] Test: verify objects created correctly
- [ ] Document: actual savings vs expected

**Step 3c: skip_conversion**
- [ ] Implement `skip_conversion` flag
- [ ] Benchmark: measure savings
- [ ] Test: verify objects created correctly
- [ ] Document: actual savings vs expected

**Step 3d: skip_defaults**
- [ ] Implement `skip_defaults` flag
- [ ] Benchmark: measure savings
- [ ] Test: verify objects created correctly
- [ ] Document: actual savings vs expected

**Step 3e: skip_mro_walk**
- [ ] Implement class-level MRO cache
- [ ] Implement `skip_mro_walk` flag
- [ ] Benchmark: measure savings
- [ ] Test: verify objects created correctly
- [ ] Document: actual savings vs expected

### Phase 4: On-Demand Creation

- [ ] Implement `on_demand_nested` in `__init__`
- [ ] Implement lazy `__getattribute__`
- [ ] Benchmark vs `skip_defaults`
- [ ] Deprecate `Type_Safe__On_Demand` class

### Phase 5: Immutability

- [ ] Implement `immutable` flag in `__setattr__`
- [ ] Implement `freeze_after_init` flag
- [ ] Add `__delattr__` protection
- [ ] Test exception messages

### Phase 6: Polish & Documentation

- [ ] Implement `trace_creation` for debugging
- [ ] Implement `collect_metrics` for profiling
- [ ] Create migration guide
- [ ] Update all LLM briefs
- [ ] Add to osbot-utils documentation

---

## Summary Checklist

### Infrastructure
- [ ] Single config class: `Type_Safe__Config`
- [ ] Single magic variable: `_type_safe_config_`
- [ ] Separate checked variable: `_type_safe_config__checked_`
- [ ] Stack discovery with frame injection
- [ ] O(1-2) frame walks after first call

### Init Step Flags
- [ ] `skip_mro_walk` - use cached class annotations
- [ ] `skip_defaults` - caller provides all values
- [ ] `skip_conversion` - no type coercion
- [ ] `skip_validation` - no isinstance checks
- [ ] `skip_setattr` - use object.__setattr__ directly

### Feature Flags
- [ ] `on_demand_nested` - defer nested Type_Safe creation
- [ ] `immutable` - block modification
- [ ] `freeze_after_init` - become immutable after init
- [ ] `strict_types` - require exact type matches
- [ ] `allow_extra_attrs` - allow unannounced attributes

### Quality
- [ ] Backward compatible (no config = current behavior)
- [ ] Each flag independently testable
- [ ] Benchmarks for each flag
- [ ] Migration guide from Type_Safe__On_Demand
- [ ] No instance attribute pollution
