# Stack Variable Discovery - LLM Usage Brief

**Version**: v3.65.0  
**Status**: Pattern validated, production ready  
**Purpose**: General-purpose technique for propagating context through call stacks without explicit parameter passing  
**Location**: Reusable pattern (not a specific module)  
**Repo**: https://github.com/owasp-sbot/OSBot-Utils

---

## What is Stack Variable Discovery?

**Stack Variable Discovery is a technique for finding a specially-named variable in the call stack, with frame injection caching to make repeated lookups O(1).**

This enables "ambient context" - configuration or state that is automatically available to all code within a certain scope, without passing it through every function call.

---

## The Pattern

### Core Algorithm

```python
import inspect
from typing import Optional, TypeVar, Type

T = TypeVar('T')

VARIABLE_NAME    = '_my_context_'                                                # Variable to search for
CHECKED_VAR_NAME = '_my_context__checked_'                                       # Marker for "already searched"
MAX_DEPTH        = 15                                                            # Maximum frames to walk


def find_stack_variable(var_name   : str       ,
                        checked_var: str       ,
                        var_type   : Type[T]   ,
                        max_depth  : int = 15  ) -> Optional[T]:
    
    frame           = inspect.currentframe()
    previous_frames = []
    
    for _ in range(max_depth):
        frame = frame.f_back
        if frame is None:
            break
        
        value = frame.f_locals.get(var_name)
        
        if isinstance(value, var_type):                                          # Found it
            for previous_frame in previous_frames:
                previous_frame.f_locals[var_name] = value                        # Inject for future lookups
            return value
        
        if frame.f_locals.get(checked_var):                                      # Already checked this path
            return None
        
        previous_frames.append(frame)
    
    for previous_frame in previous_frames:                                       # Not found - mark as checked
        previous_frame.f_locals[checked_var] = True
    
    return None
```

### Usage Example

```python
# Define your context class
class My_Context:
    debug_mode: bool = False
    
    def __enter__(self):
        return self
    
    def __exit__(self, *args):
        return False

# Create a finder function
def find_my_context() -> Optional[My_Context]:
    return find_stack_variable('_my_context_'          ,
                               '_my_context__checked_' ,
                               My_Context              )

# Use it
def some_deep_function():
    ctx = find_my_context()
    if ctx and ctx.debug_mode:
        print("Debug: doing something")

def middle_function():
    some_deep_function()

def outer_function():
    _my_context_ = My_Context(debug_mode=True)
    with _my_context_:
        middle_function()                                                        # Context available throughout
```

---

## How Frame Injection Works

### The Problem: Repeated Stack Walks

Without optimization, nested calls repeatedly walk the same frames:

```
outer():           _my_context_ = Context()
  middle():        # walks 1 frame to find context
    inner():       # walks 2 frames to find context
      deep():      # walks 3 frames to find context
                   # Total: 6 frame walks
```

### The Solution: Inject Into Walked Frames

When we find the variable, inject it into all frames we walked through:

```
outer():           _my_context_ = Context()
  middle():        # walks 1 frame, finds context, injects into middle
    inner():       # walks 1 frame, finds injected context in middle!
      deep():      # walks 1 frame, finds injected context in inner!
                   # Total: 3 frame walks (plus 3 O(1) injections)
```

### Caching "Not Found"

When no context exists, cache this fact to avoid repeated full walks:

```
outer():           # no context
  middle():        # walks to max_depth, marks all frames as "checked"
    inner():       # walks 1 frame, sees "checked" marker, returns None
      deep():      # walks 1 frame, sees "checked" marker, returns None
                   # Total: max_depth + 2 (not max_depth Ã— 3)
```

---

## Performance Characteristics

### Time Complexity

| Scenario | First Call | Subsequent Calls |
|----------|------------|------------------|
| Context at depth d | O(d) | O(1-2) |
| No context | O(MAX_DEPTH) | O(1-2) |

### Space Complexity

- No global state
- No heap allocations for caching
- Only stack frame locals modified (auto-cleanup)

### Measured Performance

| Operation | Time |
|-----------|------|
| Per-frame walk | ~200 ns |
| `isinstance()` check | ~50 ns |
| `f_locals` injection | ~100 ns |
| Cache hit (1-2 frames) | ~300-500 ns |

---

## Design Decisions

### Why Stack Walk Over Thread-Local?

| Thread-Local | Stack Walk |
|--------------|------------|
| Global state | No global state |
| Requires cleanup | Auto-cleanup when frame exits |
| Can leak on exceptions | Exception-safe |
| All code sees same value | Scoped to call tree |

### Why Frame Injection Over Global Cache?

| Global Cache | Frame Injection |
|--------------|-----------------|
| `dict[id(frame)]` | `frame.f_locals[var]` |
| Must clear on context exit | Auto-clears with frame |
| Thread safety concerns | Thread-safe by design |
| Memory leak risk | No leak possible |
| External state | Self-contained |

### Why Magic Variable Name?

The specific naming pattern `_my_context_` (with underscores) provides:

1. **Uniqueness** - unlikely to collide with user variables
2. **Discoverability** - consistent pattern across uses
3. **Convention** - follows Python's internal variable style
4. **Intentionality** - clearly not an accident

### Why Separate "Checked" Variable?

Using a single variable with sentinel value (e.g., `False` for "not found") violates type consistency. Separate variables keep types clean:

- `_my_context_` is always `MyContext | None | undefined`
- `_my_context__checked_` is always `bool | undefined`

---

## Implementation Patterns

### Pattern 1: Simple Context

```python
class Debug_Context:
    enabled: bool = True
    
    def __enter__(self): return self
    def __exit__(self, *args): return False

def find_debug_context():
    return find_stack_variable('_debug_context_', '_debug_context__checked_', Debug_Context)

# Usage
_debug_context_ = Debug_Context(enabled=True)
with _debug_context_:
    ...
```

### Pattern 2: Configuration Object

```python
class Type_Safe__Config(Type_Safe):
    skip_validation  : bool = False
    on_demand_nested : bool = False
    immutable        : bool = False
    
    def __enter__(self): return self
    def __exit__(self, *args): return False

TYPE_SAFE__CONFIG__VAR_NAME    = '_type_safe_config_'
TYPE_SAFE__CONFIG__CHECKED_VAR = '_type_safe_config__checked_'

def find_type_safe_config():
    return find_stack_variable(TYPE_SAFE__CONFIG__VAR_NAME    ,
                               TYPE_SAFE__CONFIG__CHECKED_VAR ,
                               Type_Safe__Config              )
```

### Pattern 3: Timestamp Capture (Potential Refactor)

```python
class Timestamp_Context:
    timestamp     : datetime
    capture_mode  : str = 'start'                                                # 'start', 'end', 'both'
    
    def __enter__(self): return self
    def __exit__(self, *args): return False

def find_timestamp_context():
    return find_stack_variable('_timestamp_context_'          ,
                               '_timestamp_context__checked_' ,
                               Timestamp_Context              )

# Usage in @timestamp decorator
def timestamp_decorator(func):
    def wrapper(*args, **kwargs):
        ctx = find_timestamp_context()
        if ctx:
            # Use context's timestamp instead of datetime.now()
            ...
```

### Pattern 4: Metrics Collection

```python
class Metrics_Context:
    counters : Dict[str, int]
    timings  : Dict[str, float]
    
    def __enter__(self): return self
    def __exit__(self, *args): return False
    
    def increment(self, name): ...
    def record_time(self, name, duration): ...

def find_metrics_context():
    return find_stack_variable('_metrics_context_', '_metrics_context__checked_', Metrics_Context)

# Throughout codebase
def some_operation():
    ctx = find_metrics_context()
    if ctx:
        ctx.increment('some_operation_count')
```

---

## Best Practices

### DO: Use Descriptive Variable Names

```python
# Good
_type_safe_config_ = Type_Safe__Config(...)
_debug_context_    = Debug_Context(...)
_metrics_context_  = Metrics_Context(...)

# Bad
_ctx_ = Config(...)                                                              # Too generic
config = Config(...)                                                             # Likely to collide
```

### DO: Use Context Manager Pattern

```python
# Good - clear scope
_my_context_ = My_Context()
with _my_context_:
    do_stuff()

# Bad - unclear when context ends
_my_context_ = My_Context()
do_stuff()
```

### DO: Check for None

```python
# Good
ctx = find_my_context()
if ctx and ctx.some_flag:
    ...

# Bad - will raise if no context
ctx = find_my_context()
if ctx.some_flag:                                                                # AttributeError if ctx is None
    ...
```

### DON'T: Nest Different Contexts with Same Name

```python
# Bad - inner shadows outer
_my_context_ = Context(mode='outer')
with _my_context_:
    _my_context_ = Context(mode='inner')                                         # Shadows, confusing
    with _my_context_:
        ...
```

### DON'T: Rely on Context Outside Scope

```python
# Bad - context won't be found after 'with' exits
def setup():
    _my_context_ = My_Context()
    with _my_context_:
        pass                                                                     # Context only valid here

def later():
    ctx = find_my_context()                                                      # Returns None!
```

---

## Testing Strategy

### Test 1: Basic Discovery

```python
def test__finds_context_in_stack(self):
    _my_context_ = My_Context()
    with _my_context_:
        found = find_my_context()
        assert found is _my_context_
```

### Test 2: Nested Discovery

```python
def test__finds_context_from_nested_call(self):
    def inner():
        return find_my_context()
    
    _my_context_ = My_Context()
    with _my_context_:
        found = inner()
        assert found is _my_context_
```

### Test 3: Frame Injection

```python
def test__injection_reduces_walks(self):
    walk_counts = []
    
    # Use instrumented find function that counts walks
    ...
    
    _my_context_ = My_Context()
    with _my_context_:
        level1()                                                                 # Should walk N frames
        level2()                                                                 # Should walk fewer (cache hit)
    
    assert walk_counts[1] < walk_counts[0]
```

### Test 4: Not Found Caching

```python
def test__caches_not_found(self):
    # No context set
    
    result1 = find_my_context()                                                  # Full walk
    result2 = find_my_context()                                                  # Should hit "checked" marker
    
    assert result1 is None
    assert result2 is None
    # Verify second call was faster (hit checked marker)
```

### Test 5: Scope Boundary

```python
def test__context_not_found_outside_scope(self):
    def with_context():
        _my_context_ = My_Context()
        with _my_context_:
            return find_my_context()
    
    inside  = with_context()
    outside = find_my_context()
    
    assert inside is not None
    assert outside is None
```

---

## Caveats and Limitations

### 1. MAX_DEPTH Limit

Stack walk stops at MAX_DEPTH frames. If context is deeper, it won't be found.

**Mitigation**: Set MAX_DEPTH appropriately (15-20 is usually sufficient).

### 2. Frame Reuse Edge Case

`id(frame)` can be reused after a frame is deallocated. This doesn't affect frame injection (we write to `f_locals`, not a separate cache), but worth knowing.

### 3. Generator/Async Complexity

Generator and async frames have different lifecycles. The pattern works but may need care with long-lived generators.

### 4. Debugging Complexity

Stack-based context can be harder to debug than explicit parameters. Use `trace_creation` flags if needed.

---

## Summary

Stack Variable Discovery provides:

- **Ambient context** without explicit parameter passing
- **O(1)** lookups after first walk via frame injection
- **Zero global state** - everything in stack frames
- **Automatic cleanup** when frames exit
- **Thread safety** by design
- **Composable** with context managers

Use it when you need configuration, metrics, or state to propagate through deep call stacks without polluting every function signature.
