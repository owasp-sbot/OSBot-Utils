# Stack Variable Discovery vs Python's contextvars

**Version**: v1.1.0  
**Status**: Design rationale document  
**Purpose**: Explain why Stack Variable Discovery was chosen over `contextvars` for Type_Safe performance optimization  
**Related**: `v3_65_0__stack-variable-discovery__implementation-brief.md`, `v3_65_0__type-safe-performance-optimization__usage-brief.md`  
**Repo**: https://github.com/owasp-sbot/OSBot-Utils

---

## Design Principles

The following principles guided the choice of Stack Variable Discovery over `contextvars`:

### 1. Explicit Over Implicit

Context should be explicitly created where it's used, not declared at module level and implicitly available everywhere. Code readability matters — anyone reading a function should be able to see where context comes from.

### 2. Lexical Scoping

Python developers understand lexical scope intuitively. A variable exists from its declaration until its scope ends. Context propagation should follow the same model — not introduce new scoping rules that differ between sync and async contexts.

### 3. No Global State

Global state creates hidden dependencies, makes testing harder, and enables spooky action at a distance. Even "thread-safe" or "task-isolated" global state is still global state — it exists at module level, is created at import time, and can be accessed by any code that imports it.

### 4. Automatic Resource Cleanup

Resources should clean themselves up. Requiring manual cleanup (tokens, reset calls, try/finally) is error-prone. The best cleanup is no cleanup — when scope ends, resources disappear.

### 5. Call-Tree Scoping

Context should flow downward through the call tree — to functions you call, not to unrelated code that happens to run in the same task or thread. If you set up context for an operation, only that operation and its sub-operations should see it.

### 6. Minimal Coupling

Consuming code shouldn't need to import a specific singleton to access context. The less coupling between context provider and context consumer, the better.

### 7. No Import-Time Side Effects

Module imports should not create stateful objects. Importing a module should be safe and side-effect free. State should be created explicitly when needed, not as a side effect of the import system loading source code.

---

## Executive Summary

Python 3.7+ provides `contextvars` — a stdlib module designed for propagating context through async code. It's the "obvious" solution for ambient context. However, for the Type_Safe performance optimization problem, **Stack Variable Discovery (SVD)** was chosen instead.

This document explains the technical differences and why SVD is the better fit for synchronous, library-internal context propagation where zero global state is a design goal.

---

## The Problem Being Solved

Type_Safe's `__init__` method needs to detect whether it's being called inside a "fast mode" scope:

```python
_type_safe_config_ = Type_Safe__Config(skip_validation=True)
with _type_safe_config_:
    index = MGraph__Index()  # Creates ~20 nested Type_Safe objects
                             # ALL of them need to see the config
```

**Constraints:**

1. Cannot modify Type_Safe constructor signatures (hundreds of subclasses)
2. Must propagate automatically to arbitrarily nested object creation
3. Must self-clean when scope exits
4. Should introduce no module-level coupling
5. Must be backward compatible (existing code unchanged)

---

## How contextvars Works

```python
from contextvars import ContextVar

# Module-level declaration (required)
_config_var: ContextVar[Optional[Type_Safe__Config]] = ContextVar('type_safe_config', default=None)

# Setting context
def fast_mode():
    token = _config_var.set(Type_Safe__Config(skip_validation=True))
    try:
        yield
    finally:
        _config_var.reset(token)

# Reading context (anywhere in code)
def some_init():
    config = _config_var.get()
    if config and config.skip_validation:
        ...
```

**Key characteristics:**

| Property | contextvars |
|----------|-------------|
| Declaration | Module-level `ContextVar` singleton |
| Scope | Per-task (copies on `asyncio.create_task`) |
| Cleanup | Manual via `token.reset()` |
| Propagation | Automatic to async tasks |
| State location | Thread-local + task-local storage |

---

## How Stack Variable Discovery Works

```python
# No module-level declaration needed

# Setting context
_type_safe_config_ = Type_Safe__Config(skip_validation=True)
with _type_safe_config_:
    do_stuff()  # Context available to all callees

# Reading context (anywhere in call stack)
def some_init():
    config = find_type_safe_config()  # Walks stack frames
    if config and config.skip_validation:
        ...
```

**Key characteristics:**

| Property | Stack Variable Discovery |
|----------|--------------------------|
| Declaration | None (searches for magic variable name) |
| Scope | Call-tree only (literal stack frames) |
| Cleanup | Automatic (frame exit = gone) |
| Propagation | Automatic to callees, NOT to spawned tasks |
| State location | `frame.f_locals` (the stack itself) |

---

## Critical Issues with contextvars

### Issue 1: Module-Level Singleton Coupling

Every consumer must import the exact same `ContextVar` instance:

```python
# osbot_utils/config.py
from contextvars import ContextVar

# Module-level singleton - THIS is the coupling point
type_safe_config_var: ContextVar = ContextVar('type_safe_config', default=None)
```

```python
# osbot_utils/base_classes/Type_Safe.py
from osbot_utils.config import type_safe_config_var  # MUST import this exact object

class Type_Safe:
    def __init__(self, **kwargs):
        config = type_safe_config_var.get()  # Read from the imported singleton
        ...
```

```python
# User code - ALSO must import it
from osbot_utils.config import type_safe_config_var

token = type_safe_config_var.set(Type_Safe__Config(skip_validation=True))
try:
    index = MGraph__Index()
finally:
    type_safe_config_var.reset(token)  # Manual cleanup required
```

**With SVD, no imports are needed:**

```python
# User code - no imports from osbot_utils.config
_type_safe_config_ = Type_Safe__Config(skip_validation=True)
with _type_safe_config_:
    index = MGraph__Index()
# Automatic cleanup when scope exits
```

### Issue 2: Import-Time State Creation

The `ContextVar` is created when the module is first imported:

```python
# osbot_utils/config.py
from contextvars import ContextVar

# This line EXECUTES at import time
type_safe_config_var = ContextVar('type_safe_config', default=None)
print("I run when anyone imports this module")  # Side effect!
```

```python
# Somewhere else
import osbot_utils.config  # <- ContextVar is created NOW, at import time
```

The singleton exists the moment the module is imported and lives for the entire process lifetime. This violates the principle that imports should be side-effect free.

**With SVD, state is created exactly when you write the assignment:**

```python
def my_operation():
    _type_safe_config_ = Type_Safe__Config(...)  # Created HERE, not at import
    with _type_safe_config_:
        ...
    # Destroyed when scope exits
```

### Issue 3: Global Mutation by Any Importer

Any code that imports the `ContextVar` can mutate it:

```python
# Some random module, maybe a third-party dependency
from osbot_utils.config import type_safe_config_var

# Oops, someone changed it for the entire current task
type_safe_config_var.set(Type_Safe__Config(skip_validation=True))

# No "with" block, no cleanup, this persists for the rest of the task...
```

There's no protection. The variable is globally accessible to anyone who imports it.

**With SVD, only code in your call stack can see the context:**

```python
_type_safe_config_ = Type_Safe__Config(skip_validation=True)
with _type_safe_config_:
    foo()  # Can find it (you called it)
    
bar()  # Cannot find it (outside the with block)

# Some other module running in a different call tree? Cannot see it at all.
```

### Issue 4: Confusing Sync vs Async Isolation

`contextvars` behaves differently depending on whether you cross an async boundary:

**Across async task boundary — isolated (copy-on-write):**

```python
config_var.set(Config(mode='parent'))

async def child_task():
    print(config_var.get())              # Sees 'parent' (inherited copy)
    config_var.set(Config(mode='child'))
    print(config_var.get())              # Sees 'child'

async def main():
    await asyncio.create_task(child_task())
    print(config_var.get())              # Still 'parent' — child had its own copy

asyncio.run(main())
```

**Within same task (sync calls) — NOT isolated:**

```python
config_var.set(Config(mode='parent'))

def some_function():
    config_var.set(Config(mode='oops'))  # Mutates the SAME context
    # Forgot to reset...

some_function()
print(config_var.get())  # 'oops' — parent value is GONE!
```

This creates a confusing mental model:

| Scenario | Isolated? | Parent value preserved? |
|----------|-----------|------------------------|
| Parent → spawned async task | ✓ | ✓ Copy-on-write |
| Parent → sync function call | ✗ | ✗ Must use tokens |
| Sibling async tasks | ✓ | ✓ Each has own copy |

You need the token dance for sync calls:

```python
def some_function():
    token = config_var.set(Config(mode='temporary'))
    try:
        do_stuff()
    finally:
        config_var.reset(token)  # Restore previous value — easy to forget!
```

**With SVD, the model is consistent and intuitive:**

```python
_config_ = Config(mode='parent')
with _config_:
    
    def inner():
        _config_ = Config(mode='child')  # Shadows parent in this scope
        with _config_:
            deep()  # Sees 'child'
        # 'child' scope ends here
    
    inner()
    foo()  # Sees 'parent' — inner's shadow is gone, no token needed
```

Normal Python scoping rules. No tokens, no copies, no async special cases. The newest variable in the call stack wins, and it disappears when that frame exits.

### Issue 5: No Natural "with" Block Support

`contextvars` doesn't provide a context manager. You have to build one:

```python
@contextmanager  
def fast_mode():
    token = type_safe_config_var.set(Type_Safe__Config(skip_validation=True))
    try:
        yield
    finally:
        type_safe_config_var.reset(token)
```

**With SVD, the "with" block is natural Python:**

```python
_type_safe_config_ = Type_Safe__Config(skip_validation=True)
with _type_safe_config_:  # Just a regular context manager
    ...
```

The context object itself defines `__enter__` and `__exit__`. No wrapper needed.

---

## Direct Comparison

### Visibility and Access Model

| Aspect | contextvars | SVD |
|--------|-------------|-----|
| Declaration | Module-level singleton | None (name convention) |
| Created when | Import time | When you write the assignment |
| Consumer must import | Yes, the exact ContextVar | No |
| Who can access | Anyone who imports it | Only your callees (call stack) |
| Who can mutate | Anyone who imports it | Only code that has the variable in scope |
| Visibility direction | Global (horizontal) | Downward only (vertical) |
| When destroyed | Never (process lifetime) | When variable goes out of scope |

### Scope and Cleanup Model

| Aspect | contextvars | SVD |
|--------|-------------|-----|
| Scope control | Manual (token/reset) | Automatic (variable scope) |
| "with" block | You build it yourself | Natural Python scoping |
| Sync call isolation | ✗ Must use tokens | ✓ Automatic |
| Async task isolation | ✓ Copy-on-write | N/A (not designed for async) |
| Cleanup on exception | Must be in finally block | Automatic (frame exits) |
| Risk of forgetting cleanup | High (token.reset) | None |

---

## The Type_Safe-Specific Argument

### The Cascade Problem

Creating `MGraph__Index` triggers a cascade:

```
MGraph__Index.__init__
  ├─ Index__Nodes__By_Id.__init__
  │    └─ Schema__Index__Data.__init__
  │         ├─ Type_Safe__Dict.__init__
  │         └─ Type_Safe__Dict.__init__
  ├─ Index__Nodes__By_Type.__init__
  │    └─ ...
  └─ ... (20+ nested Type_Safe objects)
```

Each `__init__` independently needs to check: "Am I in fast mode?"

**With contextvars:**
```python
class Type_Safe:
    def __init__(self, **kwargs):
        from osbot_utils.config import type_safe_config_var  # Import coupling
        config = type_safe_config_var.get()                   # Read from global
        ...
```

Every Type_Safe subclass now implicitly depends on that import. The coupling is hidden but real.

**With Stack Variable Discovery:**
```python
class Type_Safe:
    def __init__(self, **kwargs):
        config = find_type_safe_config()  # No import, just searches stack
        ...
```

The `find_type_safe_config()` function is self-contained. It doesn't reference any module-level state — it literally walks stack frames looking for a variable named `_type_safe_config_`.

### Frame Injection Bonus

SVD's frame injection provides a unique optimization for the cascade:

```
MGraph__Index.__init__         # Walks 3 frames, finds config, injects into all 3
  └─ Index__Nodes__By_Id.__init__    # Walks 1 frame, finds injected reference!
       └─ Schema__Index__Data.__init__   # Walks 1 frame, finds injected reference!
            └─ Type_Safe__Dict.__init__      # Walks 1 frame, finds injected reference!
```

After the first discovery, every nested `__init__` finds the config in its immediate caller's frame. The injection acts as a "breadcrumb trail" through the call stack.

`contextvars` doesn't have this — but its O(1) lookup is already fast, so this is more of a "nice to have" than a deciding factor.

---

## Decision Matrix

| Criterion | contextvars | SVD | Winner for Type_Safe |
|-----------|-------------|-----|----------------------|
| No global state | ✗ (module-level ContextVar) | ✓ | **SVD** |
| No import-time side effects | ✗ (created at import) | ✓ | **SVD** |
| Protected from external mutation | ✗ (anyone can .set()) | ✓ | **SVD** |
| Consistent isolation model | ✗ (sync ≠ async) | ✓ | **SVD** |
| Natural "with" block | ✗ (must wrap) | ✓ | **SVD** |
| Auto-cleanup | ✗ (token-based) | ✓ | **SVD** |
| Zero coupling | ✗ (import required) | ✓ | **SVD** |
| Call-tree scoping | ✗ (task-scoped) | ✓ | **SVD** |
| Async propagation | ✓ | ✗ | N/A (not needed) |
| Stdlib/supported | ✓ | ✗ (custom) | contextvars |
| Lookup performance | O(1) always | O(1) after first | Tie |

**For Type_Safe optimization specifically:** SVD wins on the criteria that matter (no global state, call-tree scoping, auto-cleanup, no coupling) and ties or accepts minor tradeoffs on criteria that don't apply (async support not needed).

---

## When to Use Each

### Use contextvars when:

- Building async-heavy applications
- Need context to propagate to spawned tasks
- Building public APIs where stdlib patterns are expected
- Working with frameworks that integrate with contextvars (e.g., Starlette, FastAPI)
- Need context to survive across `await` boundaries
- Willing to accept the global singleton and token management

### Use Stack Variable Discovery when:

- Zero global state is a design requirement
- Import-time side effects are unacceptable
- Context should be strictly call-tree scoped (not task-scoped)
- Working in sync-heavy library internals you control
- Want automatic cleanup without token management
- Need protection from external code mutating your context
- Building framework internals where you control the call topology
- Need the context to NOT propagate to background tasks
- Want natural Python scoping semantics

---

## Addressing Common Objections

### "But contextvars is in the stdlib"

True. It's well-tested, maintained, and documented. SVD is a custom pattern.

**Counter:** The pattern is simple (~30 lines), well-understood (stack inspection is a known technique), and the tradeoffs are explicit. For a library that prioritizes "no global state", the custom solution is justified.

### "contextvars doesn't really copy your objects"

Correct. The context mapping is copied, not the values. Your complex `Type_Safe__Config` object is passed by reference in both approaches.

**This isn't the concern.** The concern is:
1. Module-level `ContextVar` declaration (coupling)
2. Task-scoped vs call-tree-scoped semantics
3. Explicit vs automatic cleanup
4. Global mutability by any importer

### "Frame inspection is hacky"

It uses `inspect.currentframe()` and `frame.f_locals`, which are documented CPython features. They're used by debuggers, profilers, and even the stdlib's `warnings` module.

**Acknowledged risk:** These are CPython implementation details. Alternative Python implementations (PyPy, etc.) may behave differently. For OSBot-Utils' use case (CPython-focused), this is acceptable.

### "What about performance?"

Measured overhead:
- SVD first lookup: ~1-3 µs (depth-dependent)
- SVD subsequent lookups: ~300-500 ns
- contextvars lookup: ~50-100 ns

**In context:** Type_Safe validation overhead is ~10,000-15,000 ns per object. The lookup mechanism's overhead is noise compared to the savings from skipping validation.

---

## Conclusion

`contextvars` is the right choice for most Python context propagation, especially in async codebases. It's stdlib, well-supported, and designed for exactly this purpose.

**Stack Variable Discovery** is the right choice for OSBot-Utils' Type_Safe optimization because:

1. **No global state** — no module-level `ContextVar` singleton
2. **No import-time side effects** — state is created when you write the assignment, not when modules load
3. **Protected from external mutation** — only code in your call stack can see or affect the context
4. **Consistent isolation model** — same behavior for sync and async, no special cases
5. **Natural "with" block support** — standard Python context managers, no wrapper needed
6. **Automatic cleanup** — no token management, exception-safe by design
7. **Zero coupling** — consumers search for a name, not an imported object
8. **Call-tree scoping** — context flows downward to callees only

The pattern trades stdlib support and async compatibility for stronger isolation guarantees, cleaner architecture, and alignment with Python's natural scoping model. For library internals where you control the call topology, that's the right tradeoff.

---

## Related Work: Existing Python Packages

A survey of PyPI and GitHub reveals several packages attempting to solve similar problems. None implement the exact combination of features that Stack Variable Discovery provides.

### Comparison Table: Dynamic Scoping Packages

| Package | Stars | Last Update | Approach | Production Ready? |
|---------|-------|-------------|----------|-------------------|
| **`stackful`** | 9 | 2011 | Converts globals to stack-scoped via Proxy objects | Unmaintained |
| **`dynamicscope`** | — | 2022 | Reads/writes caller's `f_locals` directly | Author says "no" |
| **`dynascope`** | 0 | Recent | Thread-safe dynamic scope with dataclass support | Incomplete docs |
| **`Dysco`** | — | — | Configurable dynamic scope | Missing docs |
| **`VarScope`** | — | — | `with` blocks only | Limited |
| **`block-scopes`** | — | — | `with` blocks only | Limited |
| **`scoping`** | — | Active | Block scoping for garbage collection | Different goal |

### Feature Comparison

| Feature | SVD | `stackful` | `dynamicscope` | `dynascope` | `contextvars` |
|---------|-----|------------|----------------|-------------|---------------|
| No global state | ✓ | ✗ (Proxy) | ✓ | ✗ | ✗ |
| No module-level declaration | ✓ | ✗ | ✓ | ✗ | ✗ |
| Frame injection caching | ✓ | ✗ | ✗ | ✗ | N/A |
| O(1) repeated lookups | ✓ | ✓ | ✗ | ✓ | ✓ |
| Type checking on discovery | ✓ | ✗ | ✗ | ✗ | ✗ |
| "Not found" caching | ✓ | ✗ | ✗ | ✗ | N/A |
| Natural `with` block | ✓ | ✓ | ✗ | ✓ | ✗ (manual) |
| Thread-safe | ✓ | ✓ | ? | ✓ | ✓ |
| Async-safe | ✗ | ✗ | ✗ | ✓ | ✓ |
| Production recommended | ✓ | ✗ | ✗ | ? | ✓ |

### Package Details

#### `stackful` (erikrose/stackful)

The closest conceptual match. Transforms existing global variables into stack-scoped variables using Proxy objects that intercept all operations.

```python
from stackful import stackful

with stackful('some_global', 8):
    foo()  # sees some_global as 8
```

**Key differences from SVD:**
- Requires an existing global variable to transform
- Uses Proxy objects (operator interception) rather than frame inspection
- No caching mechanism
- Unmaintained since 2011

#### `dynamicscope` (mentalisttraceur)

Implements true dynamic scoping by directly reading and writing caller's `f_locals`.

```python
from dynamicscope import DYNAMIC_SCOPE

def inner():
    print(DYNAMIC_SCOPE.x)  # searches call stack for 'x'

def outer():
    x = 42
    inner()  # prints 42
```

**Key differences from SVD:**
- Accesses/modifies caller's actual local variables (dangerous)
- No caching — full stack walk every time
- Author explicitly warns against production use
- Can delete variables in caller's scope (!)

#### `dynascope` (mikaelho/dynascope)

A more recent attempt with dataclass support and async safety.

```python
from dynascope import scope

scope.x = 42

def inner():
    print(scope.x)
```

**Key differences from SVD:**
- Uses `contextvars` under the hood (inherits its issues)
- Requires module-level scope object
- More feature-rich (dataclasses, async) but more complex

#### Standard Library: `contextvars`

The official solution for async context propagation. See main document sections above for detailed comparison.

### Why SVD is Unique

No existing package combines all of:

1. **Magic variable name discovery** — no global declaration, no imports needed by consumers
2. **Frame injection caching** — O(1) repeated lookups via breadcrumb trail
3. **"Not found" caching** — prevents repeated full walks when no context exists
4. **Type checking** — `isinstance()` verification during discovery
5. **Zero global state** — everything lives in stack frames
6. **Production-ready design** — not a "party trick" or educational tool

The frame injection caching is particularly novel. When context is found, SVD injects references into all traversed frames, creating a shortcut for subsequent lookups from the same call subtree. No other package implements this optimization.

### Conclusion on Related Work

The dynamic scoping problem space in Python is underserved:

- **`contextvars`** solves async context but requires global singletons
- **`stackful`** is unmaintained and uses a different mechanism
- **`dynamicscope`** is explicitly not for production
- **`dynascope`** builds on `contextvars`, inheriting its limitations

Stack Variable Discovery fills a gap: a production-ready, zero-global-state, cached stack-walking approach for synchronous context propagation. The pattern may warrant publication as a standalone package.

---

## References

- [PEP 567 — Context Variables](https://peps.python.org/pep-0567/)
- [contextvars documentation](https://docs.python.org/3/library/contextvars.html)
- [erikrose/stackful](https://github.com/erikrose/stackful) — Dynamically-scoped variables for Python
- [mentalisttraceur/dynamicscope](https://pypi.org/project/dynamicscope/) — Emulate dynamic scope in Python
- [mikaelho/dynascope](https://github.com/mikaelho/dynascope) — Dynamic scope for Python
- `v3_65_0__stack-variable-discovery__implementation-brief.md`
- `v3_65_0__type-safe-performance-optimization__usage-brief.md`
