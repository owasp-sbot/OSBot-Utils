# Stack Variable Discovery vs Python's contextvars

**Version**: v3.66.0     
**Status**: Design rationale document  
**Purpose**: Explain why Stack Variable Discovery was chosen over `contextvars` for Type_Safe performance optimization  
**Related**: `v3_65_0__stack-variable-discovery__implementation-brief.md`, `v3_65_0__type-safe-performance-optimization__usage-brief.md`  
**Repo**: https://github.com/owasp-sbot/OSBot-Utils

---

## Design Principles

The following principles guided the choice of Stack Variable Discovery over `contextvars`:

### 1. Explicit Over Implicit

Context should be explicitly created where it's used, not declared at module level and implicitly available everywhere. Code readability matters — anyone reading a function should be able to see where context comes from.

### 2. Lexical Scoping

Python developers understand lexical scope intuitively. A variable exists from its declaration until its scope ends. Context propagation should follow the same model — not introduce new scoping rules that differ between sync and async contexts.

### 3. No Global State

Global state creates hidden dependencies, makes testing harder, and enables spooky action at a distance. Even "thread-safe" or "task-isolated" global state is still global state — it exists at module level, is created at import time, and can be accessed by any code that imports it.

### 4. Automatic Resource Cleanup

Resources should clean themselves up. Requiring manual cleanup (tokens, reset calls, try/finally) is error-prone. The best cleanup is no cleanup — when scope ends, resources disappear.

### 5. Call-Tree Scoping

Context should flow downward through the call tree — to functions you call, not to unrelated code that happens to run in the same task or thread. If you set up context for an operation, only that operation and its sub-operations should see it.

### 6. Minimal Coupling

Consuming code shouldn't need to import a specific singleton to access context. The less coupling between context provider and context consumer, the better.

### 7. No Import-Time Side Effects

Module imports should not create stateful objects. Importing a module should be safe and side-effect free. State should be created explicitly when needed, not as a side effect of the import system loading source code.

---

## Executive Summary

Python 3.7+ provides `contextvars` — a stdlib module designed for propagating context through async code. It's the "obvious" solution for ambient context. However, for OSBot-Utils' ambient context needs, **Stack Variable Discovery (SVD)** was chosen instead.

This document explains the technical differences and why SVD is the better fit for synchronous, library-internal context propagation where zero global state is a design goal.

**Note**: While Type_Safe performance optimization was the catalyst for formalizing SVD with frame injection caching, the pattern originated from the `@timestamp` decorator system and has broad applicability across many use cases.

---

## The Problem Being Solved

Type_Safe's `__init__` method needs to detect whether it's being called inside a "fast mode" scope:

```python
_type_safe_config_ = Type_Safe__Config(skip_validation=True)
with _type_safe_config_:
    index = MGraph__Index()  # Creates ~20 nested Type_Safe objects
                             # ALL of them need to see the config
```

**Constraints:**

1. Cannot modify Type_Safe constructor signatures (hundreds of subclasses)
2. Must propagate automatically to arbitrarily nested object creation
3. Must self-clean when scope exits
4. Should introduce no module-level coupling
5. Must be backward compatible (existing code unchanged)

---

## Origin: The @timestamp Decorator

Stack Variable Discovery originated from OSBot-Utils' `@timestamp` profiling system. The `@timestamp` decorator needs to find a `Timestamp_Collector` without requiring it to be passed through every function signature:

```python
from osbot_utils.helpers.timestamp_capture.decorators.timestamp import timestamp
from osbot_utils.helpers.timestamp_capture.Timestamp_Collector import Timestamp_Collector

class MyProcessor:
    
    @timestamp
    def process(self, data):
        return self._transform(self._parse(data))
    
    @timestamp
    def _parse(self, data):
        ...
    
    @timestamp
    def _transform(self, data):
        ...

# The variable MUST be named exactly '_timestamp_collector_'
_timestamp_collector_ = Timestamp_Collector(name="profiling_session")

with _timestamp_collector_:
    processor = MyProcessor()
    result = processor.process(data)

_timestamp_collector_.print_report()
```

The `@timestamp` decorator walks the call stack looking for a local variable named `_timestamp_collector_`. If found, it records timing data. If not found, the method executes normally with ~3μs overhead.

**This is the SVD pattern in action** — but the current `@timestamp` implementation lacks the frame injection caching optimization. Each decorated method does a full stack walk. With frame injection caching, subsequent lookups would be O(1), significantly improving profiling overhead in deep call stacks.

---

## Broader Use Cases

Type_Safe optimization was the catalyst for formalizing SVD with frame injection caching, but the pattern has broad applicability.

### Use Case 1: Profiling and Instrumentation (@timestamp)

As described above, the `@timestamp` system uses stack walking to find collectors. Any instrumentation that needs to aggregate data across a call tree benefits from SVD:

```python
_metrics_context_ = Metrics_Collector()
with _metrics_context_:
    run_complex_workflow()  # All @instrumented methods find the collector
```

### Use Case 2: Adaptive Application Behavior (MVP Pattern)

A "Minimum Viable Product/Application" pattern where application behavior adapts based on runtime constraints:

```python
class Application_Context:
    resource_constrained : bool = False      # Running on limited hardware
    under_attack         : bool = False      # DDoS or abuse detected
    budget_exceeded      : bool = False      # API quota nearly exhausted
    off_peak_hours       : bool = False      # Time-based feature availability
    geographic_region    : str  = 'default'  # Caller location affects features
    
    def __enter__(self): return self
    def __exit__(self, *args): return False

def find_app_context():
    return find_stack_variable('_app_context_', '_app_context__checked_', Application_Context)

# Feature implementations check context
class ImageProcessor:
    
    def process(self, image):
        ctx = find_app_context()
        
        if ctx and ctx.resource_constrained:
            return self._process_fast(image)      # Reduced quality, faster
        elif ctx and ctx.under_attack:
            return self._process_minimal(image)   # Bare minimum processing
        else:
            return self._process_full(image)      # Full quality

# Usage: Degrade gracefully under load
_app_context_ = Application_Context(resource_constrained=True, under_attack=True)
with _app_context_:
    # All code in this call tree sees the constraints
    # and automatically adapts behavior
    handle_user_request(request)
```

This pattern enables:
- **Resource-aware processing**: Reduce quality/features when CPU/memory is constrained
- **Attack mitigation**: Disable expensive features during DDoS
- **Budget management**: Throttle API calls when approaching quota limits
- **Time-based features**: Premium features only during business hours
- **Geographic compliance**: Different feature sets per region

### Use Case 3: Debug and Trace Contexts

Enable detailed logging/tracing for specific operations without global flags:

```python
class Debug_Context:
    trace_sql      : bool = False
    trace_http     : bool = False
    trace_cache    : bool = False
    log_level      : str  = 'INFO'
    correlation_id : str  = None
    
    def __enter__(self): return self
    def __exit__(self, *args): return False

# Deep in database layer
def execute_query(sql):
    ctx = find_debug_context()
    if ctx and ctx.trace_sql:
        logger.debug(f"[{ctx.correlation_id}] SQL: {sql}")
    ...

# Enable tracing for one specific request
_debug_context_ = Debug_Context(trace_sql=True, correlation_id="req-12345")
with _debug_context_:
    process_complex_request()  # All SQL in this call tree is traced
```

### Use Case 4: Transaction and Unit of Work Contexts

Database transactions, API sessions, or other resources that should be implicitly available:

```python
class Transaction_Context:
    connection  : Connection
    read_only   : bool = False
    isolation   : str  = 'READ_COMMITTED'
    
    def __enter__(self): return self
    def __exit__(self, *args): 
        self.connection.commit()
        return False

# Repository methods find the transaction automatically
class UserRepository:
    
    def find_by_id(self, user_id):
        ctx = find_transaction_context()
        conn = ctx.connection if ctx else get_default_connection()
        return conn.execute("SELECT * FROM users WHERE id = ?", user_id)

# Usage
_transaction_context_ = Transaction_Context(connection=db.begin())
with _transaction_context_:
    user = user_repo.find_by_id(123)
    order = order_repo.find_by_user(user.id)
    # Both queries use the same transaction, no explicit passing
```

### Use Case 5: Test Fixtures and Mocking

Override behavior during tests without modifying production code:

```python
class Test_Context:
    mock_time      : datetime = None     # Freeze time for deterministic tests
    mock_random    : float    = None     # Deterministic "random" values
    skip_external  : bool     = False    # Skip external API calls
    capture_calls  : list     = None     # Record function calls for assertions
    
    def __enter__(self): return self
    def __exit__(self, *args): return False

# Production code checks for test context
def get_current_time():
    ctx = find_test_context()
    if ctx and ctx.mock_time:
        return ctx.mock_time
    return datetime.now()

# Tests
def test__order_expiry():
    _test_context_ = Test_Context(mock_time=datetime(2025, 1, 1, 12, 0, 0))
    with _test_context_:
        order = create_order()
        assert order.expires_at == datetime(2025, 1, 1, 13, 0, 0)  # 1 hour later
```

### Use Case 6: Security and Authorization Contexts

Propagate security context through call stacks:

```python
class Security_Context:
    user_id       : str
    roles         : List[str]
    permissions   : Set[str]
    audit_enabled : bool = True
    
    def __enter__(self): return self
    def __exit__(self, *args): return False

# Authorization checks deep in the stack
def delete_document(doc_id):
    ctx = find_security_context()
    if not ctx or 'documents.delete' not in ctx.permissions:
        raise PermissionDenied("Cannot delete documents")
    
    if ctx.audit_enabled:
        audit_log(f"User {ctx.user_id} deleted document {doc_id}")
    
    # Proceed with deletion
    ...

# Request handler establishes context
_security_context_ = Security_Context(
    user_id='user-123',
    roles=['editor'],
    permissions={'documents.read', 'documents.write', 'documents.delete'}
)
with _security_context_:
    handle_api_request(request)  # All authorization checks find the context
```

### Use Case 7: Feature Flags and A/B Testing

Runtime feature flag evaluation with call-tree scoping:

```python
class Feature_Context:
    enabled_features : Set[str]
    experiment_group : str = 'control'
    user_segment     : str = 'default'
    
    def __enter__(self): return self
    def __exit__(self, *args): return False

# Feature checks
def render_checkout():
    ctx = find_feature_context()
    
    if ctx and 'new_checkout_flow' in ctx.enabled_features:
        return render_new_checkout()
    else:
        return render_classic_checkout()

# Different users get different features
_feature_context_ = Feature_Context(
    enabled_features={'new_checkout_flow', 'dark_mode'},
    experiment_group='treatment_b'
)
with _feature_context_:
    render_page_for_user()
```

---

## How contextvars Works

```python
from contextvars import ContextVar

# Module-level declaration (required)
_config_var: ContextVar[Optional[Type_Safe__Config]] = ContextVar('type_safe_config', default=None)

# Setting context
def fast_mode():
    token = _config_var.set(Type_Safe__Config(skip_validation=True))
    try:
        yield
    finally:
        _config_var.reset(token)

# Reading context (anywhere in code)
def some_init():
    config = _config_var.get()
    if config and config.skip_validation:
        ...
```

**Key characteristics:**

| Property | contextvars |
|----------|-------------|
| Declaration | Module-level `ContextVar` singleton |
| Scope | Per-task (copies on `asyncio.create_task`) |
| Cleanup | Manual via `token.reset()` |
| Propagation | Automatic to async tasks |
| State location | Thread-local + task-local storage |

---

## How Stack Variable Discovery Works

```python
# No module-level declaration needed

# Setting context
_type_safe_config_ = Type_Safe__Config(skip_validation=True)
with _type_safe_config_:
    do_stuff()  # Context available to all callees

# Reading context (anywhere in call stack)
def some_init():
    config = find_type_safe_config()  # Walks stack frames
    if config and config.skip_validation:
        ...
```

**Key characteristics:**

| Property | Stack Variable Discovery |
|----------|--------------------------|
| Declaration | None (searches for magic variable name) |
| Scope | Call-tree only (literal stack frames) |
| Cleanup | Automatic (frame exit = gone) |
| Propagation | Automatic to callees, NOT to spawned tasks |
| State location | `frame.f_locals` (the stack itself) |

---

## Critical Issues with contextvars

### Issue 1: Module-Level Singleton Coupling

Every consumer must import the exact same `ContextVar` instance:

```python
# osbot_utils/config.py
from contextvars import ContextVar

# Module-level singleton - THIS is the coupling point
type_safe_config_var: ContextVar = ContextVar('type_safe_config', default=None)
```

```python
# osbot_utils/base_classes/Type_Safe.py
from osbot_utils.config import type_safe_config_var  # MUST import this exact object

class Type_Safe:
    def __init__(self, **kwargs):
        config = type_safe_config_var.get()  # Read from the imported singleton
        ...
```

```python
# User code - ALSO must import it
from osbot_utils.config import type_safe_config_var

token = type_safe_config_var.set(Type_Safe__Config(skip_validation=True))
try:
    index = MGraph__Index()
finally:
    type_safe_config_var.reset(token)  # Manual cleanup required
```

**With SVD, no imports are needed:**

```python
# User code - no imports from osbot_utils.config
_type_safe_config_ = Type_Safe__Config(skip_validation=True)
with _type_safe_config_:
    index = MGraph__Index()
# Automatic cleanup when scope exits
```

### Issue 2: Import-Time State Creation

The `ContextVar` is created when the module is first imported:

```python
# osbot_utils/config.py
from contextvars import ContextVar

# This line EXECUTES at import time
type_safe_config_var = ContextVar('type_safe_config', default=None)
print("I run when anyone imports this module")  # Side effect!
```

```python
# Somewhere else
import osbot_utils.config  # <- ContextVar is created NOW, at import time
```

The singleton exists the moment the module is imported and lives for the entire process lifetime. This violates the principle that imports should be side-effect free.

**With SVD, state is created exactly when you write the assignment:**

```python
def my_operation():
    _type_safe_config_ = Type_Safe__Config(...)  # Created HERE, not at import
    with _type_safe_config_:
        ...
    # Destroyed when scope exits
```

### Issue 3: Global Mutation by Any Importer

Any code that imports the `ContextVar` can mutate it:

```python
# Some random module, maybe a third-party dependency
from osbot_utils.config import type_safe_config_var

# Oops, someone changed it for the entire current task
type_safe_config_var.set(Type_Safe__Config(skip_validation=True))

# No "with" block, no cleanup, this persists for the rest of the task...
```

There's no protection. The variable is globally accessible to anyone who imports it.

**With SVD, only code in your call stack can see the context:**

```python
_type_safe_config_ = Type_Safe__Config(skip_validation=True)
with _type_safe_config_:
    foo()  # Can find it (you called it)
    
bar()  # Cannot find it (outside the with block)

# Some other module running in a different call tree? Cannot see it at all.
```

### Issue 4: Confusing Sync vs Async Isolation

`contextvars` behaves differently depending on whether you cross an async boundary:

**Across async task boundary — isolated (copy-on-write):**

```python
config_var.set(Config(mode='parent'))

async def child_task():
    print(config_var.get())              # Sees 'parent' (inherited copy)
    config_var.set(Config(mode='child'))
    print(config_var.get())              # Sees 'child'

async def main():
    await asyncio.create_task(child_task())
    print(config_var.get())              # Still 'parent' — child had its own copy

asyncio.run(main())
```

**Within same task (sync calls) — NOT isolated:**

```python
config_var.set(Config(mode='parent'))

def some_function():
    config_var.set(Config(mode='oops'))  # Mutates the SAME context
    # Forgot to reset...

some_function()
print(config_var.get())  # 'oops' — parent value is GONE!
```

This creates a confusing mental model:

| Scenario | Isolated? | Parent value preserved? |
|----------|-----------|------------------------|
| Parent → spawned async task | ✓ | ✓ Copy-on-write |
| Parent → sync function call | ✗ | ✗ Must use tokens |
| Sibling async tasks | ✓ | ✓ Each has own copy |

You need the token dance for sync calls:

```python
def some_function():
    token = config_var.set(Config(mode='temporary'))
    try:
        do_stuff()
    finally:
        config_var.reset(token)  # Restore previous value — easy to forget!
```

**With SVD, the model is consistent and intuitive:**

```python
_config_ = Config(mode='parent')
with _config_:
    
    def inner():
        _config_ = Config(mode='child')  # Shadows parent in this scope
        with _config_:
            deep()  # Sees 'child'
        # 'child' scope ends here
    
    inner()
    foo()  # Sees 'parent' — inner's shadow is gone, no token needed
```

Normal Python scoping rules. No tokens, no copies, no async special cases. The newest variable in the call stack wins, and it disappears when that frame exits.

### Issue 5: No Natural "with" Block Support

`contextvars` doesn't provide a context manager. You have to build one:

```python
@contextmanager  
def fast_mode():
    token = type_safe_config_var.set(Type_Safe__Config(skip_validation=True))
    try:
        yield
    finally:
        type_safe_config_var.reset(token)
```

**With SVD, the "with" block is natural Python:**

```python
_type_safe_config_ = Type_Safe__Config(skip_validation=True)
with _type_safe_config_:  # Just a regular context manager
    ...
```

The context object itself defines `__enter__` and `__exit__`. No wrapper needed.

---

## Direct Comparison

### Visibility and Access Model

| Aspect | contextvars | SVD |
|--------|-------------|-----|
| Declaration | Module-level singleton | None (name convention) |
| Created when | Import time | When you write the assignment |
| Consumer must import | Yes, the exact ContextVar | No |
| Who can access | Anyone who imports it | Only your callees (call stack) |
| Who can mutate | Anyone who imports it | Only code that has the variable in scope |
| Visibility direction | Global (horizontal) | Downward only (vertical) |
| When destroyed | Never (process lifetime) | When variable goes out of scope |

### Scope and Cleanup Model

| Aspect | contextvars | SVD |
|--------|-------------|-----|
| Scope control | Manual (token/reset) | Automatic (variable scope) |
| "with" block | You build it yourself | Natural Python scoping |
| Sync call isolation | ✗ Must use tokens | ✓ Automatic |
| Async task isolation | ✓ Copy-on-write | N/A (not designed for async) |
| Cleanup on exception | Must be in finally block | Automatic (frame exits) |
| Risk of forgetting cleanup | High (token.reset) | None |

---

## The Type_Safe-Specific Argument

### The Cascade Problem

Creating `MGraph__Index` triggers a cascade:

```
MGraph__Index.__init__
  ├─ Index__Nodes__By_Id.__init__
  │    └─ Schema__Index__Data.__init__
  │         ├─ Type_Safe__Dict.__init__
  │         └─ Type_Safe__Dict.__init__
  ├─ Index__Nodes__By_Type.__init__
  │    └─ ...
  └─ ... (20+ nested Type_Safe objects)
```

Each `__init__` independently needs to check: "Am I in fast mode?"

**With contextvars:**
```python
class Type_Safe:
    def __init__(self, **kwargs):
        from osbot_utils.config import type_safe_config_var  # Import coupling
        config = type_safe_config_var.get()                   # Read from global
        ...
```

Every Type_Safe subclass now implicitly depends on that import. The coupling is hidden but real.

**With Stack Variable Discovery:**
```python
class Type_Safe:
    def __init__(self, **kwargs):
        config = find_type_safe_config()  # No import, just searches stack
        ...
```

The `find_type_safe_config()` function is self-contained. It doesn't reference any module-level state — it literally walks stack frames looking for a variable named `_type_safe_config_`.

### Frame Injection Bonus

SVD's frame injection provides a unique optimization for the cascade:

```
MGraph__Index.__init__         # Walks 3 frames, finds config, injects into all 3
  └─ Index__Nodes__By_Id.__init__    # Walks 1 frame, finds injected reference!
       └─ Schema__Index__Data.__init__   # Walks 1 frame, finds injected reference!
            └─ Type_Safe__Dict.__init__      # Walks 1 frame, finds injected reference!
```

After the first discovery, every nested `__init__` finds the config in its immediate caller's frame. The injection acts as a "breadcrumb trail" through the call stack.

`contextvars` doesn't have this — but its O(1) lookup is already fast, so this is more of a "nice to have" than a deciding factor.

---

## Decision Matrix

| Criterion | contextvars | SVD | Winner for Type_Safe |
|-----------|-------------|-----|----------------------|
| No global state | ✗ (module-level ContextVar) | ✓ | **SVD** |
| No import-time side effects | ✗ (created at import) | ✓ | **SVD** |
| Protected from external mutation | ✗ (anyone can .set()) | ✓ | **SVD** |
| Consistent isolation model | ✗ (sync ≠ async) | ✓ | **SVD** |
| Natural "with" block | ✗ (must wrap) | ✓ | **SVD** |
| Auto-cleanup | ✗ (token-based) | ✓ | **SVD** |
| Zero coupling | ✗ (import required) | ✓ | **SVD** |
| Call-tree scoping | ✗ (task-scoped) | ✓ | **SVD** |
| Async propagation | ✓ | ✗ | N/A (not needed) |
| Stdlib/supported | ✓ | ✗ (custom) | contextvars |
| Lookup performance | O(1) always | O(1) after first | Tie |

**For Type_Safe optimization specifically:** SVD wins on the criteria that matter (no global state, call-tree scoping, auto-cleanup, no coupling) and ties or accepts minor tradeoffs on criteria that don't apply (async support not needed).

---

## When to Use Each

### Use contextvars when:

- Building async-heavy applications
- Need context to propagate to spawned tasks
- Building public APIs where stdlib patterns are expected
- Working with frameworks that integrate with contextvars (e.g., Starlette, FastAPI)
- Need context to survive across `await` boundaries
- Willing to accept the global singleton and token management

### Use Stack Variable Discovery when:

- **Zero global state** is a design requirement
- **Import-time side effects** are unacceptable
- Context should be **strictly call-tree scoped** (not task-scoped)
- Working in **sync-heavy library internals** you control
- Want **automatic cleanup** without token management
- Need **protection from external code** mutating your context
- Building **framework internals** where you control the call topology
- Need the context to **NOT propagate** to background tasks
- Want **natural Python scoping** semantics

### Specific SVD Use Cases

| Scenario | Why SVD? |
|----------|----------|
| `@timestamp` profiling | Decorators can't have signatures modified; collector must be discoverable |
| Type_Safe fast mode | Hundreds of subclasses; can't add `config` param to every `__init__` |
| Adaptive MVP | Constraints should apply to entire call tree, not leak to other requests |
| Debug tracing | Enable tracing for specific operation, auto-disable when done |
| Transaction scope | Connection should be available to all repository calls in scope |
| Test mocking | Override behavior during test, guarantee cleanup |
| Security context | Authorization must be scoped, not globally mutable |
| Feature flags | A/B test assignment must be consistent within a request |

---

## Addressing Common Objections

### "But contextvars is in the stdlib"

True. It's well-tested, maintained, and documented. SVD is a custom pattern.

**Counter:** The pattern is simple (~30 lines), well-understood (stack inspection is a known technique), and the tradeoffs are explicit. For a library that prioritizes "no global state", the custom solution is justified.

### "contextvars doesn't really copy your objects"

Correct. The context mapping is copied, not the values. Your complex `Type_Safe__Config` object is passed by reference in both approaches.

**This isn't the concern.** The concern is:
1. Module-level `ContextVar` declaration (coupling)
2. Task-scoped vs call-tree-scoped semantics
3. Explicit vs automatic cleanup
4. Global mutability by any importer

### "Frame inspection is hacky"

It uses `inspect.currentframe()` and `frame.f_locals`, which are documented CPython features. They're used by debuggers, profilers, and even the stdlib's `warnings` module.

**Acknowledged risk:** These are CPython implementation details. Alternative Python implementations (PyPy, etc.) may behave differently. For OSBot-Utils' use case (CPython-focused), this is acceptable.

### "What about performance?"

Measured overhead:
- SVD first lookup: ~1-3 µs (depth-dependent)
- SVD subsequent lookups: ~300-500 ns
- contextvars lookup: ~50-100 ns

**In context:** Type_Safe validation overhead is ~10,000-15,000 ns per object. The lookup mechanism's overhead is noise compared to the savings from skipping validation.

---

## Conclusion

`contextvars` is the right choice for most Python context propagation, especially in async codebases. It's stdlib, well-supported, and designed for exactly this purpose.

**Stack Variable Discovery** is the right choice for OSBot-Utils and similar libraries because:

1. **No global state** — no module-level `ContextVar` singleton
2. **No import-time side effects** — state is created when you write the assignment, not when modules load
3. **Protected from external mutation** — only code in your call stack can see or affect the context
4. **Consistent isolation model** — same behavior for sync and async, no special cases
5. **Natural "with" block support** — standard Python context managers, no wrapper needed
6. **Automatic cleanup** — no token management, exception-safe by design
7. **Zero coupling** — consumers search for a name, not an imported object
8. **Call-tree scoping** — context flows downward to callees only

### Beyond Type_Safe

While Type_Safe optimization was the catalyst for formalizing SVD with frame injection caching, the pattern originated from `@timestamp` and has broad applicability:

| Use Case | Context Object | Benefit |
|----------|----------------|---------|
| **Profiling** (`@timestamp`) | `Timestamp_Collector` | Instrument methods without signature changes |
| **Adaptive behavior** (MVP) | `Application_Context` | Degrade gracefully under constraints |
| **Debug/trace** | `Debug_Context` | Enable tracing for specific operations |
| **Transactions** | `Transaction_Context` | Implicit connection propagation |
| **Testing** | `Test_Context` | Mock time, randomness, external calls |
| **Security** | `Security_Context` | Authorization without explicit passing |
| **Feature flags** | `Feature_Context` | A/B testing with call-tree scoping |
| **Configuration** | `Type_Safe__Config` | Skip validation in trusted contexts |

### The Frame Injection Optimization

The key innovation in SVD is frame injection caching. The existing `@timestamp` implementation does a full stack walk on every decorated method call. With frame injection:

- First lookup: O(d) where d = stack depth to context
- Subsequent lookups: O(1-2) — injected reference found in caller's frame

For `@timestamp` profiling deep call stacks, this reduces overhead significantly. The same optimization applies to all SVD use cases.

The pattern trades stdlib support and async compatibility for stronger isolation guarantees, cleaner architecture, and alignment with Python's natural scoping model. For library internals where you control the call topology, that's the right tradeoff.

---

## Related Work: Existing Python Packages

A survey of PyPI and GitHub reveals several packages attempting to solve similar problems. None implement the exact combination of features that Stack Variable Discovery provides.

### Comparison Table: Dynamic Scoping Packages

| Package | Stars | Last Update | Approach | Production Ready? |
|---------|-------|-------------|----------|-------------------|
| **`stackful`** | 9 | 2011 | Converts globals to stack-scoped via Proxy objects | Unmaintained |
| **`dynamicscope`** | — | 2022 | Reads/writes caller's `f_locals` directly | Author says "no" |
| **`dynascope`** | 0 | Recent | Thread-safe dynamic scope with dataclass support | Incomplete docs |
| **`Dysco`** | — | — | Configurable dynamic scope | Missing docs |
| **`VarScope`** | — | — | `with` blocks only | Limited |
| **`block-scopes`** | — | — | `with` blocks only | Limited |
| **`scoping`** | — | Active | Block scoping for garbage collection | Different goal |

### Feature Comparison

| Feature | SVD | `stackful` | `dynamicscope` | `dynascope` | `contextvars` |
|---------|-----|------------|----------------|-------------|---------------|
| No global state | ✓ | ✗ (Proxy) | ✓ | ✗ | ✗ |
| No module-level declaration | ✓ | ✗ | ✓ | ✗ | ✗ |
| Frame injection caching | ✓ | ✗ | ✗ | ✗ | N/A |
| O(1) repeated lookups | ✓ | ✓ | ✗ | ✓ | ✓ |
| Type checking on discovery | ✓ | ✗ | ✗ | ✗ | ✗ |
| "Not found" caching | ✓ | ✗ | ✗ | ✗ | N/A |
| Natural `with` block | ✓ | ✓ | ✗ | ✓ | ✗ (manual) |
| Thread-safe | ✓ | ✓ | ? | ✓ | ✓ |
| Async-safe | ✗ | ✗ | ✗ | ✓ | ✓ |
| Production recommended | ✓ | ✗ | ✗ | ? | ✓ |

### Package Details

#### `stackful` (erikrose/stackful)

The closest conceptual match. Transforms existing global variables into stack-scoped variables using Proxy objects that intercept all operations.

```python
from stackful import stackful

with stackful('some_global', 8):
    foo()  # sees some_global as 8
```

**Key differences from SVD:**
- Requires an existing global variable to transform
- Uses Proxy objects (operator interception) rather than frame inspection
- No caching mechanism
- Unmaintained since 2011

#### `dynamicscope` (mentalisttraceur)

Implements true dynamic scoping by directly reading and writing caller's `f_locals`.

```python
from dynamicscope import DYNAMIC_SCOPE

def inner():
    print(DYNAMIC_SCOPE.x)  # searches call stack for 'x'

def outer():
    x = 42
    inner()  # prints 42
```

**Key differences from SVD:**
- Accesses/modifies caller's actual local variables (dangerous)
- No caching — full stack walk every time
- Author explicitly warns against production use
- Can delete variables in caller's scope (!)

#### `dynascope` (mikaelho/dynascope)

A more recent attempt with dataclass support and async safety.

```python
from dynascope import scope

scope.x = 42

def inner():
    print(scope.x)
```

**Key differences from SVD:**
- Uses `contextvars` under the hood (inherits its issues)
- Requires module-level scope object
- More feature-rich (dataclasses, async) but more complex

#### Standard Library: `contextvars`

The official solution for async context propagation. See main document sections above for detailed comparison.

### Why SVD is Unique

No existing package combines all of:

1. **Magic variable name discovery** — no global declaration, no imports needed by consumers
2. **Frame injection caching** — O(1) repeated lookups via breadcrumb trail
3. **"Not found" caching** — prevents repeated full walks when no context exists
4. **Type checking** — `isinstance()` verification during discovery
5. **Zero global state** — everything lives in stack frames
6. **Production-ready design** — not a "party trick" or educational tool

The frame injection caching is particularly novel. When context is found, SVD injects references into all traversed frames, creating a shortcut for subsequent lookups from the same call subtree. No other package implements this optimization.

### Conclusion on Related Work

The dynamic scoping problem space in Python is underserved:

- **`contextvars`** solves async context but requires global singletons
- **`stackful`** is unmaintained and uses a different mechanism
- **`dynamicscope`** is explicitly not for production
- **`dynascope`** builds on `contextvars`, inheriting its limitations

Stack Variable Discovery fills a gap: a production-ready, zero-global-state, cached stack-walking approach for synchronous context propagation.

**Immediate impact**: The existing `@timestamp` profiling system in OSBot-Utils can be upgraded with frame injection caching, reducing profiling overhead in deep call stacks from O(d) per call to O(1) for repeated lookups.

**Broader applicability**: The pattern enables a whole class of "ambient context" use cases — adaptive application behavior, debug contexts, transaction scoping, test fixtures, security contexts, and feature flags — all with natural Python scoping semantics and zero global state.

The pattern may warrant publication as a standalone package (e.g., `stack-context` or `ambient-scope`).

---

## References

- [PEP 567 — Context Variables](https://peps.python.org/pep-0567/)
- [contextvars documentation](https://docs.python.org/3/library/contextvars.html)
- [erikrose/stackful](https://github.com/erikrose/stackful) — Dynamically-scoped variables for Python
- [mentalisttraceur/dynamicscope](https://pypi.org/project/dynamicscope/) — Emulate dynamic scope in Python
- [mikaelho/dynascope](https://github.com/mikaelho/dynascope) — Dynamic scope for Python
- `v3_65_0__stack-variable-discovery__implementation-brief.md`
- `v3_65_0__type-safe-performance-optimization__usage-brief.md`