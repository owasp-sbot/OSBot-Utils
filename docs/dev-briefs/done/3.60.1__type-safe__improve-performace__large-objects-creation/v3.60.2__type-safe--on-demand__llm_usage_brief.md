# Type_Safe__On_Demand - LLM Usage Brief

**Version**: v3.60.2  
**Date**: December 2025  
**Module**: `osbot_utils.type_safe.Type_Safe__On_Demand`  
**Purpose**: High-performance drop-in replacement for Type_Safe with on-demand nested object creation

---

## Executive Summary

`Type_Safe__On_Demand` is a performance-optimized variant of `Type_Safe` that defers the creation of nested Type_Safe objects until they are first accessed. This provides **20x faster construction** for deeply nested object hierarchies while maintaining full compatibility with the Type_Safe API.

### Key Benefits

| Metric | Type_Safe (Eager) | Type_Safe__On_Demand | Improvement |
|--------|-------------------|----------------------|-------------|
| Construction time (MGraph__Index) | ~1,800 µs | ~90 µs | **20x faster** |
| Objects created | 47 | 1 | **98% reduction** |
| Memory allocation | All upfront | On-demand | **Deferred** |

### When to Use

Use `Type_Safe__On_Demand` when:
- Your class has **multiple nested Type_Safe attributes**
- Many of those attributes are **not accessed in typical workflows**
- Construction performance is a **bottleneck** (measurable with `Performance_Measure__Session`)

Do NOT use when:
- Your class has few or no nested Type_Safe attributes
- All attributes are accessed immediately after construction
- The class primarily contains primitives or collections

---

## Quick Start

### Basic Usage

```python
from osbot_utils.type_safe.Type_Safe__On_Demand import Type_Safe__On_Demand

# Simply inherit from Type_Safe__On_Demand instead of Type_Safe
class Schema__Data(Type_Safe__On_Demand):
    edges : Dict[str, str]
    labels: Dict[str, str]

class Index__Edges(Type_Safe__On_Demand):
    data   : Schema__Data      # NOT created until first access
    enabled: bool = True

class MGraph__Index(Type_Safe__On_Demand):
    edges_index : Index__Edges  # Created on demand
    labels_index: Index__Labels # Created on demand
    query_index : Index__Query  # Created on demand
    count       : int = 0       # Primitives work normally

# Construction is now ~20x faster
index = MGraph__Index()         # Only creates 1 object, not 47

# Attributes are created when accessed
edges = index.edges_index       # Index__Edges created now
data = edges.data               # Schema__Data created now
```

### Migration from Type_Safe

Migration is a single-line change:

```python
# Before (eager initialization)
class MGraph__Index(Type_Safe):
    edges_index: Index__Edges
    # ... many nested Type_Safe attributes

# After (on-demand initialization)  
class MGraph__Index(Type_Safe__On_Demand):
    edges_index: Index__Edges
    # ... same attributes, 20x faster construction
```

---

## How It Works

### Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    Type_Safe__On_Demand                         │
├─────────────────────────────────────────────────────────────────┤
│  Inherits from: Type_Safe                                       │
│                                                                 │
│  Additional State:                                              │
│    _on_demand__types        : dict   # {attr_name: type}        │
│    _on_demand__init_complete: bool   # False during __init__    │
├─────────────────────────────────────────────────────────────────┤
│  __init__():                                                    │
│    1. Set _on_demand__init_complete = False                     │
│    2. Walk MRO, find Type_Safe-typed attributes                 │
│    3. For each: store type, set kwargs[name] = None             │
│    4. Call super().__init__(**kwargs)                           │
│    5. Set _on_demand__init_complete = True                      │
├─────────────────────────────────────────────────────────────────┤
│  __getattribute__(name):                                        │
│    1. If name starts with '_': return directly                  │
│    2. If not _on_demand__init_complete: return directly         │
│    3. If name in _on_demand__types:                             │
│       - Pop type, create instance, store, return                │
│    4. Normal attribute access                                   │
└─────────────────────────────────────────────────────────────────┘
```

### What Gets Deferred

| Type | Deferred? | Reason |
|------|-----------|--------|
| `Type_Safe` subclasses | ✅ Yes | These are expensive to create |
| `Type_Safe__On_Demand` subclasses | ✅ Yes | Same reason |
| `Dict[K, V]` (Type_Safe__Dict) | ❌ No | Cheap empty containers |
| `List[T]` (Type_Safe__List) | ❌ No | Cheap empty containers |
| `Set[T]` (Type_Safe__Set) | ❌ No | Cheap empty containers |
| `Type_Safe__Primitive` (Safe_Str, etc.) | ❌ No | Immutable, validation needed |
| Native primitives (str, int, etc.) | ❌ No | Zero overhead |

### Internal State

After construction, you can inspect the on-demand state:

```python
index = MGraph__Index()

# See what's pending
print(index._on_demand__types)
# {'edges_index': <class 'Index__Edges'>, 'labels_index': ...}

# After accessing
_ = index.edges_index
print(index._on_demand__types)
# {'labels_index': ...}  # edges_index removed
```

---

## API Reference

### Class: `Type_Safe__On_Demand`

Inherits all methods from `Type_Safe` plus:

#### Attributes

| Attribute | Type | Description |
|-----------|------|-------------|
| `_on_demand__types` | `dict[str, type]` | Pending attribute names → types |
| `_on_demand__init_complete` | `bool` | True after `__init__` completes |

#### Methods

| Method | Description |
|--------|-------------|
| `_on_demand__should_create(var_type)` | Static method. Returns True if type should be deferred |
| `__repr__()` | Shows pending count: `<MGraph__Index (10 attrs pending)>` |

#### Inherited from Type_Safe

All standard Type_Safe methods work:
- `json()` - Serialize to dict (accessed attrs only have real data)
- `from_json(data)` - Deserialize from dict
- `obj()` - Convert to `__` for testing
- `reset()` - Reset to defaults
- `__locals__()` - Get current attribute values
- `__cls_kwargs__()` - Get class-level defaults

---

## Performance Benchmarking

### Measuring Construction Time

Use `Performance_Measure__Session` to benchmark:

```python
from osbot_utils.testing.performance.Performance_Measure__Session import Performance_Measure__Session

# Compare eager vs on-demand
with Performance_Measure__Session() as _:
    _.measure__quick(MGraph__Index__Eager)
    eager_time = _.result.final_score

with Performance_Measure__Session() as _:
    _.measure__quick(MGraph__Index__OnDemand)
    on_demand_time = _.result.final_score

speedup = eager_time / on_demand_time
print(f"Speedup: {speedup:.1f}x")  # Typically 10-20x
```

### Counting Object Creation

```python
# Monkey-patch to count creations
creation_count = 0
original_init = Type_Safe.__init__

def counting_init(self, **kwargs):
    global creation_count
    creation_count += 1
    original_init(self, **kwargs)

Type_Safe.__init__ = counting_init

# Test
_ = MGraph__Index__Eager()
print(f"Eager: {creation_count} objects")     # ~47

creation_count = 0
_ = MGraph__Index__OnDemand()
print(f"On-demand: {creation_count} objects") # 1

Type_Safe.__init__ = original_init
```

---

## Integration Patterns

### Pattern 1: Index Classes (MGraph Use Case)

The primary use case—index classes with multiple sub-indexes:

```python
class MGraph__Index(Type_Safe__On_Demand):
    index_data  : Schema__Data
    edges_index : Index__Edges
    edit_index  : Index__Edit
    labels_index: Index__Labels
    paths_index : Index__Paths
    query_index : Index__Query
    stats_index : Index__Stats
    types_index : Index__Types
    values_index: Index__Values
    resolver    : Type__Resolver

# Construction: ~90µs instead of ~1,800µs
# Access edges only: creates edges_index + its children
# Other indexes remain uncreated until needed
```

### Pattern 2: Mixed Hierarchies

Combine with regular Type_Safe where appropriate:

```python
class Schema__Data(Type_Safe):           # Eager - always fully accessed
    edges : Dict[str, str]
    labels: Dict[str, str]

class MGraph__Index(Type_Safe__On_Demand):  # On-demand - selective access
    data       : Schema__Data            # Deferred
    edges_index: Index__Edges            # Deferred
    labels_index: Index__Labels          # Deferred
```

### Pattern 3: Factory Classes

Create wrapper factories for complex object graphs:

```python
class MGraph__Factory(Type_Safe__On_Demand):
    index : MGraph__Index
    graph : MGraph__Graph
    config: MGraph__Config
    
    def create_editor(self):
        # Only index is accessed - others remain uncreated
        return MGraph__Editor(index=self.index)
```

---

## Common Pitfalls

### Pitfall 1: Expecting JSON to Trigger Creation

`json()` does NOT trigger on-demand creation for pending attributes:

```python
index = MGraph__Index()
json_data = index.json()
# json_data['edges_index'] will be None, not the serialized object

# Fix: Access attributes first
_ = index.edges_index           # Create it
json_data = index.json()        # Now it serializes
```

### Pitfall 2: Assignment to Pending Attributes

Assigning to a pending attribute may be overwritten:

```python
index = MGraph__Index()
index.edges_index = custom_edges  # Sets value
_ = index.edges_index             # OVERWRITES with new Index__Edges!

# Fix: Remove from pending first
index._on_demand__types.pop('edges_index', None)
index.edges_index = custom_edges  # Now it sticks
```

### Pitfall 3: Assuming All Type_Safe Attrs Are Deferred

Collections and primitives are NOT deferred:

```python
class Schema(Type_Safe__On_Demand):
    data  : Dict[str, str]     # Created immediately
    items : List[str]          # Created immediately
    name  : str = ""           # Created immediately
    nested: Another_Schema     # ONLY this is deferred
```

---

## Use Case: Html_MGraph Performance Optimization

### The Problem

Html_MGraph creates 6 MGraph__Index instances during document conversion:

```python
class Html_MGraph:
    def convert(self, html):
        # Each index construction was ~1.8ms
        self.index_1 = MGraph__Index()  # 1.8ms
        self.index_2 = MGraph__Index()  # 1.8ms
        self.index_3 = MGraph__Index()  # 1.8ms
        self.index_4 = MGraph__Index()  # 1.8ms
        self.index_5 = MGraph__Index()  # 1.8ms
        self.index_6 = MGraph__Index()  # 1.8ms
        # Total: ~11ms just for empty index construction
```

### The Solution

Migrate MGraph__Index to Type_Safe__On_Demand:

```python
class MGraph__Index(Type_Safe__On_Demand):  # Changed from Type_Safe
    # ... same attributes ...

# Now:
self.index_1 = MGraph__Index()  # ~90µs
# Total for 6: ~0.5ms (saved ~10.5ms)
```

### Expected Impact

| Scenario | Before | After | Improvement |
|----------|--------|-------|-------------|
| Single MGraph__Index | 1.8ms | 0.09ms | 20x |
| Html_MGraph (6 indexes) | 11ms | 0.5ms | 22x |
| 100 document batch | 1,100ms | 50ms | 22x |

---

## Testing Type_Safe__On_Demand Classes

### Functional Testing

```python
from osbot_utils.testing.__ import __, __SKIP__

def test__init__(self):
    with MGraph__Index() as _:
        assert type(_) is MGraph__Index
        assert len(_._on_demand__types) == 10       # 10 attrs pending
        
def test__on_demand_creation(self):
    with MGraph__Index() as _:
        edges = _.edges_index                        # Trigger creation
        assert type(edges) is Index__Edges
        assert 'edges_index' not in _._on_demand__types
        
def test_json__after_access(self):
    with MGraph__Index() as _:
        _ = _.edges_index                            # Must access first
        json_data = _.json()
        assert 'edges_index' in json_data
        assert json_data['edges_index'] is not None
```

### Performance Testing

```python
def test__construction_performance(self):
    with Performance_Measure__Session() as _:
        _.measure__quick(MGraph__Index)
        
    target_ns = 200_000  # 200µs
    assert _.result.final_score <= target_ns
```

---

## Compatibility Matrix

| Feature | Compatible | Notes |
|---------|------------|-------|
| Type_Safe inheritance | ✅ | Direct subclass |
| JSON serialization | ✅ | Access attrs first |
| from_json() | ✅ | Works normally |
| .obj() comparison | ✅ | Access attrs first |
| Type_Safe__Dict | ✅ | Not deferred |
| Type_Safe__List | ✅ | Not deferred |
| Type_Safe__Primitive | ✅ | Not deferred |
| Mixed inheritance | ✅ | See patterns above |
| Context managers | ✅ | Works normally |
| reset() | ✅ | Works normally |

---

## Summary

`Type_Safe__On_Demand` provides a targeted optimization for the specific problem of deeply nested Type_Safe hierarchies. By deferring object creation until access:

1. **Construction is 20x faster** for complex hierarchies
2. **Memory is allocated incrementally** as needed
3. **Full API compatibility** with Type_Safe is maintained
4. **Migration is trivial** (single inheritance change)

The feature is particularly valuable for:
- Index classes with many sub-indexes (MGraph__Index)
- Factory classes that may not use all components
- Batch processing where construction overhead accumulates

For the Html_MGraph project specifically, migrating to `Type_Safe__On_Demand` is expected to save **~10ms per document** in index construction overhead.
