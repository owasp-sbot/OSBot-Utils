# Timestamp Capture System - Design Document

**Version**: v3.58.0  
**Date**: December 2025

---

## Overview

A lightweight performance instrumentation framework using decorators and stack-walking to capture execution timestamps with minimal code changes.

---

## Design Goals

| Goal | Requirement |
|------|-------------|
| **Minimal Code Changes** | Just add `@timestamp` decorator to methods |
| **No Signature Changes** | Methods don't need collector parameter |
| **Thread/Call-Specific** | Each invocation has its own collector |
| **Low Overhead** | Minimal impact when not profiling |
| **Reusable** | Generic system, not tied to Html_MGraph |
| **Leave-in-Place** | Can remain in codebase permanently |

---

## Core Concept

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           STACK-WALKING PATTERN                             │
└─────────────────────────────────────────────────────────────────────────────┘

    Entry Point (test/main)                    @timestamp decorated methods
    ────────────────────────                   ────────────────────────────
    
    def test_workflow():                       class Converter:
        _timestamp_collector_ = Collector()        @timestamp
        with _timestamp_collector_:                def convert(self, data):
            result = converter.convert(data)           ...
                        │                              │
                        │                              │
                        ▼                              ▼
                    ┌───────────────────────────────────────┐
                    │         CALL STACK                    │
                    ├───────────────────────────────────────┤
                    │  frame 0: convert()                   │
                    │  frame 1: ...                         │
                    │  frame 2: ...                         │
                    │  frame N: test_workflow()  ◄── HAS    │
                    │           _timestamp_collector_       │
                    └───────────────────────────────────────┘
                                    │
                                    │ walk stack, find collector
                                    ▼
                    ┌───────────────────────────────────────┐
                    │  collector.enter("convert")           │
                    │  ... execute method ...               │
                    │  collector.exit("convert")            │
                    └───────────────────────────────────────┘
```

---

## Key Design Decisions

### 1. Stack-Walking to Find Collector

**Why**: Avoids passing collector through every function signature.

```python
# WITHOUT stack-walking (invasive)
def convert(self, data, collector=None):
    result = self._parse(data, collector)       # Must thread through
    result = self._transform(result, collector)  # Every method
    return result

# WITH stack-walking (non-invasive)
@timestamp
def convert(self, data):
    result = self._parse(data)                   # No changes needed
    result = self._transform(result)             # Signatures unchanged
    return result
```

### 2. Magic Variable Name `_timestamp_collector_`

**Why**: Simple convention that works with Python's frame inspection.

```python
# The collector must be a local variable with this exact name
_timestamp_collector_ = Timestamp_Collector()

# Stack walker looks for this:
if '_timestamp_collector_' in frame.f_locals:
    return frame.f_locals['_timestamp_collector_']
```

### 3. No-Op When Collector Absent

**Why**: Decorated code runs normally when not profiling.

```python
@timestamp
def my_method(self):
    ...

# When no collector in stack:
#   - Stack walk takes ~1-2μs
#   - Returns None
#   - Method executes directly
#   - Minimal overhead
```

### 4. perf_counter_ns for Timing

**Why**: Monotonic, high-resolution, not affected by system clock changes.

```python
timestamp_ns = time.perf_counter_ns()   # Monotonic, ~nanosecond precision
clock_ns     = time.time_ns()            # Wall clock (for correlation)
```

---

## API Reference

### Timestamp_Collector

```python
class Timestamp_Collector(Type_Safe):
    name          : str                       # Collector name
    entries       : List[Timestamp_Entry]     # All recorded entries
    start_time_ns : int                       # Start timestamp
    end_time_ns   : int                       # End timestamp
    
    # Context manager
    def __enter__(self) -> 'Timestamp_Collector'
    def __exit__(...)
    
    # Recording
    def enter(self, name: str, extra: Dict = None)
    def exit(self, name: str, extra: Dict = None)
    
    # Analysis
    def total_duration_ms(self) -> float
    def get_method_timings(self) -> Dict[str, Method_Timing]
    def get_hotspots(self, top_n: int = 10) -> List[Method_Timing]
    
    # Reporting
    def print_report()
    def print_timeline(max_entries: int = 100)
    def print_hotspots(top_n: int = 10)
```

### @timestamp Decorator

```python
@timestamp
def my_method(self):
    ...

@timestamp(name="custom.name")
def another_method(self):
    ...
```

### timestamp_block Context Manager

```python
with timestamp_block("processing_phase"):
    # Code to measure
    ...
```

---

## Overhead Analysis

| Operation | Approximate Cost |
|-----------|-----------------|
| Stack walk (collector not found) | ~1-2 μs |
| Stack walk (collector found) | ~1-2 μs |
| Record entry | ~0.5-1 μs |
| Per decorated call (when profiling) | ~3-5 μs total |
| Per decorated call (no collector) | ~1-2 μs |

**Comparison with alternatives**:

| Approach | Overhead | Granularity | Code Changes |
|----------|----------|-------------|--------------|
| **This approach** | ~3-5 μs/call | Method-level | Decorator only |
| sys.settrace | ~100-500 μs/call | Line-level | None |
| cProfile | ~10-50 μs/call | Function-level | None |
| Manual timing | ~1-2 μs/call | Arbitrary | Extensive |

---

## Alternative Approaches Considered

### 1. sys.settrace / sys.setprofile

```python
def trace_calls(frame, event, arg):
    if event == 'call':
        record_entry(frame.f_code.co_name)
    return trace_calls

sys.settrace(trace_calls)
```

**Pros**: No code changes, traces everything  
**Cons**: High overhead (~100-500μs per call), captures too much

### 2. cProfile

```python
import cProfile
profiler = cProfile.Profile()
profiler.enable()
# ... code ...
profiler.disable()
profiler.print_stats()
```

**Pros**: Built-in, comprehensive  
**Cons**: Can't leave in place, all-or-nothing, ~10-50μs overhead

### 3. Context Variables (Python 3.7+)

```python
from contextvars import ContextVar
_collector: ContextVar[Timestamp_Collector] = ContextVar('collector')

@timestamp
def my_method(self):
    collector = _collector.get(None)
    if collector:
        collector.enter(...)
```

**Pros**: Thread-safe, async-compatible  
**Cons**: Still need to set context var somewhere (similar to our approach)

### 4. Thread-Local Storage

```python
import threading
_local = threading.local()

@timestamp
def my_method(self):
    collector = getattr(_local, 'collector', None)
    ...
```

**Pros**: Simple, thread-safe  
**Cons**: Global state, cleanup issues, less explicit

---

## Integration with Html_MGraph

### Step 1: Add decorators to key methods

```python
# Html__To__Html_MGraph__Document.py

class Html__To__Html_MGraph__Document(Type_Safe):
    
    @timestamp
    def convert(self, html: str) -> Html_MGraph__Document:
        ...
    
    @timestamp(name="parse_html")
    def _parse_html(self, html: str):
        self.soup = BeautifulSoup(html, 'html.parser')
    
    @timestamp(name="build_body_graph")
    def _build_body_graph(self, doc):
        ...
    
    @timestamp(name="build_attrs_graph")  
    def _build_attrs_graph(self, doc):
        ...
    
    @timestamp(name="process_element")
    def _process_element(self, elem, parent_id):
        # Called many times - will aggregate
        ...
```

### Step 2: Use in tests/profiling

```python
def test_conversion_performance():
    html = load_test_html()
    
    _timestamp_collector_ = Timestamp_Collector(name="html_conversion")
    
    with _timestamp_collector_:
        with Html__To__Html_MGraph__Document() as converter:
            doc = converter.convert(html)
    
    # Automatic report
    _timestamp_collector_.print_report()
    
    # Or get data programmatically
    timings = _timestamp_collector_.get_method_timings()
    assert timings['build_attrs_graph'].total_ms() < 100
```

### Step 3: Leave decorators in production

The decorators have minimal overhead (~1-2μs) when no collector is present.

```python
# Production code - no collector, minimal overhead
doc = converter.convert(html)  # ~1-2μs extra per decorated method

# Debugging - add collector to capture timing
_timestamp_collector_ = Timestamp_Collector()
with _timestamp_collector_:
    doc = converter.convert(html)  # Full timing captured
```

---

## Sample Output

```
================================================================================
Timestamp Report: html_conversion
================================================================================

  Total Duration : 3,419.15 ms
  Entry Count    : 847
  Methods Traced : 12

Method Timings (sorted by total time):
----------------------------------------------------------------------------------------------------
Method                                             Calls      Total       Self      Avg    %Total
----------------------------------------------------------------------------------------------------
Html__To__Html_MGraph__Document.convert                1  2942.93ms  145.23ms 2942.930ms   86.1%
build_attrs_graph                                      1  1823.45ms 1823.45ms 1823.450ms   53.3%
build_body_graph                                       1   892.12ms  234.56ms  892.120ms   26.1%
process_element                                      156   657.56ms  657.56ms    4.215ms   19.2%
Html_MGraph__Document__To__Html.convert                1   476.22ms   89.34ms  476.220ms   13.9%
serialize_element                                    156   386.88ms  386.88ms    2.480ms   11.3%
...

================================================================================
Top 10 Hotspots (by self-time)
================================================================================
   1. build_attrs_graph                        1823.45ms (53.3%) [1 calls]
   2. process_element                           657.56ms (19.2%) [156 calls]
   3. serialize_element                         386.88ms (11.3%) [156 calls]
   4. build_body_graph                          234.56ms ( 6.9%) [1 calls]
   5. Html__To__Html_MGraph__Document.convert   145.23ms ( 4.2%) [1 calls]
================================================================================
```

---

## Summary

| Feature | Implementation |
|---------|----------------|
| Find collector | Stack walk looking for `_timestamp_collector_` |
| Minimal changes | `@timestamp` decorator only |
| Low overhead | ~3-5μs when profiling, ~1-2μs when not |
| Thread-safe | Each call has its own collector |
| Leave-in-place | Decorators stay in production code |
| Self-time | Tracks exclusive time (minus children) |
| Aggregation | Sums multiple calls to same method |

The approach meets all stated requirements while providing rich timing data for performance analysis.
