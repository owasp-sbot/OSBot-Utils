# (Brief 3.8) Complete Semantic Graph Foundation

**Version:** v3.65.0  
**Status:** Extension to Brief 3.7  
**Target:** OSBot-Utils (`osbot_utils.helpers.semantic_graphs`)  
**Created:** January 2026  
**Prerequisites:** Brief 3.7 (Projected Data Architecture) complete  
**Enables:** Full RDF/OWL alignment, typed properties, taxonomy integration  

---

## 1. Document Purpose

This brief completes the semantic graph foundation by addressing gaps identified during Brief 3.7 implementation:

> **Gap 1:** Taxonomy exists but is disconnected — node types don't link to categories  
> **Gap 2:** Taxonomy uses refs internally instead of IDs (inconsistent with Brief 3.7)  
> **Gap 3:** Nodes and edges cannot hold properties (data values)  
> **Gap 4:** Projections include full ontology in references instead of only what's used  

> **The Solution:** 
> - Wire taxonomy to ontology via `category_id` on node types
> - Convert taxonomy to ID-based internal references  
> - Add property system with `property_name_id` and optional `property_type_id`
> - Add properties to nodes and edges
> - Add taxonomy section to projections
> - Filter projection references to only include used refs

**Outcome:** A complete, standards-aligned foundation for semantic graphs that maps cleanly to RDF, RDFS, and OWL concepts.

---

## 2. Standards Alignment

This design intentionally aligns with established semantic web standards:

| Our Concept | RDF/RDFS | OWL | Notes |
|-------------|----------|-----|-------|
| Node Type | `rdfs:Class` | `owl:Class` | Type definition |
| Node | `rdf:Resource` | `owl:NamedIndividual` | Instance |
| Predicate | `rdf:Property` | `owl:ObjectProperty` | Relationship type |
| Edge | RDF Triple (s→p→o) | Same | Subject-Predicate-Object |
| Edge Rule | `rdfs:domain` + `rdfs:range` | Same | Valid connections |
| inverse_id | — | `owl:inverseOf` | Bidirectional relationships |
| Category | `rdfs:Class` hierarchy | `owl:subClassOf` | Classification |
| Property Name | `rdf:Property` | `owl:DatatypeProperty` | Data properties |
| Property Type | `xsd:*` datatypes | Same | Value types |

### Edge as Triple

Our edge structure maps directly to RDF triples:

```
from_node_id  →  predicate_id  →  to_node_id
   Subject         Predicate        Object
```

This enables straightforward export to N-Triples, Turtle, JSON-LD, and other RDF serializations.

---

## 3. Design Principles

### Principle 1: Everything Uses IDs Internally

All cross-references in Schema__ use IDs for referential integrity:
- `parent_id` not `parent_ref`
- `category_id` not `category_ref`  
- `property_name_id` not `property_name_ref`
- `property_type_id` not `property_type_ref`

### Principle 2: Refs Are Human Labels Defined Once

Each entity has a `*_ref` field that is the human-readable label:
- Defined once on the entity itself
- Looked up via registry or projection references
- Never used as foreign keys

### Principle 3: Properties Are Flexible

Property values are stored as strings (`Safe_Str__Text`):
- Simple and universal
- Type validation is optional (via `property_type_id`)
- Consumer decides how to interpret/validate
- `property_type_id = None` implies string (no validation)

### Principle 4: Ontology Defines, Rules Constrain

Clear separation of concerns:
- **Ontology:** What CAN exist (definitions)
- **Rules:** What MUST exist (constraints)

Example: "line_number property" is defined in ontology. "method nodes MUST have line_number" is a rule.

### Principle 5: Projections Show Only What's Used

Projection references include only:
- Node types that appear in the graph's nodes
- Predicates that appear in the graph's edges
- Categories of those node types
- Property names used in node/edge properties
- Property types of those property names

---

## 4. Taxonomy Changes

### 4.1 Before (Brief 3.7)

```python
class Schema__Taxonomy__Category(Type_Safe):
    category_ref : Category_Ref
    name         : Safe_Str__Id
    description  : Safe_Str__Text
    parent_ref   : Category_Ref           # ← Ref-based (inconsistent)
    child_refs   : List__Category_Refs    # ← Ref-based (inconsistent)
```

### 4.2 After (Brief 3.8)

```python
class Schema__Taxonomy__Category(Type_Safe):
    category_id  : Category_Id                        # Instance identifier
    category_ref : Category_Ref                       # Human-readable label (display name derivable from this)
    parent_id    : Category_Id      = None            # FK to parent (None = root)
    child_ids    : List__Category_Ids                 # FKs to children
    # NOTE: 'name' removed — derivable from category_ref via: ref.replace('_', ' ').title()
```

### 4.3 Schema__Taxonomy Update

```python
class Schema__Taxonomy(Type_Safe):
    taxonomy_id   : Taxonomy_Id
    taxonomy_ref  : Taxonomy_Ref
    version       : Safe_Str__Version
    root_id       : Category_Id                       # CHANGED: was root_category (ref)
    categories    : Dict__Categories__By_Id           # CHANGED: was By_Ref
```

### 4.4 New Collection Types

```python
class Dict__Categories__By_Id(Type_Safe__Dict):
    expected_key_type   = Category_Id
    expected_value_type = Schema__Taxonomy__Category
```

---

## 5. Ontology Changes

### 5.1 Node Type — Add category_id

```python
class Schema__Ontology__Node_Type(Type_Safe):
    node_type_id   : Node_Type_Id
    node_type_ref  : Node_Type_Ref
    category_id    : Category_Id     = None           # NEW: FK to taxonomy category
```

### 5.2 New Property Name Entity

```python
class Schema__Ontology__Property_Name(Type_Safe):
    property_name_id  : Property_Name_Id              # Instance identifier
    property_name_ref : Property_Name_Ref             # Human-readable label ("line_number")
    property_type_id  : Property_Type_Id = None       # FK to type (None = string)
```

### 5.3 New Property Type Entity

```python
class Schema__Ontology__Property_Type(Type_Safe):
    property_type_id  : Property_Type_Id              # Instance identifier
    property_type_ref : Property_Type_Ref             # Human-readable label ("integer", "boolean")
```

### 5.4 Schema__Ontology Update

```python
class Schema__Ontology(Type_Safe):
    ontology_id     : Ontology_Id
    ontology_ref    : Ontology_Ref
    taxonomy_id     : Taxonomy_Id        = None
    
    node_types      : Dict__Node_Types__By_Id
    predicates      : Dict__Predicates__By_Id
    property_names  : Dict__Property_Names__By_Id     # NEW
    property_types  : Dict__Property_Types__By_Id     # NEW
    edge_rules      : List__Edge_Rules
```

### 5.5 New Identifier Types

```python
class Property_Name_Id(Semantic_Id):
    pass

class Property_Name_Ref(Semantic_Ref):
    pass

class Property_Type_Id(Semantic_Id):
    pass

class Property_Type_Ref(Semantic_Ref):
    pass
```

### 5.6 New Collection Types

```python
class Dict__Property_Names__By_Id(Type_Safe__Dict):
    expected_key_type   = Property_Name_Id
    expected_value_type = Schema__Ontology__Property_Name

class Dict__Property_Types__By_Id(Type_Safe__Dict):
    expected_key_type   = Property_Type_Id
    expected_value_type = Schema__Ontology__Property_Type
```

---

## 6. Graph Changes

### 6.1 Node Properties

```python
class Schema__Semantic_Graph__Node(Type_Safe):
    node_id        : Node_Id
    node_id_source : Schema__Id__Source = None
    node_type_id   : Node_Type_Id
    name           : Safe_Str__Id
    properties     : Dict__Node_Properties  = None    # NEW: Property_Name_Id → Safe_Str__Text
```

### 6.2 Edge Properties

```python
class Schema__Semantic_Graph__Edge(Type_Safe):
    edge_id        : Edge_Id
    edge_id_source : Schema__Id__Source = None
    from_node_id   : Node_Id
    to_node_id     : Node_Id
    predicate_id   : Predicate_Id
    properties     : Dict__Edge_Properties  = None    # NEW: Property_Name_Id → Safe_Str__Text
```

### 6.3 Property Collection Types

```python
class Dict__Node_Properties(Type_Safe__Dict):
    expected_key_type   = Property_Name_Id
    expected_value_type = Safe_Str__Text

class Dict__Edge_Properties(Type_Safe__Dict):
    expected_key_type   = Property_Name_Id
    expected_value_type = Safe_Str__Text
```

---

## 7. Rules Changes

### 7.1 Required Property Rules

New rule types for property constraints:

```python
class Schema__Rule__Required_Node_Property(Type_Safe):
    node_type_id      : Node_Type_Id
    property_name_id  : Property_Name_Id

class Schema__Rule__Required_Edge_Property(Type_Safe):
    predicate_id      : Predicate_Id
    property_name_id  : Property_Name_Id
```

### 7.2 Schema__Rule_Set Update

```python
class Schema__Rule_Set(Type_Safe):
    rule_set_id              : Rule_Set_Id
    rule_set_ref             : Rule_Set_Ref
    ontology_ref             : Ontology_Ref
    version                  : Safe_Str__Version
    transitivity_rules       : List__Rules__Transitivity
    cardinality_rules        : List__Rules__Cardinality
    required_node_properties : List__Rules__Required_Node_Property    # NEW
    required_edge_properties : List__Rules__Required_Edge_Property    # NEW
```

### 7.3 New Collection Types

```python
class List__Rules__Required_Node_Property(Type_Safe__List):
    expected_type = Schema__Rule__Required_Node_Property

class List__Rules__Required_Edge_Property(Type_Safe__List):
    expected_type = Schema__Rule__Required_Edge_Property
```

---

## 8. Projection Changes

### 8.1 Projected Node — Add Properties

```python
class Schema__Projected__Node(Type_Safe):
    ref        : Node_Type_Ref
    name       : Safe_Str__Id
    properties : Dict__Projected_Properties = None    # NEW: Property_Name_Ref → Safe_Str__Text
```

### 8.2 Projected Edge — Add Properties

```python
class Schema__Projected__Edge(Type_Safe):
    from_name  : Safe_Str__Id
    to_name    : Safe_Str__Id
    ref        : Predicate_Ref
    properties : Dict__Projected_Properties = None    # NEW: Property_Name_Ref → Safe_Str__Text
```

### 8.3 Projected Properties Collection

```python
class Dict__Projected_Properties(Type_Safe__Dict):
    expected_key_type   = Property_Name_Ref
    expected_value_type = Safe_Str__Text
```

### 8.4 Projected References — Filter + Expand

**Bug fix:** Only include refs actually used in the projection.

**Addition:** Add categories, property_names, property_types.

```python
class Schema__Projected__References(Type_Safe):
    node_types     : Dict__Node_Type_Ids__By_Ref      # Only types in graph nodes
    predicates     : Dict__Predicate_Ids__By_Ref      # Only predicates in graph edges
    categories     : Dict__Category_Ids__By_Ref       # NEW: Only categories of node types in graph
    property_names : Dict__Property_Name_Ids__By_Ref  # NEW: Only properties used in graph
    property_types : Dict__Property_Type_Ids__By_Ref  # NEW: Only types of used properties
```

### 8.5 New Reference Collection Types

```python
class Dict__Category_Ids__By_Ref(Type_Safe__Dict):
    expected_key_type   = Category_Ref
    expected_value_type = Category_Id

class Dict__Property_Name_Ids__By_Ref(Type_Safe__Dict):
    expected_key_type   = Property_Name_Ref
    expected_value_type = Property_Name_Id

class Dict__Property_Type_Ids__By_Ref(Type_Safe__Dict):
    expected_key_type   = Property_Type_Ref
    expected_value_type = Property_Type_Id
```

### 8.6 Projected Taxonomy — NEW Section

New section providing human-readable taxonomy information:

```python
class Schema__Projected__Taxonomy(Type_Safe):
    node_type_categories : Dict__Category_Refs__By_Node_Type_Ref   # Which category each type belongs to
    category_parents     : Dict__Category_Refs__By_Category_Ref    # Category hierarchy (None = root)
```

### 8.7 Taxonomy Collection Types

```python
class Dict__Category_Refs__By_Node_Type_Ref(Type_Safe__Dict):
    expected_key_type   = Node_Type_Ref
    expected_value_type = Category_Ref                             # Can be None if no category

class Dict__Category_Refs__By_Category_Ref(Type_Safe__Dict):
    expected_key_type   = Category_Ref
    expected_value_type = Category_Ref                             # Parent ref (None = root)
```

### 8.8 Schema__Projected__Semantic_Graph Update

```python
class Schema__Projected__Semantic_Graph(Type_Safe):
    projection : Schema__Projected__Data
    references : Schema__Projected__References
    taxonomy   : Schema__Projected__Taxonomy          # NEW: fourth section
    sources    : Schema__Projected__Sources
```

---

## 9. Projector Changes

### 9.1 Updated project() Method

The projector now:
1. Projects properties on nodes (ID → Ref)
2. Projects properties on edges (ID → Ref)
3. Builds filtered references (only used refs)
4. Builds taxonomy section

```python
@type_safe
def project(self, graph: Schema__Semantic_Graph) -> Schema__Projected__Semantic_Graph:
    ontology = self.ontology_registry.get_by_id(graph.ontology_id)
    taxonomy = self.get_taxonomy(ontology)
    
    # Build lookup maps
    node_type_id_to_ref    = self.build_node_type_id_to_ref(ontology)
    predicate_id_to_ref    = self.build_predicate_id_to_ref(ontology)
    property_name_id_to_ref = self.build_property_name_id_to_ref(ontology)
    node_id_to_name        = self.build_node_id_to_name(graph)
    
    # Project data
    projected_nodes = self.project_nodes(graph, node_type_id_to_ref, property_name_id_to_ref)
    projected_edges = self.project_edges(graph, node_id_to_name, predicate_id_to_ref, property_name_id_to_ref)
    
    # Build filtered references (only what's used)
    references = self.build_references_filtered(graph, ontology, projected_nodes, projected_edges)
    
    # Build taxonomy section
    taxonomy_section = self.build_taxonomy_section(ontology, taxonomy, projected_nodes)
    
    # Build sources
    sources = self.build_sources(graph, ontology)
    
    return Schema__Projected__Semantic_Graph(
        projection = Schema__Projected__Data(nodes=projected_nodes, edges=projected_edges),
        references = references,
        taxonomy   = taxonomy_section,
        sources    = sources
    )
```

### 9.2 Project Node Properties

```python
def project_node_properties(self,
                            properties          : Dict__Node_Properties,
                            property_name_id_to_ref : dict) -> Dict__Projected_Properties:
    if properties is None:
        return None
    result = Dict__Projected_Properties()
    for prop_id, value in properties.items():
        prop_ref = property_name_id_to_ref.get(prop_id, Property_Name_Ref(''))
        result[prop_ref] = value
    return result
```

### 9.3 Build Filtered References

```python
def build_references_filtered(self,
                              graph           : Schema__Semantic_Graph,
                              ontology        : Schema__Ontology,
                              projected_nodes : List__Projected__Nodes,
                              projected_edges : List__Projected__Edges) -> Schema__Projected__References:
    
    # Collect used refs from projection
    used_node_type_refs  = {n.ref for n in projected_nodes}
    used_predicate_refs  = {e.ref for e in projected_edges}
    used_property_refs   = set()
    
    for node in projected_nodes:
        if node.properties:
            used_property_refs.update(node.properties.keys())
    for edge in projected_edges:
        if edge.properties:
            used_property_refs.update(edge.properties.keys())
    
    # Build filtered mappings (ref → id for only used refs)
    node_types = Dict__Node_Type_Ids__By_Ref()
    for nt in ontology.node_types.values():
        if nt.node_type_ref in used_node_type_refs:
            node_types[nt.node_type_ref] = nt.node_type_id
    
    predicates = Dict__Predicate_Ids__By_Ref()
    for p in ontology.predicates.values():
        if p.predicate_ref in used_predicate_refs:
            predicates[p.predicate_ref] = p.predicate_id
    
    # ... similar for categories, property_names, property_types
    
    return Schema__Projected__References(
        node_types     = node_types,
        predicates     = predicates,
        categories     = categories,
        property_names = property_names,
        property_types = property_types
    )
```

### 9.4 Build Taxonomy Section

```python
def build_taxonomy_section(self,
                           ontology        : Schema__Ontology,
                           taxonomy        : Schema__Taxonomy,
                           projected_nodes : List__Projected__Nodes) -> Schema__Projected__Taxonomy:
    
    used_node_type_refs = {n.ref for n in projected_nodes}
    
    # Map node types to their categories
    node_type_categories = Dict__Category_Refs__By_Node_Type_Ref()
    category_ids_used = set()
    
    for nt in ontology.node_types.values():
        if nt.node_type_ref in used_node_type_refs and nt.category_id:
            category = taxonomy.categories.get(nt.category_id)
            if category:
                node_type_categories[nt.node_type_ref] = category.category_ref
                category_ids_used.add(nt.category_id)
    
    # Build category parent chain (for all used categories and their ancestors)
    category_parents = Dict__Category_Refs__By_Category_Ref()
    # ... walk up parent chain for each used category
    
    return Schema__Projected__Taxonomy(
        node_type_categories = node_type_categories,
        category_parents     = category_parents
    )
```

---

## 10. Example: Complete Data Flow

### 10.1 Taxonomy

```python
taxonomy = Schema__Taxonomy(
    taxonomy_id  = Taxonomy_Id('tax001'),
    taxonomy_ref = Taxonomy_Ref('code_elements'),
    root_id      = Category_Id('cat001'),
    categories   = {
        Category_Id('cat001'): Schema__Taxonomy__Category(
            category_id  = Category_Id('cat001'),
            category_ref = Category_Ref('code_element'),
            parent_id    = None,
            child_ids    = [Category_Id('cat002'), Category_Id('cat003')],
        ),
        Category_Id('cat002'): Schema__Taxonomy__Category(
            category_id  = Category_Id('cat002'),
            category_ref = Category_Ref('callable'),
            parent_id    = Category_Id('cat001'),
            child_ids    = [],
        ),
        # ...
    }
)
```

### 10.2 Ontology

```python
ontology = Schema__Ontology(
    ontology_id    = Ontology_Id('ont001'),
    ontology_ref   = Ontology_Ref('code_structure'),
    taxonomy_id    = Taxonomy_Id('tax001'),
    
    node_types = {
        Node_Type_Id('nt001'): Schema__Ontology__Node_Type(
            node_type_id  = Node_Type_Id('nt001'),
            node_type_ref = Node_Type_Ref('method'),
            category_id   = Category_Id('cat002')           # Links to "callable"
        ),
        # ...
    },
    
    predicates = {
        Predicate_Id('pred001'): Schema__Ontology__Predicate(
            predicate_id  = Predicate_Id('pred001'),
            predicate_ref = Predicate_Ref('calls'),
            inverse_id    = Predicate_Id('pred002')
        ),
        # ...
    },
    
    property_names = {
        Property_Name_Id('prop001'): Schema__Ontology__Property_Name(
            property_name_id  = Property_Name_Id('prop001'),
            property_name_ref = Property_Name_Ref('line_number'),
            property_type_id  = Property_Type_Id('type001')
        ),
        Property_Name_Id('prop002'): Schema__Ontology__Property_Name(
            property_name_id  = Property_Name_Id('prop002'),
            property_name_ref = Property_Name_Ref('is_async'),
            property_type_id  = Property_Type_Id('type002')
        ),
    },
    
    property_types = {
        Property_Type_Id('type001'): Schema__Ontology__Property_Type(
            property_type_id  = Property_Type_Id('type001'),
            property_type_ref = Property_Type_Ref('integer')
        ),
        Property_Type_Id('type002'): Schema__Ontology__Property_Type(
            property_type_id  = Property_Type_Id('type002'),
            property_type_ref = Property_Type_Ref('boolean')
        ),
    },
    
    edge_rules = [...]
)
```

### 10.3 Graph

```python
graph = Schema__Semantic_Graph(
    graph_id    = Graph_Id('graph001'),
    ontology_id = Ontology_Id('ont001'),
    
    nodes = {
        Node_Id('n001'): Schema__Semantic_Graph__Node(
            node_id      = Node_Id('n001'),
            node_type_id = Node_Type_Id('nt001'),
            name         = Safe_Str__Id('calculate_sum'),
            properties   = {
                Property_Name_Id('prop001'): Safe_Str__Text('42'),
                Property_Name_Id('prop002'): Safe_Str__Text('false'),
            }
        ),
        Node_Id('n002'): Schema__Semantic_Graph__Node(
            node_id      = Node_Id('n002'),
            node_type_id = Node_Type_Id('nt002'),
            name         = Safe_Str__Id('helper'),
            properties   = {
                Property_Name_Id('prop001'): Safe_Str__Text('87'),
            }
        ),
    },
    
    edges = [
        Schema__Semantic_Graph__Edge(
            edge_id      = Edge_Id('e001'),
            from_node_id = Node_Id('n001'),
            to_node_id   = Node_Id('n002'),
            predicate_id = Predicate_Id('pred001'),
            properties   = {
                Property_Name_Id('prop003'): Safe_Str__Text('3'),
            }
        ),
    ]
)
```

### 10.4 Projection Output

```yaml
projection:
  nodes:
    - ref: "method"
      name: "calculate_sum"
      properties:
        line_number: "42"
        is_async: "false"
    - ref: "function"
      name: "helper"
      properties:
        line_number: "87"
  edges:
    - from_name: "calculate_sum"
      to_name: "helper"
      ref: "calls"
      properties:
        call_count: "3"

references:
  node_types:
    method: "nt001"
    function: "nt002"
  predicates:
    calls: "pred001"
  categories:
    callable: "cat002"
    code_element: "cat001"
  property_names:
    line_number: "prop001"
    is_async: "prop002"
    call_count: "prop003"
  property_types:
    integer: "type001"
    boolean: "type002"

taxonomy:
  node_type_categories:
    method: "callable"
    function: "callable"
  category_parents:
    callable: "code_element"
    code_element: null

sources:
  source_graph_id: "graph001"
  ontology_seed: null
  generated_at: 1704412800000
```

---

## 11. File Structure

### 11.1 New Files

```
osbot_utils/helpers/semantic_graphs/
├── schemas/
│   ├── identifier/
│   │   ├── Property_Name_Id.py                     # NEW
│   │   ├── Property_Name_Ref.py                    # NEW
│   │   ├── Property_Type_Id.py                     # NEW
│   │   └── Property_Type_Ref.py                    # NEW
│   ├── ontology/
│   │   ├── Schema__Ontology__Property_Name.py     # NEW
│   │   └── Schema__Ontology__Property_Type.py     # NEW
│   ├── rule/
│   │   ├── Schema__Rule__Required_Node_Property.py # NEW
│   │   └── Schema__Rule__Required_Edge_Property.py # NEW
│   ├── collection/
│   │   ├── Dict__Categories__By_Id.py             # NEW (was By_Ref)
│   │   ├── Dict__Property_Names__By_Id.py         # NEW
│   │   ├── Dict__Property_Types__By_Id.py         # NEW
│   │   ├── Dict__Node_Properties.py               # NEW
│   │   ├── Dict__Edge_Properties.py               # NEW
│   │   ├── Dict__Projected_Properties.py          # NEW
│   │   ├── Dict__Category_Ids__By_Ref.py          # NEW
│   │   ├── Dict__Property_Name_Ids__By_Ref.py     # NEW
│   │   ├── Dict__Property_Type_Ids__By_Ref.py     # NEW
│   │   ├── Dict__Category_Refs__By_Node_Type_Ref.py  # NEW
│   │   ├── Dict__Category_Refs__By_Category_Ref.py   # NEW
│   │   ├── List__Rules__Required_Node_Property.py    # NEW
│   │   └── List__Rules__Required_Edge_Property.py    # NEW
│   └── projected/
│       └── Schema__Projected__Taxonomy.py         # NEW
```

### 11.2 Modified Files

```
osbot_utils/helpers/semantic_graphs/
├── schemas/
│   ├── taxonomy/
│   │   ├── Schema__Taxonomy.py                    # MODIFIED: root_id, categories by ID
│   │   └── Schema__Taxonomy__Category.py          # MODIFIED: ID-based
│   ├── ontology/
│   │   └── Schema__Ontology.py                    # MODIFIED: property_names, property_types
│   │   └── Schema__Ontology__Node_Type.py         # MODIFIED: category_id
│   ├── graph/
│   │   ├── Schema__Semantic_Graph__Node.py        # MODIFIED: properties
│   │   └── Schema__Semantic_Graph__Edge.py        # MODIFIED: properties
│   ├── rule/
│   │   └── Schema__Rule_Set.py                    # MODIFIED: required_*_properties
│   └── projected/
│       ├── Schema__Projected__Node.py             # MODIFIED: properties
│       ├── Schema__Projected__Edge.py             # MODIFIED: properties
│       ├── Schema__Projected__References.py       # MODIFIED: categories, property_names, property_types
│       └── Schema__Projected__Semantic_Graph.py   # MODIFIED: taxonomy section
├── projectors/
│   └── Semantic_Graph__Projector.py               # MODIFIED: properties, filtering, taxonomy
└── taxonomy/
    └── Taxonomy__Utils.py                         # MODIFIED: ID-based operations
```

---

## 12. Implementation Checklist

### Phase 1: Identifier Types

- [ ] Create `Property_Name_Id` extending `Semantic_Id`
- [ ] Create `Property_Name_Ref` extending `Semantic_Ref`
- [ ] Create `Property_Type_Id` extending `Semantic_Id`
- [ ] Create `Property_Type_Ref` extending `Semantic_Ref`

### Phase 2: Taxonomy Updates

- [ ] Update `Schema__Taxonomy__Category` to ID-based (category_id, parent_id, child_ids)
- [ ] Update `Schema__Taxonomy` (root_id, Dict__Categories__By_Id)
- [ ] Create `Dict__Categories__By_Id` collection
- [ ] Update `List__Category_Ids` if needed
- [ ] Update `Taxonomy__Utils` for ID-based operations
- [ ] Update `Taxonomy__Registry` for ID-based lookups

### Phase 3: Ontology Property System

- [ ] Create `Schema__Ontology__Property_Name`
- [ ] Create `Schema__Ontology__Property_Type`
- [ ] Create `Dict__Property_Names__By_Id`
- [ ] Create `Dict__Property_Types__By_Id`
- [ ] Update `Schema__Ontology` to include property_names, property_types
- [ ] Update `Schema__Ontology__Node_Type` to include category_id
- [ ] Update `Ontology__Utils` for property lookups

### Phase 4: Graph Properties

- [ ] Create `Dict__Node_Properties` (Property_Name_Id → Safe_Str__Text)
- [ ] Create `Dict__Edge_Properties` (Property_Name_Id → Safe_Str__Text)
- [ ] Update `Schema__Semantic_Graph__Node` to include properties
- [ ] Update `Schema__Semantic_Graph__Edge` to include properties
- [ ] Update `Semantic_Graph__Utils` for property queries
- [ ] Update `Semantic_Graph__Builder` for property support

### Phase 5: Rules Updates

- [ ] Create `Schema__Rule__Required_Node_Property`
- [ ] Create `Schema__Rule__Required_Edge_Property`
- [ ] Create `List__Rules__Required_Node_Property`
- [ ] Create `List__Rules__Required_Edge_Property`
- [ ] Update `Schema__Rule_Set` to include new rule types
- [ ] Update `Rule_Set__Utils` for property validation

### Phase 6: Projection Updates

- [ ] Create `Dict__Projected_Properties` (Property_Name_Ref → Safe_Str__Text)
- [ ] Update `Schema__Projected__Node` to include properties
- [ ] Update `Schema__Projected__Edge` to include properties
- [ ] Create `Dict__Category_Ids__By_Ref`
- [ ] Create `Dict__Property_Name_Ids__By_Ref`
- [ ] Create `Dict__Property_Type_Ids__By_Ref`
- [ ] Update `Schema__Projected__References` with new fields
- [ ] Create `Dict__Category_Refs__By_Node_Type_Ref`
- [ ] Create `Dict__Category_Refs__By_Category_Ref`
- [ ] Create `Schema__Projected__Taxonomy`
- [ ] Update `Schema__Projected__Semantic_Graph` with taxonomy section

### Phase 7: Projector Updates

- [ ] Add `build_property_name_id_to_ref()` method
- [ ] Update `project_nodes()` to project properties
- [ ] Update `project_edges()` to project properties
- [ ] Implement `build_references_filtered()` (bug fix)
- [ ] Implement `build_taxonomy_section()`
- [ ] Update main `project()` method

### Phase 8: Test Data & Tests

- [ ] Update `QA__Semantic_Graphs__Test_Data` for new structures
- [ ] Add property test data
- [ ] Add taxonomy integration tests
- [ ] Add projection filtering tests
- [ ] Update expected output constants

---

## 13. Success Criteria

### 13.1 Taxonomy Is Connected

```python
def test__node_type_links_to_category(self):
    ontology = create_ontology()
    taxonomy = create_taxonomy()
    
    method_type = ontology.node_types.get(method_type_id)
    category = taxonomy.categories.get(method_type.category_id)
    
    assert category.category_ref == 'callable'
```

### 13.2 Properties Work End-to-End

```python
def test__properties_project_correctly(self):
    # Schema node with properties
    node = Schema__Semantic_Graph__Node(
        node_id      = Node_Id('n001'),
        node_type_id = method_type_id,
        name         = Safe_Str__Id('my_method'),
        properties   = {
            Property_Name_Id('prop001'): Safe_Str__Text('42')
        }
    )
    
    # Project
    projected = projector.project(graph)
    
    # Properties use refs, not IDs
    projected_node = projected.projection.nodes[0]
    assert projected_node.properties.get(Property_Name_Ref('line_number')) == '42'
```

### 13.3 References Are Filtered

```python
def test__references_only_contain_used_refs(self):
    projected = projector.project(simple_graph)
    
    # Only refs used in projection
    assert len(projected.references.node_types) == 3    # Not full ontology
    assert 'function' not in projected.references.node_types  # Not used in graph
```

### 13.4 Taxonomy Section Enables Grouping

```python
def test__taxonomy_section_maps_types_to_categories(self):
    projected = projector.project(graph)
    
    # Can look up category for any node type
    method_category = projected.taxonomy.node_type_categories.get(Node_Type_Ref('method'))
    assert method_category == Category_Ref('callable')
    
    # Can walk category hierarchy
    callable_parent = projected.taxonomy.category_parents.get(Category_Ref('callable'))
    assert callable_parent == Category_Ref('code_element')
```

---

## 14. Summary

### 14.1 What This Achieves

| Requirement | How Addressed |
|-------------|---------------|
| **RDF/OWL alignment** | Node types, predicates, properties map to standards |
| **Taxonomy integration** | Node types link to categories via category_id |
| **ID-based integrity** | All cross-references use IDs |
| **Typed properties** | property_type_id with consumer-defined types |
| **Flexible validation** | Rules separate from definitions |
| **Human-readable projection** | Properties use refs, taxonomy section for grouping |
| **Minimal projection** | References filtered to only used refs |

### 14.2 The Complete Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              TAXONOMY                                        │
│  category_id, category_ref, parent_id, child_ids                            │
└───────────────────────────────────┬─────────────────────────────────────────┘
                                    │ category_id (FK)
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                              ONTOLOGY                                        │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐ ┌──────────────┐       │
│  │ Node Types   │ │ Predicates   │ │ Prop Names   │ │ Prop Types   │       │
│  │ +category_id │ │ +inverse_id  │ │ +type_id     │ │              │       │
│  └──────────────┘ └──────────────┘ └──────────────┘ └──────────────┘       │
│  ┌──────────────┐                                                           │
│  │ Edge Rules   │                                                           │
│  └──────────────┘                                                           │
└───────────────────────────────────┬─────────────────────────────────────────┘
                                    │ ontology_id (FK)
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                              GRAPH                                           │
│  ┌─────────────────────────────┐  ┌─────────────────────────────┐          │
│  │ Nodes                       │  │ Edges                       │          │
│  │ +node_type_id               │  │ +from_node_id               │          │
│  │ +properties (name_id→text)  │  │ +to_node_id                 │          │
│  └─────────────────────────────┘  │ +predicate_id               │          │
│                                   │ +properties (name_id→text)  │          │
│                                   └─────────────────────────────┘          │
└───────────────────────────────────┬─────────────────────────────────────────┘
                                    │ project()
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            PROJECTION                                        │
│  ┌───────────────┐ ┌───────────────┐ ┌───────────────┐ ┌───────────────┐   │
│  │ projection    │ │ references    │ │ taxonomy      │ │ sources       │   │
│  │ nodes (ref)   │ │ (filtered)    │ │ type→category │ │ provenance    │   │
│  │ edges (ref)   │ │ ref→id maps   │ │ cat→parent    │ │               │   │
│  │ +properties   │ │               │ │               │ │               │   │
│  └───────────────┘ └───────────────┘ └───────────────┘ └───────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

*End of Implementation Brief*
