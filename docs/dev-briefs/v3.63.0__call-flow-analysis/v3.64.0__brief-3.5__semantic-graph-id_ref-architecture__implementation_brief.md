# (Brief 3.5) Semantic Graph ID/Ref Architecture Clarification

**Version:** v3.64.0  
**Status:** Preparatory Refactoring  
**Target:** OSBot-Utils (`osbot_utils.type_safe.primitives` and `osbot_utils.helpers.semantic_graphs`)  
**Created:** January 2026  
**Prerequisites:** Brief 3 Complete - Semantic Graphs Framework  
**Enables:** Brief 4 - Call Flow as Semantic Graph  

---

## Executive Summary

This brief specifies a foundational refactoring to clarify the distinction between **Instance IDs** and **Semantic References** in the semantic graphs framework. The current implementation uses `*_Id` suffix for both concepts, causing architectural confusion.

**Key Changes:**

1. **Rename label/reference types:** `*_Id` → `*_Ref` (e.g., `Ontology_Id` → `Ontology_Ref`)
2. **Add deterministic ID creation:** `Obj_Id.from_seed(seed_string)` for URI/seed-based IDs
3. **Add ID provenance tracking:** `Schema__Id__Source` with sidecar pattern `{id}_source`
4. **Keep schemas pure data:** Complex ID logic lives in Registries/Builders, not schema `__init__`
5. **Update all semantic_graphs code** to use new naming conventions

**Why Now:** Brief 4 (Call Flow as Semantic Graph) will be significantly cleaner with this foundation in place. The current naming confusion would propagate into call flow code and make the architecture harder to understand.

---

## Part 1: The Problem

### 1.1 Current Naming Confusion

The current implementation uses `*_Id` suffix for two fundamentally different concepts:

```python
# GROUP A: These are string labels/references (NOT instance identifiers)
class Node_Type_Id(Semantic_Id): pass    # Values: "class", "method", "function"
class Ontology_Id(Semantic_Id): pass     # Values: "code_structure", "call_flow"
class Taxonomy_Id(Semantic_Id): pass     # Values: "call_flow_taxonomy"
class Category_Id(Semantic_Id): pass     # Values: "container", "callable"
class Rule_Set_Id(Semantic_Id): pass     # Values: "call_flow_rules"

# GROUP B: These ARE instance identifiers
class Node_Id(...): pass                 # Created via Node_Id(Obj_Id())
class Edge_Id(...): pass                 # Created via Edge_Id(Obj_Id())
class Graph_Id(...): pass                # Created via Graph_Id(Obj_Id())
```

### 1.2 Why This Matters

| Aspect | Group A (Labels) | Group B (Instance IDs) |
|--------|------------------|------------------------|
| **Source** | JSON config, dict keys | Created via `*_Id(Obj_Id())` |
| **Default value** | `''` (empty string) | `''` (empty string) |
| **Unique value** | From JSON/config | From `Obj_Id()` |
| **Uniqueness scope** | Per-ontology definition | Per-instance globally |
| **Human readable** | YES ("class", "method") | NO (random/sequential) |

### 1.3 Missing Capability: Deterministic IDs

Currently, instance IDs can only be:
- **Random:** `Node_Id(Obj_Id())` — different each time
- **Sequential (tests):** Inside `graph_deterministic_ids()` context

**Missing:** Deterministic IDs from a stable seed (e.g., URI, qualified name), enabling:
- Cross-session identity
- Semantic Web compatibility
- Reproducible ID generation

---

## Part 2: Solution Architecture

### 2.1 New Naming Convention

```
*_Id  = Instance identifier, unique per instance, created via *_Id(Obj_Id())
*_Ref = Reference by name, string-based, comes from JSON/config
```

### 2.2 Rename Mapping

| Current Name | New Name | Base Class | Purpose |
|--------------|----------|------------|---------|
| `Semantic_Id` | `Semantic_Ref` | `Safe_Str` | Base for string references |
| `Ontology_Id` | `Ontology_Ref` | `Semantic_Ref` | Reference ontology by name |
| `Taxonomy_Id` | `Taxonomy_Ref` | `Semantic_Ref` | Reference taxonomy by name |
| `Category_Id` | `Category_Ref` | `Semantic_Ref` | Reference category by name |
| `Node_Type_Id` | `Node_Type_Ref` | `Semantic_Ref` | Reference node type by name |
| `Rule_Set_Id` | `Rule_Set_Ref` | `Semantic_Ref` | Reference rule set by name |

**Keep unchanged:**
- `Node_Id` — Instance ID for graph nodes
- `Edge_Id` — Instance ID for graph edges
- `Graph_Id` — Instance ID for graphs
- `Safe_Str__Ontology__Verb` — Primitive with regex constraints

### 2.3 Semantic_Ref Regex

`Safe_Str` has regex `r'[^a-zA-Z0-9]'` which only allows alphanumeric characters. This is too restrictive for `Semantic_Ref` values which need:

- **Underscores:** `call_flow`, `code_structure`, `call_flow_taxonomy`
- **Hyphens:** `call-flow` style naming
- **Colons:** For CURIEs like `owl:Class`, `foaf:Person` (Semantic Web compact URIs)
- **Dots:** For namespacing like `v1.0.thing`

```python
import re
from osbot_utils.type_safe.primitives.core.Safe_Str import Safe_Str


class Semantic_Ref(Safe_Str):
    """Base class for semantic reference strings (human-readable labels from config)."""
    regex = re.compile(r'[^a-zA-Z0-9_:\-.]')      # Allow: alphanumeric, underscore, colon, hyphen, dot
```

This supports:
- `call_flow` ✓
- `owl:Class` ✓
- `foaf:Person` ✓
- `call-flow` ✓
- `v1.0.thing` ✓

### 2.4 Type Hierarchy After Refactoring

```
Safe_Str (core primitive, regex: [^a-zA-Z0-9])
│
├── Semantic_Ref                          # String references from config
│   │                                     # regex: [^a-zA-Z0-9_:\-.]
│   ├── Ontology_Ref                      # "call_flow", "code_structure"
│   ├── Taxonomy_Ref                      # "call_flow_taxonomy"
│   ├── Category_Ref                      # "container", "callable"
│   ├── Node_Type_Ref                     # "class", "method", "function"
│   └── Rule_Set_Ref                      # "call_flow_rules"
│
├── Safe_Str__Ontology__Verb              # Verb primitive: "calls", "contains"
│
└── Safe_Str__Id__Seed                    # Seed for deterministic IDs (URI, etc.)
                                          # regex: [^a-zA-Z0-9_:/.#\-@]

Obj_Id (auto-generating base)
│
├── Node_Id                               # Per-node instance ID
├── Edge_Id                               # Per-edge instance ID
└── Graph_Id                              # Per-graph instance ID
```

---

## Part 3: Deterministic ID Creation

### 3.1 The `from_seed()` Method

Add to `Obj_Id` class:

```python
import hashlib
from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id import Obj_Id


class Obj_Id(Safe_Id):
    
    @classmethod
    def from_seed(cls, seed: str) -> 'Obj_Id':
        """Create deterministic ID from seed string.
        
        Same seed string always produces same ID.
        Enables:
        - Cross-session identity (same seed → same ID)
        - Semantic Web compatibility (URI as seed)
        - Reproducible ID generation
        
        Args:
            seed: Seed string (URI, qualified name, any stable identifier)
            
        Returns:
            Deterministic Obj_Id derived from seed
        """
        if not seed:
            raise ValueError("Seed string cannot be empty")
        hash_bytes = hashlib.sha256(seed.encode('utf-8')).digest()
        deterministic_id = hash_bytes.hex()[:8]                      # Match Obj_Id format
        return cls(deterministic_id)
```

### 3.2 ID Creation Modes

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         ID CREATION MODES                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  MODE 1: Random                                                          │
│  ─────────────────                                                       │
│  node_id = Node_Id(Obj_Id())                                             │
│  → Random unique ID each call                                            │
│  → Use for: runtime instances, session-specific entities                 │
│                                                                          │
│  MODE 2: Deterministic from seed (NEW)                                   │
│  ─────────────────────────────────────                                   │
│  ontology_id = Ontology_Id(Obj_Id.from_seed(uri))                        │
│  → Same seed → same ID, always                                           │
│  → Use for: entities with stable identity (URIs, qualified names)        │
│                                                                          │
│  MODE 3: Sequential (tests)                                              │
│  ──────────────────────────                                              │
│  with graph_deterministic_ids():                                         │
│      node_id = Node_Id(Obj_Id())  # → 'c0000001', 'c0000002', ...        │
│  → Use for: deterministic test assertions                                │
│                                                                          │
│  MODE 4: Explicit                                                        │
│  ────────────────                                                        │
│  node_id = Node_Id('existing-id-from-storage')                           │
│  → Use for: loading from persisted data                                  │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Part 4: ID Provenance Tracking

### 4.1 Source Type Enum

**File:** `osbot_utils/type_safe/primitives/domains/identifiers/enums/Enum__Id__Source_Type.py`

```python
from enum import Enum


class Enum__Id__Source_Type(str, Enum):
    DETERMINISTIC = 'deterministic'                  # From seed string (URI, etc.)
    RANDOM        = 'random'                         # Via Obj_Id()
    SEQUENTIAL    = 'sequential'                     # Via graph_deterministic_ids context
    EXPLICIT      = 'explicit'                       # Directly assigned (loaded from storage)
```

### 4.2 Seed Primitive

**File:** `osbot_utils/type_safe/primitives/domains/identifiers/safe_str/Safe_Str__Id__Seed.py`

```python
import re
from osbot_utils.type_safe.primitives.core.Safe_Str import Safe_Str


class Safe_Str__Id__Seed(Safe_Str):                  # Seed string for deterministic IDs
    regex = re.compile(r'[^a-zA-Z0-9_:/.#\-@]')      # Allow URI characters
```

Note: The regex is permissive to support URIs like `http://www.w3.org/2002/07/owl#Class`.

### 4.3 ID Source Schema

**File:** `osbot_utils/type_safe/primitives/domains/identifiers/schemas/Schema__Id__Source.py`

```python
from osbot_utils.type_safe.Type_Safe                                                         import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.enums.Enum__Id__Source_Type        import Enum__Id__Source_Type
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Id__Seed        import Safe_Str__Id__Seed


class Schema__Id__Source(Type_Safe):                 # Provenance information for an ID
    source_type : Enum__Id__Source_Type              # How the ID was created
    seed        : Safe_Str__Id__Seed         = None  # The seed string (only for DETERMINISTIC)
```

### 4.4 Domain-Specific Source Subclasses

```python
# In semantic_graphs/schemas/identifier/

class Ontology_Id__Source(Schema__Id__Source):       # Source for Ontology_Id
    pass

class Node_Id__Source(Schema__Id__Source):           # Source for Node_Id
    pass

class Edge_Id__Source(Schema__Id__Source):           # Source for Edge_Id
    pass

class Graph_Id__Source(Schema__Id__Source):          # Source for Graph_Id
    pass
```

### 4.5 Sidecar Pattern Usage

```python
class Schema__Ontology(Type_Safe):
    ontology_id        : Ontology_Id                 # The compact ID
    ontology_id_source : Ontology_Id__Source = None  # How it was created (optional)
    ontology_ref       : Ontology_Ref                # Human label
    ...
```

**Key points:**
- Naming convention: `{id_field}_source`
- Default to `None` — only populate when provenance matters
- `seed` field is optional — only set for `DETERMINISTIC` source type
- No overhead when not needed

### 4.6 Two Storage Modes for Seed

| Mode | `*_id_source.seed` | External Cache | Use Case |
|------|-------------------|----------------|----------|
| **Inline** | Contains seed | Not used | Self-contained documents, full provenance |
| **External** | `None` | Holds mapping | Lightweight schemas, centralized provenance |

---

## Part 5: Version Captured in Seed (Design Decision)

### 5.1 The Redundancy Problem

If we have both a `seed` (URI) and a `version` field, we create redundancy:

```python
# REDUNDANT - version appears twice
class Schema__Ontology(Type_Safe):
    ontology_id        : Ontology_Id
    ontology_id_source : Ontology_Id__Source = None
    ontology_ref       : Ontology_Ref
    version            : Safe_Str__Version           # "1.0.0" ← REDUNDANT!
    ...

# Where seed might be:
seed = "http://osbot.dev/ontologies/call_flow/1.0.0"  # ← Version already here!
```

### 5.2 Version as Part of Identity

In URI-based identity (Semantic Web pattern), **version is part of the identifier**:

```
http://osbot.dev/ontologies/call_flow/1.0     → Version 1.0
http://osbot.dev/ontologies/call_flow/2.0.1   → Version 2.0.1 (DIFFERENT ID!)
```

This means:
- **Different version = different seed = different ID**
- **No separate `version` field needed**
- **Simpler schemas with fewer fields**
- **Single source of truth** — the seed contains everything

### 5.3 Extracting Version When Needed

If version needs to be extracted programmatically:

```python
# From seed
seed = ontology.ontology_id_source.seed              # "http://osbot.dev/ontologies/call_flow/1.0"
version = seed.split('/')[-1]                        # "1.0"

# Or with a helper method on Schema__Id__Source
class Schema__Id__Source(Type_Safe):
    source_type : Enum__Id__Source_Type
    seed        : Safe_Str__Id__Seed = None
    
    def extract_version(self) -> str:
        """Extract version from seed (assumes URI pattern ending in /version)."""
        if self.seed:
            return str(self.seed).split('/')[-1]
        return None
```

### 5.4 Non-URI Seeds

For seeds that aren't URIs, the same principle applies — version can be part of the seed:

```python
seed = "call_flow:1.0.0"                             # Version in seed
seed = "mymodule.MyClass@v2"                         # Version in qualified name
```

### 5.5 Benefits

| Aspect | With Separate Version | Version in Seed |
|--------|----------------------|-----------------|
| **Fields** | More fields | Fewer fields |
| **Sync issues** | Version could mismatch seed | Single source of truth |
| **Identity** | Ambiguous (same ref, different version?) | Clear (different seed = different entity) |
| **Semantic Web** | Non-standard | Standard URI pattern |

---

## Part 6: Schema Updates (Pure Data)

**Critical Principle:** Schemas are pure data containers. Complex ID generation logic belongs in Registries/Builders, NOT in schema `__init__` methods.

### 6.1 Schema__Semantic_Graph

```python
class Schema__Semantic_Graph(Type_Safe):
    graph_id          : Graph_Id
    graph_id_source   : Graph_Id__Source = None      # Optional provenance
    ontology_ref      : Ontology_Ref                 # Reference by name
    rule_set_ref      : Rule_Set_Ref                 # Reference by name
    nodes             : Dict__Nodes__By_Id           # Typed collection
    edges             : List__Edges                  # Typed collection
    
    # NO complex __init__ - schema is pure data
```

### 6.2 Schema__Semantic_Graph__Node

```python
class Schema__Semantic_Graph__Node(Type_Safe):
    node_id        : Node_Id
    node_id_source : Node_Id__Source = None          # Optional provenance
    node_type      : Node_Type_Ref                   # Reference to type name
    name           : Safe_Str__Id
    line_number    : Safe_UInt
    
    # NO complex __init__ - schema is pure data
```

### 6.3 Schema__Semantic_Graph__Edge

```python
class Schema__Semantic_Graph__Edge(Type_Safe):
    edge_id        : Edge_Id
    edge_id_source : Edge_Id__Source = None          # Optional provenance
    from_node      : Node_Id
    verb           : Safe_Str__Ontology__Verb
    to_node        : Node_Id
    line_number    : Safe_UInt
    
    # NO complex __init__ - schema is pure data
```

### 6.4 Schema__Ontology

```python
class Schema__Ontology(Type_Safe):
    ontology_id        : Ontology_Id
    ontology_id_source : Ontology_Id__Source = None
    ontology_ref       : Ontology_Ref                # Human-readable name
    description        : Safe_Str__Text
    taxonomy_ref       : Taxonomy_Ref
    node_types         : Dict__Node_Types__By_Ref
    
    # NO complex __init__ - ID creation handled by Registry
    # NO version field - version is captured in seed/URI
```

---

## Part 7: Registry Factory Methods

ID creation logic lives in Registries with explicit factory methods:

### 7.1 Ontology__Registry

```python
class Ontology__Registry(Type_Safe):
    by_id  : Dict__Ontologies__By_Id                 # Ontology_Id → Schema__Ontology
    by_ref : Dict__Ontology_Ids__By_Ref              # Ontology_Ref → Ontology_Id (xref)
    
    def create_with__random_id(self, ontology_ref : Ontology_Ref,
                                     description  : Safe_Str__Text    = None,
                                     taxonomy_ref : Taxonomy_Ref      = None,
                                     node_types   : Dict__Node_Types__By_Ref = None
                              ) -> Schema__Ontology:
        """Create ontology with random ID."""
        ontology_id = Ontology_Id(Obj_Id())
        ontology = Schema__Ontology(
            ontology_id  = ontology_id                                               ,
            ontology_ref = ontology_ref                                              ,
            description  = description                                               ,
            taxonomy_ref = taxonomy_ref                                              ,
            node_types   = node_types or Dict__Node_Types__By_Ref()                  ,
        )
        # ontology_id_source is None - no provenance tracked for random
        self.register(ontology)
        return ontology
    
    def create_with__deterministic_id(self, ontology_ref : Ontology_Ref,
                                            seed         : Safe_Str__Id__Seed,
                                            description  : Safe_Str__Text    = None,
                                            taxonomy_ref : Taxonomy_Ref      = None,
                                            node_types   : Dict__Node_Types__By_Ref = None
                                      ) -> Schema__Ontology:
        """Create ontology with deterministic ID from seed (inline source).
        
        Note: Version should be part of the seed (e.g., URI ending in /1.0.0).
        """
        ontology_id = Ontology_Id(Obj_Id.from_seed(str(seed)))
        ontology = Schema__Ontology(
            ontology_id        = ontology_id                                         ,
            ontology_id_source = Ontology_Id__Source(
                source_type = Enum__Id__Source_Type.DETERMINISTIC                    ,
                seed        = seed                                                   ,
            )                                                                        ,
            ontology_ref       = ontology_ref                                        ,
            description        = description                                         ,
            taxonomy_ref       = taxonomy_ref                                        ,
            node_types         = node_types or Dict__Node_Types__By_Ref()            ,
        )
        self.register(ontology)
        return ontology
    
    def create_with__explicit_id(self, ontology_ref        : Ontology_Ref,
                                       ontology_id         : Ontology_Id,
                                       ontology_id_source  : Ontology_Id__Source = None,
                                       description         : Safe_Str__Text      = None,
                                       taxonomy_ref        : Taxonomy_Ref        = None,
                                       node_types          : Dict__Node_Types__By_Ref = None
                                 ) -> Schema__Ontology:
        """Create ontology with caller-provided ID and optional source."""
        ontology = Schema__Ontology(
            ontology_id        = ontology_id                                         ,
            ontology_id_source = ontology_id_source                                  ,
            ontology_ref       = ontology_ref                                        ,
            description        = description                                         ,
            taxonomy_ref       = taxonomy_ref                                        ,
            node_types         = node_types or Dict__Node_Types__By_Ref()            ,
        )
        self.register(ontology)
        return ontology
    
    def register(self, ontology: Schema__Ontology):
        """Register ontology in lookup indexes."""
        self.by_id[ontology.ontology_id] = ontology
        self.by_ref[ontology.ontology_ref] = ontology.ontology_id
```

### 7.2 Loading from JSON

Loading is always pure deserialization — no ID magic:

```python
# Loading from JSON is ALWAYS just deserialization
ontology = Schema__Ontology.from_json(data)

# The JSON contains everything needed:
# - ontology_id: the ID (must be in JSON)
# - ontology_id_source: provenance (if inline mode was used)
# - ontology_ref: the human-readable name
```

This ensures roundtrips always work:

```python
original = Schema__Ontology(ontology_id=..., ontology_ref=..., ...)
json_data = original.json()
restored = Schema__Ontology.from_json(json_data)
assert original.ontology_id == restored.ontology_id  # ✓ Always works
```

---

## Part 8: External Seed Cache (Optional)

For cases where seed storage should be centralized (not inline in schemas), use a separate cache:

### 8.1 Id__Seed__Cache

```python
class Dict__Seeds__By_Id(Type_Safe__Dict):
    expected_key_type   = Obj_Id
    expected_value_type = Safe_Str__Id__Seed

class Dict__Ids__By_Seed(Type_Safe__Dict):
    expected_key_type   = Safe_Str__Id__Seed
    expected_value_type = Obj_Id


class Id__Seed__Cache(Type_Safe):
    """External cache for ID ↔ seed mappings."""
    seeds_by_id : Dict__Seeds__By_Id                 # id → seed
    ids_by_seed : Dict__Ids__By_Seed                 # seed → id (reverse lookup)
    
    def register(self, obj_id: Obj_Id, seed: Safe_Str__Id__Seed):
        """Register an ID ↔ seed mapping."""
        self.seeds_by_id[obj_id] = seed
        self.ids_by_seed[seed]   = obj_id
    
    def get_or_create_id(self, seed: Safe_Str__Id__Seed) -> Obj_Id:
        """Get existing ID for seed, or create deterministically."""
        existing = self.ids_by_seed.get(seed)
        if existing:
            return existing
        new_id = Obj_Id.from_seed(str(seed))
        self.register(new_id, seed)
        return new_id
    
    def get_seed(self, obj_id: Obj_Id) -> Safe_Str__Id__Seed:
        """Get seed for an ID."""
        return self.seeds_by_id.get(obj_id)
```

### 8.2 Semantic Web ID Cache

Pre-computed cache for well-known Semantic Web URIs:

```python
class Semantic_Web__Id__Cache(Id__Seed__Cache):
    """Pre-computed ID mappings for well-known Semantic Web URIs."""
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._register_well_known_uris()
    
    def _register_well_known_uris(self):
        """Pre-populate common Semantic Web URIs."""
        well_known = [
            "http://www.w3.org/2002/07/owl#Class"                                    ,
            "http://www.w3.org/2002/07/owl#ObjectProperty"                           ,
            "http://www.w3.org/2002/07/owl#DatatypeProperty"                         ,
            "http://www.w3.org/2000/01/rdf-schema#label"                             ,
            "http://www.w3.org/2000/01/rdf-schema#comment"                           ,
            "http://xmlns.com/foaf/0.1/Person"                                       ,
            "http://xmlns.com/foaf/0.1/name"                                         ,
        ]
        for uri in well_known:
            seed = Safe_Str__Id__Seed(uri)
            self.get_or_create_id(seed)                                              # Registers it
```

### 8.3 Using External Cache with Registry

The cache is external to the registry — caller handles the lookup:

```python
# External cache usage
semantic_cache = Semantic_Web__Id__Cache()

# Caller gets/creates the ID from cache
uri = Safe_Str__Id__Seed("http://www.w3.org/2002/07/owl#Class")
ontology_id = Ontology_Id(semantic_cache.get_or_create_id(uri))

# Then uses explicit_id method (source tracking is optional)
registry.create_with__explicit_id(
    ontology_ref = Ontology_Ref('owl'),
    ontology_id  = ontology_id,
    # ontology_id_source = None (seed is in external cache)
)

# OR with inline source tracking
registry.create_with__explicit_id(
    ontology_ref       = Ontology_Ref('owl'),
    ontology_id        = ontology_id,
    ontology_id_source = Ontology_Id__Source(
        source_type = Enum__Id__Source_Type.DETERMINISTIC,
        seed        = uri,
    ),
)
```

---

## Part 9: Collection Subclass Updates

### 9.1 Rename Mapping

| Current Name | New Name |
|--------------|----------|
| `Dict__Node_Types__By_Id` | `Dict__Node_Types__By_Ref` |
| `Dict__Ontologies__By_Id` | `Dict__Ontologies__By_Ref` |
| `Dict__Taxonomies__By_Id` | `Dict__Taxonomies__By_Ref` |
| `Dict__Categories__By_Id` | `Dict__Categories__By_Ref` |
| `List__Node_Type_Ids` | `List__Node_Type_Refs` |

### 9.2 Updated Definitions

```python
class Dict__Node_Types__By_Ref(Type_Safe__Dict):
    expected_key_type   = Node_Type_Ref
    expected_value_type = Schema__Ontology__Node_Type

class Dict__Ontologies__By_Ref(Type_Safe__Dict):
    expected_key_type   = Ontology_Ref
    expected_value_type = Schema__Ontology

class List__Node_Type_Refs(Type_Safe__List):
    expected_type = Node_Type_Ref
```

### 9.3 New Collections for ID Lookups

```python
class Dict__Ontologies__By_Id(Type_Safe__Dict):
    expected_key_type   = Ontology_Id
    expected_value_type = Schema__Ontology

class Dict__Ontology_Ids__By_Ref(Type_Safe__Dict):
    expected_key_type   = Ontology_Ref
    expected_value_type = Ontology_Id
```

---

## Part 10: File Structure

### 10.1 New Files in `osbot_utils/type_safe/primitives/`

```
osbot_utils/type_safe/primitives/domains/identifiers/
├── Obj_Id.py                                        # Add from_seed() method
├── enums/
│   └── Enum__Id__Source_Type.py                     # NEW
├── safe_str/
│   └── Safe_Str__Id__Seed.py                        # NEW (permissive regex for URIs)
└── schemas/
    └── Schema__Id__Source.py                        # NEW
```

### 10.2 Renamed Files in `osbot_utils/helpers/semantic_graphs/`

```
osbot_utils/helpers/semantic_graphs/schemas/
├── identifier/
│   ├── Semantic_Id.py        → Semantic_Ref.py
│   ├── Ontology_Id.py        → Ontology_Ref.py
│   ├── Taxonomy_Id.py        → Taxonomy_Ref.py
│   ├── Category_Id.py        → Category_Ref.py
│   ├── Node_Type_Id.py       → Node_Type_Ref.py
│   ├── Rule_Set_Id.py        → Rule_Set_Ref.py
│   ├── Ontology_Id__Source.py                       # NEW
│   ├── Node_Id__Source.py                           # NEW
│   ├── Edge_Id__Source.py                           # NEW
│   └── Graph_Id__Source.py                          # NEW
├── collection/
│   ├── Dict__Node_Types__By_Id.py    → Dict__Node_Types__By_Ref.py
│   ├── Dict__Ontologies__By_Id.py    → Dict__Ontologies__By_Ref.py
│   ├── Dict__Ontologies__By_Id.py                   # NEW (for registry by_id)
│   ├── Dict__Ontology_Ids__By_Ref.py                # NEW (for registry xref)
│   └── List__Node_Type_Ids.py        → List__Node_Type_Refs.py
├── graph/
│   ├── Schema__Semantic_Graph.py                    # Update annotations
│   ├── Schema__Semantic_Graph__Node.py              # Update annotations
│   └── Schema__Semantic_Graph__Edge.py              # Update annotations
├── ontology/
│   └── Schema__Ontology*.py                         # Update annotations (remove version)
├── taxonomy/
│   └── Schema__Taxonomy*.py                         # Update annotations
└── rule/
    └── Schema__Rule*.py                             # Update annotations
```

### 10.3 New Cache Files

```
osbot_utils/helpers/semantic_graphs/cache/
├── __init__.py
├── Id__Seed__Cache.py                               # NEW
└── Semantic_Web__Id__Cache.py                       # NEW
```

---

## Part 11: Implementation Checklist

### Phase 1: Core Primitives (osbot_utils/type_safe/primitives/)

- [ ] Add `from_seed()` method to `Obj_Id`
- [ ] Create `Enum__Id__Source_Type` enum
- [ ] Create `Safe_Str__Id__Seed` primitive (with permissive regex)
- [ ] Create `Schema__Id__Source` schema (with optional `seed` field)
- [ ] Add tests for `from_seed()` determinism
- [ ] Add tests for `Schema__Id__Source`

### Phase 2: Identifier Renames (semantic_graphs/schemas/identifier/)

- [ ] Rename `Semantic_Id` → `Semantic_Ref` (with new regex `[^a-zA-Z0-9_:\-.]`)
- [ ] Rename `Ontology_Id` → `Ontology_Ref`
- [ ] Rename `Taxonomy_Id` → `Taxonomy_Ref`
- [ ] Rename `Category_Id` → `Category_Ref`
- [ ] Rename `Node_Type_Id` → `Node_Type_Ref`
- [ ] Rename `Rule_Set_Id` → `Rule_Set_Ref`
- [ ] Create `Ontology_Id__Source`, `Node_Id__Source`, `Edge_Id__Source`, `Graph_Id__Source`

### Phase 3: Collection Renames (semantic_graphs/schemas/collection/)

- [ ] Rename `Dict__Node_Types__By_Id` → `Dict__Node_Types__By_Ref`
- [ ] Rename `Dict__Ontologies__By_Id` → `Dict__Ontologies__By_Ref`
- [ ] Rename `Dict__Taxonomies__By_Id` → `Dict__Taxonomies__By_Ref`
- [ ] Rename `Dict__Categories__By_Id` → `Dict__Categories__By_Ref`
- [ ] Rename `List__Node_Type_Ids` → `List__Node_Type_Refs`
- [ ] Create new ID-based collections (`Dict__Ontologies__By_Id`, `Dict__Ontology_Ids__By_Ref`)

### Phase 4: Schema Updates (semantic_graphs/schemas/)

- [ ] Update `Schema__Semantic_Graph` — add sidecar, update refs, NO complex __init__
- [ ] Update `Schema__Semantic_Graph__Node` — add sidecar, update refs
- [ ] Update `Schema__Semantic_Graph__Edge` — add sidecar
- [ ] Update `Schema__Ontology` — add sidecar, update refs, remove version field, NO complex __init__
- [ ] Update `Schema__Ontology__Node_Type` — update refs
- [ ] Update `Schema__Ontology__Relationship` — update refs
- [ ] Update `Schema__Taxonomy` — add sidecar, update refs, remove version field if present
- [ ] Update `Schema__Taxonomy__Category` — update refs
- [ ] Update `Schema__Rule_Set` — add sidecar, update refs, remove version field if present

### Phase 5: Registry Updates (semantic_graphs/)

- [ ] Update `Ontology__Registry` — add factory methods, update type annotations
- [ ] Update `Taxonomy__Registry` — add factory methods, update type annotations
- [ ] Update `Rule__Engine` — update type annotations
- [ ] Update `Semantic_Graph__Builder` — update type annotations
- [ ] Update `Semantic_Graph__Validator` — update type annotations

### Phase 6: Cache Implementation (semantic_graphs/cache/)

- [ ] Create `Id__Seed__Cache`
- [ ] Create `Semantic_Web__Id__Cache`
- [ ] Add tests for cache functionality

### Phase 7: Test Updates

- [ ] Update all identifier tests for new names
- [ ] Update all collection tests for new names
- [ ] Update all schema tests for sidecar fields
- [ ] Add tests for deterministic ID creation via `from_seed()`
- [ ] Add tests for ID source tracking
- [ ] Add tests for registry factory methods

### Phase 8: Code Structure Analyzer

- [ ] Update `osbot_utils/helpers/python_call_flow/code_structure/` to use `*_Ref` types

---

## Part 12: Usage Examples

### 12.1 Creating Ontology with Random ID

```python
registry = Ontology__Registry()

ontology = registry.create_with__random_id(
    ontology_ref = Ontology_Ref('call_flow'),
    description  = Safe_Str__Text('Python call flow analysis'),
)

# ontology.ontology_id = random ID
# ontology.ontology_id_source = None (no provenance tracked)
```

### 12.2 Creating Ontology with Deterministic ID (Inline Source)

```python
registry = Ontology__Registry()

# Version is part of the URI
uri = Safe_Str__Id__Seed('http://osbot.dev/ontologies/call_flow/1.0.0')
ontology = registry.create_with__deterministic_id(
    ontology_ref = Ontology_Ref('call_flow'),
    seed         = uri,
)

# ontology.ontology_id = deterministic ID derived from URI
# ontology.ontology_id_source.source_type = DETERMINISTIC
# ontology.ontology_id_source.seed = 'http://osbot.dev/ontologies/call_flow/1.0.0'
# Version (1.0.0) can be extracted from seed if needed
```

### 12.3 Creating Ontology with Explicit ID (External Source)

```python
# Using external cache
semantic_cache = Semantic_Web__Id__Cache()
uri = Safe_Str__Id__Seed('http://osbot.dev/ontologies/call_flow/1.0.0')
ontology_id = Ontology_Id(semantic_cache.get_or_create_id(uri))

# Create with explicit ID
registry = Ontology__Registry()
ontology = registry.create_with__explicit_id(
    ontology_ref = Ontology_Ref('call_flow'),
    ontology_id  = ontology_id,
    # ontology_id_source = None (seed is in external cache)
)
```

### 12.4 Cross-Session Identity

```python
# Session 1
uri = "http://osbot.dev/ontologies/call_flow/1.0.0"
ontology_id_1 = Ontology_Id(Obj_Id.from_seed(uri))
print(ontology_id_1)  # → "a3f2b8c1"

# Session 2 (different process, different day)
ontology_id_2 = Ontology_Id(Obj_Id.from_seed(uri))
print(ontology_id_2)  # → "a3f2b8c1" (SAME!)

assert ontology_id_1 == ontology_id_2  # ✓ Always passes
```

### 12.5 Loading from JSON (Pure Deserialization)

```python
# JSON contains all necessary data (no separate version field)
json_data = {
    "ontology_id": "a3f2b8c1",
    "ontology_id_source": {
        "source_type": "deterministic",
        "seed": "http://osbot.dev/ontologies/call_flow/1.0.0"   # Version in seed
    },
    "ontology_ref": "call_flow",
    ...
}

# Loading is ALWAYS just deserialization
ontology = Schema__Ontology.from_json(json_data)

# Roundtrip works
assert ontology.json() == json_data  # ✓

# Extract version from seed if needed
version = ontology.ontology_id_source.seed.split('/')[-1]  # "1.0.0"
```

### 12.6 Node with Deterministic ID from Qualified Name

```python
# For code analysis, use qualified name as seed
qualified_name = "mymodule.MyClass.my_method"
node_id = Node_Id(Obj_Id.from_seed(qualified_name))

node = Schema__Semantic_Graph__Node(
    node_id        = node_id,
    node_id_source = Node_Id__Source(
        source_type = Enum__Id__Source_Type.DETERMINISTIC,
        seed        = Safe_Str__Id__Seed(qualified_name),
    ),
    node_type      = Node_Type_Ref('method'),
    name           = Safe_Str__Id('my_method'),
    line_number    = Safe_UInt(42),
)

# Same qualified name → same node_id, across sessions
```

---

## Part 13: Success Criteria

### Minimum Viable Product (MVP)

- [ ] All `*_Id` → `*_Ref` renames complete
- [ ] `Obj_Id.from_seed()` implemented and tested
- [ ] `Schema__Id__Source` implemented with optional `seed`
- [ ] All semantic_graphs tests pass
- [ ] No regressions in functionality

### Full Implementation

- [ ] All Phase 1-8 checklist items complete
- [ ] Sidecar pattern (`*_source`) on all ID fields in schemas
- [ ] Registry factory methods for all creation patterns
- [ ] `Id__Seed__Cache` and `Semantic_Web__Id__Cache` implemented
- [ ] Documentation updated

### Verification

```python
def test__naming_clarity(self):
    """After refactoring, naming is self-documenting."""
    
    # References are clearly references (human labels)
    node_type = Node_Type_Ref('class')               # Obviously a reference
    ontology_ref = Ontology_Ref('call_flow')         # Obviously a reference
    
    # IDs are clearly instance IDs
    node_id = Node_Id(Obj_Id())                      # Obviously an instance ID
    
    # Deterministic IDs work
    uri = "http://example.com/ontology"
    id_1 = Ontology_Id(Obj_Id.from_seed(uri))
    id_2 = Ontology_Id(Obj_Id.from_seed(uri))
    assert id_1 == id_2                              # Same seed → same ID

def test__semantic_ref_regex(self):
    """Semantic_Ref allows underscores, colons, hyphens, dots."""
    
    # All valid Semantic_Ref values
    assert Ontology_Ref('call_flow')                 # Underscore ✓
    assert Ontology_Ref('owl:Class')                 # Colon (CURIE) ✓
    assert Ontology_Ref('call-flow')                 # Hyphen ✓
    assert Ontology_Ref('v1.0.thing')                # Dot ✓
    assert Node_Type_Ref('foaf:Person')              # Semantic Web ✓

def test__roundtrip(self):
    """JSON roundtrips work correctly."""
    original = Schema__Ontology(
        ontology_id        = Ontology_Id(Obj_Id.from_seed('http://example.com/test/1.0')),
        ontology_id_source = Ontology_Id__Source(
            source_type = Enum__Id__Source_Type.DETERMINISTIC,
            seed        = Safe_Str__Id__Seed('http://example.com/test/1.0'),
        ),
        ontology_ref       = Ontology_Ref('test'),
    )
    restored = Schema__Ontology.from_json(original.json())
    assert original.ontology_id == restored.ontology_id
    assert original.ontology_id_source.seed == restored.ontology_id_source.seed
    
    # Extract version from seed
    version = str(original.ontology_id_source.seed).split('/')[-1]
    assert version == '1.0'
```

---

## Part 14: Migration Notes

### 14.1 No External Impact

Since no external code is currently using the semantic_graphs framework (per project notes), this refactoring has no backward compatibility concerns.

### 14.2 IDE Support

After renaming, IDEs will show clear type distinctions:
- `node_type: Node_Type_Ref` — obviously a reference/label
- `node_id: Node_Id` — obviously an instance ID

### 14.3 Grep-Friendly

```bash
# Find all references
grep -r "Ontology_Ref" osbot_utils/

# Find all instance IDs
grep -r "Ontology_Id" osbot_utils/

# Find all ID source tracking
grep -r "_source" osbot_utils/helpers/semantic_graphs/

# Find all factory methods
grep -r "create_with__" osbot_utils/helpers/semantic_graphs/
```

---

*End of Implementation Brief*