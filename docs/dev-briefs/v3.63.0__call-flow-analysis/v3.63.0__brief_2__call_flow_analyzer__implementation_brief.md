# (Brief 2) Call Flow Analyzer - Implementation Brief

**Version:** v3.63.0  
**Status:** Phase 1 Implementation  
**Target:** OSBot-Utils (`osbot_utils.helpers.python_call_flow`)  
**Created:** December 2024

---

## Executive Summary

This document provides a complete specification for implementing a Python static call flow analyzer that extracts call graphs from Python source code. The tool analyzes classes and functions to discover method calls, producing a graph structure compatible with MGraph-DB for visualization and querying.

**Primary Use Case:** Given a Python class like `Call_Flow__Analyzer`, produce a graph showing:
- What methods exist in the class
- Which methods call which other methods
- What external dependencies are referenced
- The structural containment relationships (class contains methods)

**Key Deliverable:** A working analyzer that can analyze itself (meta-analysis), demonstrating correctness through self-reference.

---

## Part 1: Why This Tool Exists

### The Problem

Understanding Python codebases is difficult because:

1. **Call relationships are implicit** - You must read every method to understand what calls what
2. **IDE tools show callers/callees but not the full graph** - Missing the big picture
3. **Refactoring is risky** - Without knowing the full call chain, changes have unexpected impacts
4. **Documentation gets stale** - Static diagrams don't update with code changes

### The Solution

A **deterministic, code-driven** call flow analyzer that:

1. **Parses Python AST** to extract call relationships
2. **Produces a graph** with nodes (classes, methods, functions) and edges (contains, calls)
3. **Integrates with MGraph-DB** for visualization and querying
4. **Is versionable** - Graph output can be diffed alongside code changes

### Why Not Dynamic Analysis?

Dynamic analysis (tracing at runtime) captures actual execution paths but:
- Requires running the code
- Only captures exercised paths
- Misses error handling and conditional branches
- Cannot be run in CI/CD easily

Static analysis captures **all possible** call paths from source code alone.

---

## Part 2: Core Principles

### Principle 1: Everything is a Node

Every entity in the graph gets a unique `Node_Id`:
- Classes → Node_Id
- Methods → Node_Id
- Functions → Node_Id
- External references → Node_Id (with `is_external=True`)

This enables MGraph-DB compatibility where all entities are first-class graph nodes.

### Principle 2: Relationships are Typed Edges

A single unified graph with edge types distinguishing:
- **Structural relationships:** `CONTAINS` (class contains method)
- **Behavioral relationships:** `CALLS`, `SELF`, `CHAIN`

Query by filtering edge types, not by maintaining separate graphs.

### Principle 3: Lazy Discovery from Entry Point

Only capture entities **reachable from the entry point**. Do not scan entire codebases.

```
analyze(MyClass)
  → Discover MyClass (entry)
  → Discover methods in MyClass
  → Discover calls FROM those methods
  → Recursively follow (within scope limits)
```

This keeps graphs focused and manageable.

### Principle 4: Scope Control

Not everything should be followed:
- Standard library? Usually no.
- External packages? Usually no.
- Specific modules? Configurable allow/block lists.

The user controls traversal boundaries.

### Principle 5: Depth Represents Call Distance

```
Entry point (class)     → depth=0
Contained methods       → depth=1
Methods called by those → depth=2
And so on...
```

Depth is **call depth**, not structural nesting.

### Principle 6: Type Safety Throughout

Use OSBot-Utils Type_Safe patterns:
- All schemas extend `Type_Safe`
- Use domain-specific Safe_* primitives
- Create new primitives when needed (not generic `List[str]`)

### Principle 7: Leverage Existing OSBot-Utils Capabilities

Use the AST helpers already in OSBot-Utils:
- `Ast_Module` - Parse source from object/file/string
- `Ast_Visit` - Visitor pattern with capture modes
- `Ast_Call` - Wrapper for call nodes with resolution helpers

Do not use raw `ast` module directly.

---

## Part 3: Architecture Overview

### Graph Structure (ASCII Diagram)

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           UNIFIED CALL FLOW GRAPH                                │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  NODES (by type)                           EDGES (by type)                       │
│  ══════════════                            ═══════════════                        │
│                                                                                  │
│  ┌─────────────────┐                       CONTAINS (structural)                 │
│  │ CLASS           │                       ─────────────────────                 │
│  │ node_type=class │──────CONTAINS────────►  Class ──► Method                   │
│  │ is_entry=True   │                                                            │
│  │ depth=0         │                       CALLS (behavioral)                    │
│  └─────────────────┘                       ───────────────────                   │
│           │                                  Method ──► Method                   │
│           │ CONTAINS                         Method ──► External                 │
│           ▼                                                                      │
│  ┌─────────────────┐                       SELF (self.method() calls)           │
│  │ METHOD          │                       ─────────────────────────            │
│  │ node_type=method│──────CALLS/SELF──────►  Method ──► Method (same class)     │
│  │ is_entry=False  │                                                            │
│  │ depth=1         │                       CHAIN (obj.attr.method() calls)      │
│  └─────────────────┘                       ───────────────────────────          │
│           │                                  Method ──► External                 │
│           │ CALLS                                                                │
│           ▼                                                                      │
│  ┌─────────────────┐                                                            │
│  │ EXTERNAL        │                                                            │
│  │ node_type=func  │                                                            │
│  │ is_external=True│                                                            │
│  │ depth=2         │                                                            │
│  └─────────────────┘                                                            │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### Analysis Flow (ASCII Diagram)

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           ANALYSIS FLOW                                          │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  analyze(Sample__Processor)                                                      │
│         │                                                                        │
│         ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐    │
│  │ 1. RESET STATE                                                           │    │
│  │    • Clear name_to_node_id mapping                                       │    │
│  │    • Clear visited tracking                                              │    │
│  │    • Create fresh Schema__Call_Graph                                     │    │
│  └─────────────────────────────────────────────────────────────────────────┘    │
│         │                                                                        │
│         ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐    │
│  │ 2. CREATE CLASS NODE (entry point)                                       │    │
│  │    • node_id = Node_Id(Obj_Id())  →  'c0000001'                          │    │
│  │    • is_entry = True                                                     │    │
│  │    • depth = 0                                                           │    │
│  │    • Register: name_to_node_id["...Sample__Processor"] = node_id         │    │
│  │    • Set: graph.entry_point = node_id                                    │    │
│  └─────────────────────────────────────────────────────────────────────────┘    │
│         │                                                                        │
│         ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐    │
│  │ 3. DISCOVER METHODS                                                      │    │
│  │    For each method in class:                                             │    │
│  │    • Create METHOD node (depth=1)                                        │    │
│  │    • Create CONTAINS edge (class → method)                               │    │
│  │    • Register in name_to_node_id                                         │    │
│  └─────────────────────────────────────────────────────────────────────────┘    │
│         │                                                                        │
│         ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐    │
│  │ 4. EXTRACT CALLS (for each method)                                       │    │
│  │    Using Ast_Visit:                                                      │    │
│  │    • Parse method source                                                 │    │
│  │    • Capture all Ast_Call nodes                                          │    │
│  │    • For each call:                                                      │    │
│  │      ├─ Resolve target (self.method? direct? chain?)                     │    │
│  │      ├─ Check scope (should_follow?)                                     │    │
│  │      ├─ Lookup/create target node                                        │    │
│  │      ├─ Create edge (caller → callee)                                    │    │
│  │      └─ Recursively analyze if within scope and depth                    │    │
│  └─────────────────────────────────────────────────────────────────────────┘    │
│         │                                                                        │
│         ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐    │
│  │ 5. RETURN GRAPH                                                          │    │
│  │    • Schema__Call_Graph with all nodes and edges                         │    │
│  │    • Ready for export (Mermaid, JSON, MGraph-DB)                         │    │
│  └─────────────────────────────────────────────────────────────────────────┘    │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### Scope Control Decision Flow (ASCII Diagram)

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                        SCOPE DECISION FLOW                                       │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  Should we follow this target?                                                   │
│         │                                                                        │
│         ▼                                                                        │
│  ┌─────────────────┐                                                            │
│  │ In blocklist?   │───YES──► BLOCK (create external node if configured)        │
│  └────────┬────────┘                                                            │
│           │ NO                                                                   │
│           ▼                                                                      │
│  ┌─────────────────┐                                                            │
│  │ Is stdlib?      │───YES──► include_stdlib=True? ──NO──► BLOCK                │
│  └────────┬────────┘                              └─YES─► CONTINUE ↓            │
│           │ NO                                                                   │
│           ▼                                                                      │
│  ┌─────────────────┐                                                            │
│  │ Is external?    │───YES──► include_external=True? ──NO──► BLOCK              │
│  └────────┬────────┘                                 └─YES─► CONTINUE ↓         │
│           │ NO                                                                   │
│           ▼                                                                      │
│  ┌─────────────────┐                                                            │
│  │ Allowlist set?  │───YES──► In allowlist? ──NO──► BLOCK                       │
│  └────────┬────────┘                         └─YES─► FOLLOW                     │
│           │ NO (no allowlist = allow all)                                        │
│           ▼                                                                      │
│        FOLLOW                                                                    │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

---

## Part 4: Schema Definitions

### File Structure

```
osbot_utils/helpers/python_call_flow/
├── __init__.py
├── Call_Flow__Analyzer.py
├── Call_Flow__Exporter__Mermaid.py
├── schemas/
│   ├── __init__.py
│   ├── Schema__Call_Graph.py
│   ├── Schema__Call_Graph__Config.py
│   ├── Schema__Call_Graph__Edge.py
│   ├── Schema__Call_Graph__Node.py
│   └── enums/
│       ├── __init__.py
│       ├── Enum__Call_Graph__Node_Type.py
│       └── Enum__Call_Graph__Edge_Type.py
└── primitives/                              # New primitives if needed
    ├── __init__.py
    └── Safe_Str__Python__Module_Pattern.py  # Example
```

### Schema__Call_Graph__Node

```python
from typing                                                                          import List
from osbot_utils.helpers.python_call_flow.schemas.enums.Enum__Call_Graph__Node_Type  import Enum__Call_Graph__Node_Type
from osbot_utils.type_safe.Type_Safe                                                 import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Node_Id                    import Node_Id
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Label   import Safe_Str__Label
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Text         import Safe_Str__Text
from osbot_utils.type_safe.primitives.domains.files.safe_str.Safe_Str__File__Path    import Safe_Str__File__Path
from osbot_utils.type_safe.primitives.core.Safe_UInt                                 import Safe_UInt

class Schema__Call_Graph__Node(Type_Safe):                                           # Single node in call graph
    node_id      : Node_Id                                                           # Unique node identifier
    name         : Safe_Str__Label                                                   # Short display name
    full_name    : Safe_Str__Label                                                   # Fully qualified name
    node_type    : Enum__Call_Graph__Node_Type                                       # CLASS, METHOD, FUNCTION
    module       : Safe_Str__Label                                                   # Source module path
    file_path    : Safe_Str__File__Path                                              # File where defined
    depth        : Safe_UInt                                                         # Call depth from entry
    calls        : List[Node_Id]                                                     # Outgoing call targets
    called_by    : List[Node_Id]                                                     # Incoming callers
    source_code  : Safe_Str__Text                                                    # Source code (optional)
    line_number  : Safe_UInt                                                         # Line number in file
    is_entry     : bool                         = False                              # Is entry point?
    is_external  : bool                         = False                              # External/unresolved?
    is_recursive : bool                         = False                              # Calls itself?
```

### Schema__Call_Graph__Edge

```python
from osbot_utils.helpers.python_call_flow.schemas.enums.Enum__Call_Graph__Edge_Type  import Enum__Call_Graph__Edge_Type
from osbot_utils.type_safe.Type_Safe                                                 import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Edge_Id                    import Edge_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Node_Id                    import Node_Id
from osbot_utils.type_safe.primitives.core.Safe_UInt                                 import Safe_UInt

class Schema__Call_Graph__Edge(Type_Safe):                                           # Edge in call graph
    edge_id       : Edge_Id                                                          # Unique edge identifier
    from_node     : Node_Id                                                          # Source node
    to_node       : Node_Id                                                          # Target node
    edge_type     : Enum__Call_Graph__Edge_Type                                      # CONTAINS, CALLS, SELF, CHAIN
    line_number   : Safe_UInt                                                        # Line where relationship defined
    is_conditional: bool                        = False                              # Inside if/try/etc
```

### Schema__Call_Graph__Config

```python
from typing                                                                          import List
from osbot_utils.type_safe.Type_Safe                                                 import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Label   import Safe_Str__Label
from osbot_utils.type_safe.primitives.core.Safe_UInt                                 import Safe_UInt

class Schema__Call_Graph__Config(Type_Safe):                                         # Configuration for traversal
    # Depth Control
    max_depth              : Safe_UInt             = Safe_UInt(5)                    # Max call depth from entry

    # Method Visibility
    include_private        : bool                  = True                            # Include _private methods
    include_dunder         : bool                  = False                           # Include __dunder__ methods

    # Scope Control
    include_stdlib         : bool                  = False                           # Follow into Python stdlib
    include_external       : bool                  = False                           # Follow into pip packages

    # Fine-grained Scope (TODO: create proper Safe_* primitives for these)
    module_allowlist       : List[Safe_Str__Label]                                   # ONLY follow these module prefixes
    module_blocklist       : List[Safe_Str__Label]                                   # NEVER follow these modules
    class_allowlist        : List[Safe_Str__Label]                                   # ONLY follow these classes
    class_blocklist        : List[Safe_Str__Label]                                   # NEVER follow these classes

    # Analysis Options
    resolve_self_calls     : bool                  = True                            # Resolve self.method() calls
    capture_source         : bool                  = False                           # Store source code in nodes
    create_external_nodes  : bool                  = True                            # Create placeholders for external
```

### Schema__Call_Graph

```python
from typing                                                                          import Dict, List
from osbot_utils.helpers.python_call_flow.schemas.Schema__Call_Graph__Config         import Schema__Call_Graph__Config
from osbot_utils.helpers.python_call_flow.schemas.Schema__Call_Graph__Edge           import Schema__Call_Graph__Edge
from osbot_utils.helpers.python_call_flow.schemas.Schema__Call_Graph__Node           import Schema__Call_Graph__Node
from osbot_utils.type_safe.Type_Safe                                                 import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Graph_Id                   import Graph_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Node_Id                    import Node_Id
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Label   import Safe_Str__Label
from osbot_utils.type_safe.primitives.core.Safe_UInt                                 import Safe_UInt

class Schema__Call_Graph(Type_Safe):                                                 # Complete call graph
    graph_id        : Graph_Id                                                       # Unique graph identifier
    name            : Safe_Str__Label                                                # Descriptive name
    entry_point     : Node_Id                                                        # Starting node
    config          : Schema__Call_Graph__Config                                     # Configuration used
    nodes           : Dict[str, Schema__Call_Graph__Node]                            # node_id → node
    edges           : List[Schema__Call_Graph__Edge]                                 # All edges
    max_depth_found : Safe_UInt                    = Safe_UInt(0)                    # Deepest level reached
```

### Enum__Call_Graph__Node_Type

```python
from enum import Enum

class Enum__Call_Graph__Node_Type(str, Enum):
    CLASS    = 'class'                                                               # Class definition
    METHOD   = 'method'                                                              # Method within a class
    FUNCTION = 'function'                                                            # Standalone function
```

### Enum__Call_Graph__Edge_Type

```python
from enum import Enum

class Enum__Call_Graph__Edge_Type(str, Enum):
    # Structural
    CONTAINS = 'contains'                                                            # Class contains Method

    # Behavioral
    CALLS    = 'calls'                                                               # Direct function call
    SELF     = 'self'                                                                # self.method() call
    CHAIN    = 'chain'                                                               # obj.attr.method() call
```

---

## Part 5: Call_Flow__Analyzer Implementation

### Class Structure

```python
from typing                                                                          import Dict, Optional, Any
from osbot_utils.helpers.ast                                                         import Ast_Module
from osbot_utils.helpers.ast.Ast_Visit                                               import Ast_Visit
from osbot_utils.helpers.python_call_flow.schemas.Schema__Call_Graph                 import Schema__Call_Graph
from osbot_utils.helpers.python_call_flow.schemas.Schema__Call_Graph__Config         import Schema__Call_Graph__Config
from osbot_utils.helpers.python_call_flow.schemas.Schema__Call_Graph__Edge           import Schema__Call_Graph__Edge
from osbot_utils.helpers.python_call_flow.schemas.Schema__Call_Graph__Node           import Schema__Call_Graph__Node
from osbot_utils.helpers.python_call_flow.schemas.enums.Enum__Call_Graph__Node_Type  import Enum__Call_Graph__Node_Type
from osbot_utils.helpers.python_call_flow.schemas.enums.Enum__Call_Graph__Edge_Type  import Enum__Call_Graph__Edge_Type
from osbot_utils.type_safe.Type_Safe                                                 import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Graph_Id                   import Graph_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Node_Id                    import Node_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Edge_Id                    import Edge_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id                     import Obj_Id

class Call_Flow__Analyzer(Type_Safe):
    config           : Schema__Call_Graph__Config                                    # Traversal configuration
    graph            : Schema__Call_Graph                                            # The resulting graph
    name_to_node_id  : Dict[str, Node_Id]                                            # qualified_name → Node_Id
    visited_methods  : Dict[str, bool]                                               # Track analyzed methods
    class_context    : Dict[str, type]                                               # Track class for self resolution
```

### Key Methods (Public API)

```python
def analyze(self, target) -> Schema__Call_Graph:
    """Main entry point - analyze a function, class, or module."""

def analyze_class(self, cls: type, depth: int) -> Node_Id:
    """Analyze a class, creating class node and method nodes."""

def analyze_function(self, func, depth: int, class_context: type = None) -> Node_Id:
    """Analyze a single function or method."""
```

### Key Methods (Internal)

```python
def reset_state(self):
    """Reset internal state for fresh analysis."""

def register_node(self, full_name: str, node_id: Node_Id):
    """Register a node in the name→id mapping."""

def lookup_node_id(self, full_name: str) -> Optional[Node_Id]:
    """Lookup a node by qualified name."""

def get_qualified_name(self, target) -> str:
    """Get fully qualified name for a target."""

def create_class_node(self, cls: type, depth: int) -> Schema__Call_Graph__Node:
    """Create a node for a class."""

def create_method_node(self, func, depth: int, class_context: type) -> Schema__Call_Graph__Node:
    """Create a node for a method."""

def create_external_node(self, call_name: str, depth: int) -> Schema__Call_Graph__Node:
    """Create a placeholder node for an external/unresolved call."""

def create_edge(self, from_node: Node_Id, to_node: Node_Id,
                edge_type: Enum__Call_Graph__Edge_Type, line_number: int = 0):
    """Create an edge between two nodes."""

def extract_calls(self, func, caller_node: Schema__Call_Graph__Node,
                  depth: int, class_context: type = None):
    """Extract all function calls from a method using AST helpers."""

def resolve_call(self, call, class_context: type = None) -> Optional[Dict[str, Any]]:
    """Resolve an Ast_Call to target information."""

def should_follow(self, qualified_name: str, target) -> bool:
    """Determine if we should follow/analyze this target."""

def is_stdlib(self, module: str) -> bool:
    """Check if module is Python standard library."""

def is_external(self, module: str) -> bool:
    """Check if module is an external (pip) package."""

def is_blocked(self, qualified_name: str, module: str) -> bool:
    """Check if target is in any blocklist."""

def is_allowed(self, qualified_name: str, module: str) -> bool:
    """Check if target passes allowlists."""
```

---

## Part 6: Using OSBot-Utils AST Helpers

### Key Classes to Use

```python
from osbot_utils.helpers.ast import Ast_Module
from osbot_utils.helpers.ast.Ast_Visit import Ast_Visit
```

### Parsing a Function/Class

```python
# Ast_Module accepts: source string, file path, or Python object
module = Ast_Module(func)  # Parse a function directly
module = Ast_Module(MyClass)  # Parse a class
```

### Extracting Calls with Ast_Visit

```python
def extract_calls(self, func, caller_node, depth, class_context=None):
    try:
        module = Ast_Module(func)
    except:
        return                                                                       # Can't get source

    with Ast_Visit(module) as visitor:
        visitor.capture_calls()                                                      # Enable call capture
        visitor.visit()                                                              # Execute visitor

        for call in visitor.captured_nodes().get('Ast_Call', []):
            call_info = self.resolve_call(call, class_context)
            if call_info:
                self.process_call(call_info, caller_node, depth)
```

### Resolving Calls

```python
def resolve_call(self, call, class_context=None):
    """Resolve an Ast_Call node to call information."""
    call_name = call.name()                                                          # Built-in resolution
    if not call_name:
        return None

    func_node = call.func()
    func_type = type(func_node).__name__

    # Check for self.method() pattern
    if func_type == 'Ast_Attribute':
        value = func_node.value()
        if type(value).__name__ == 'Ast_Name' and value.id() == 'self':
            # This is self.method()
            return {
                'name'    : call_name,
                'type'    : 'self',
                'class'   : class_context,
                'resolved': self.resolve_self_method(call_name, class_context),
            }

    # Direct call
    if func_type == 'Ast_Name':
        return {
            'name'    : call_name,
            'type'    : 'calls',
            'resolved': None,
        }

    # Chained call (obj.attr.method)
    if func_type == 'Ast_Attribute':
        return {
            'name'    : call_name,
            'type'    : 'chain',
            'resolved': None,
        }

    return None
```

---

## Part 7: Expected Test Output

### Sample Test Class

```python
class Sample__Processor:
    def __init__(self):
        self.helper = Sample__Helper()

    def run(self, items):
        validated = self.validate(items)
        transformed = self.transform(validated)
        return self.output(transformed)

    def validate(self, items):
        return [i for i in items if i is not None]

    def transform(self, items):
        results = []
        for item in items:
            result = self.helper.do_work(item)
            results.append(result)
        return results

    def output(self, items):
        return {'count': len(items), 'items': items}
```

### Expected Graph Output

```python
with test_graph_ids():
    analyzer = Call_Flow__Analyzer()
    graph = analyzer.analyze(Sample__Processor)

    assert graph.obj() == __(
        graph_id        = 'a0000001',
        name            = 'test_module.Sample__Processor',
        entry_point     = 'c0000001',
        max_depth_found = 2,
        config          = __(...),
        nodes           = __(
            c0000001 = __(                                                           # CLASS (entry)
                node_id     = 'c0000001',
                name        = 'Sample__Processor',
                full_name   = 'test_module.Sample__Processor',
                node_type   = 'class',
                depth       = 0,
                is_entry    = True,
                is_external = False,
                calls       = [],
                called_by   = [],
            ),
            c0000002 = __(                                                           # METHOD: run
                node_id     = 'c0000002',
                name        = 'run',
                full_name   = 'test_module.Sample__Processor.run',
                node_type   = 'method',
                depth       = 1,
                is_entry    = False,
                calls       = ['c0000003', 'c0000004', 'c0000005'],
                called_by   = [],
            ),
            c0000003 = __(                                                           # METHOD: validate
                node_id     = 'c0000003',
                name        = 'validate',
                full_name   = 'test_module.Sample__Processor.validate',
                node_type   = 'method',
                depth       = 1,
                calls       = [],
                called_by   = ['c0000002'],
            ),
            c0000004 = __(                                                           # METHOD: transform
                node_id     = 'c0000004',
                name        = 'transform',
                full_name   = 'test_module.Sample__Processor.transform',
                node_type   = 'method',
                depth       = 1,
                calls       = ['c0000006'],                                          # Calls external
                called_by   = ['c0000002'],
            ),
            c0000005 = __(                                                           # METHOD: output
                node_id     = 'c0000005',
                name        = 'output',
                full_name   = 'test_module.Sample__Processor.output',
                node_type   = 'method',
                depth       = 1,
                calls       = [],
                called_by   = ['c0000002'],
            ),
            c0000006 = __(                                                           # EXTERNAL: helper.do_work
                node_id     = 'c0000006',
                name        = 'do_work',
                full_name   = 'external.helper.do_work',
                node_type   = 'function',
                depth       = 2,
                is_external = True,
                calls       = [],
                called_by   = ['c0000004'],
            ),
        ),
        edges = [
            # CONTAINS edges (class → methods)
            __(edge_id='d0000001', from_node='c0000001', to_node='c0000002', edge_type='contains'),
            __(edge_id='d0000002', from_node='c0000001', to_node='c0000003', edge_type='contains'),
            __(edge_id='d0000003', from_node='c0000001', to_node='c0000004', edge_type='contains'),
            __(edge_id='d0000004', from_node='c0000001', to_node='c0000005', edge_type='contains'),
            # CALLS edges (method → method)
            __(edge_id='d0000005', from_node='c0000002', to_node='c0000003', edge_type='self'),
            __(edge_id='d0000006', from_node='c0000002', to_node='c0000004', edge_type='self'),
            __(edge_id='d0000007', from_node='c0000002', to_node='c0000005', edge_type='self'),
            __(edge_id='d0000008', from_node='c0000004', to_node='c0000006', edge_type='chain'),
        ],
    )
```

---

## Part 8: Code Formatting Guidelines

### Import Alignment

```python
from osbot_utils.helpers.python_call_flow.schemas.Schema__Call_Graph                import Schema__Call_Graph
from osbot_utils.helpers.python_call_flow.schemas.Schema__Call_Graph__Config        import Schema__Call_Graph__Config
from osbot_utils.type_safe.Type_Safe                                                 import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Node_Id                    import Node_Id
```

### Attribute Alignment

```python
class Schema__Call_Graph__Node(Type_Safe):
    node_id      : Node_Id                                                           # Unique identifier
    name         : Safe_Str__Label                                                   # Short name
    full_name    : Safe_Str__Label                                                   # Qualified name
    node_type    : Enum__Call_Graph__Node_Type                                       # CLASS/METHOD/FUNCTION
    depth        : Safe_UInt                    = Safe_UInt(0)                        # Call depth
    is_entry     : bool                         = False                              # Entry point?
```

### Method Naming

- **NO underscores** at start of method names
- Use descriptive names: `should_follow` not `_should_follow`
- Public methods: `analyze`, `analyze_class`, `analyze_function`
- Internal helpers: `resolve_call`, `create_edge`, `is_stdlib`

### Comments

```python
def analyze(self, target) -> Schema__Call_Graph:                                     # Main entry point
    self.reset_state()                                                               # Clear previous state
    
    if inspect.isclass(target):                                                      # Handle class analysis
        self.analyze_class(target, depth=0)
```

---

## Part 9: Testing Strategy

### Test File Structure

```
tests/unit/helpers/python_call_flow/
├── test_Call_Flow__Analyzer.py
├── test_Call_Flow__Exporter__Mermaid.py
└── schemas/
    ├── test_Schema__Call_Graph.py
    ├── test_Schema__Call_Graph__Config.py
    ├── test_Schema__Call_Graph__Edge.py
    └── test_Schema__Call_Graph__Node.py
```

### Key Test Patterns

```python
from osbot_utils.testing.Graph__Deterministic__Ids import test_graph_ids
from osbot_utils.testing.__ import __

class test_Call_Flow__Analyzer(TestCase):

    def test__analyze__class(self):
        with test_graph_ids():                                                       # Deterministic IDs
            with Call_Flow__Analyzer() as analyzer:
                graph = analyzer.analyze(Sample__Processor)
                
                assert graph.entry_point == 'c0000001'                               # Class is entry
                assert graph.node_count() == 6                                       # Class + 5 methods
                assert graph.edge_count() == 8                                       # 4 CONTAINS + 4 CALLS
```

### Meta Test (Analyzer Analyzing Itself)

```python
def test__meta__self_analysis(self):
    with test_graph_ids():
        analyzer = Call_Flow__Analyzer()
        graph = analyzer.analyze(Call_Flow__Analyzer)                                # Analyze itself!
        
        assert graph.node_count() >= 10                                              # Should find many methods
        assert 'analyze' in [n.name for n in graph.nodes.values()]                   # Entry method found
```

---

## Part 10: Implementation Checklist

### Phase 1.1: Schema Updates
- [ ] Create/verify `Enum__Call_Graph__Node_Type` with CLASS, METHOD, FUNCTION
- [ ] Create/verify `Enum__Call_Graph__Edge_Type` with CONTAINS, CALLS, SELF, CHAIN
- [ ] Update `Schema__Call_Graph__Edge` to use `edge_type` (renamed from `call_type`)
- [ ] Add scope control fields to `Schema__Call_Graph__Config`

### Phase 1.2: Analyzer Core
- [ ] Add `name_to_node_id` mapping to `Call_Flow__Analyzer`
- [ ] Implement `reset_state()` to clear mappings
- [ ] Implement `register_node()` and `lookup_node_id()`
- [ ] Implement `get_qualified_name()`

### Phase 1.3: Node Creation
- [ ] Implement `create_class_node()` (depth=0, is_entry=True)
- [ ] Implement `create_method_node()` (depth=1 for contained methods)
- [ ] Implement `create_external_node()` (is_external=True)
- [ ] Implement `create_edge()`

### Phase 1.4: Analysis Flow
- [ ] Implement `analyze()` main entry point
- [ ] Implement `analyze_class()` with class node + method discovery
- [ ] Implement `analyze_function()` for method/function analysis

### Phase 1.5: Call Extraction (Using AST Helpers)
- [ ] Implement `extract_calls()` using `Ast_Visit`
- [ ] Implement `resolve_call()` for self/direct/chain detection
- [ ] Implement `resolve_self_method()` for class method lookup
- [ ] Implement `process_call()` for edge creation and recursion

### Phase 1.6: Scope Control
- [ ] Implement `should_follow()`
- [ ] Implement `is_stdlib()`
- [ ] Implement `is_external()`
- [ ] Implement `is_blocked()` and `is_allowed()`

### Phase 1.7: Testing
- [ ] Write schema tests (all passing)
- [ ] Write analyzer tests with deterministic IDs
- [ ] Write meta self-analysis test
- [ ] Write scope control tests

---

## Part 11: Reference Documents

The following documents provide additional context and should be referenced during implementation:

1. **Type_Safe & Python Formatting Guide for LLMs** - Coding style and patterns
2. **Type_Safe Testing Guidance for LLMs** - Testing patterns and `.obj()` usage
3. **OSBot-Utils Safe Primitives Reference Guide** - Available Safe_* primitives
4. **AST Helpers LLM Usage Brief** - How to use Ast_Module, Ast_Visit, etc.

---

## Part 12: Success Criteria

### Minimum Viable Product (MVP)
- [ ] Can analyze a class and produce a graph with nodes and edges
- [ ] Class node is entry point (depth=0)
- [ ] Method nodes are contained (depth=1)
- [ ] CONTAINS edges connect class to methods
- [ ] CALLS/SELF edges connect methods to called methods
- [ ] External calls produce external placeholder nodes
- [ ] All tests pass with deterministic IDs

### Full Implementation
- [ ] Scope control (stdlib, external, allow/block lists)
- [ ] Mermaid export working
- [ ] HTML visualization working
- [ ] Meta self-analysis working
- [ ] Ready for MGraph-DB integration

---

*End of Implementation Brief*
