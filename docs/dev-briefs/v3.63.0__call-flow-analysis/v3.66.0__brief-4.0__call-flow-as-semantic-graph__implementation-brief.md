# (Brief 4.0) Call Flow as Semantic Graph

**Version:** v3.66.0  
**Status:** Refactoring Implementation  
**Target:** OSBot-Utils (`osbot_utils.helpers.python_call_flow`)  
**Created:** January 2026  
**Prerequisites:** Brief 3.8 (Complete Semantic Graph Foundation) complete  
**Enables:** Unified graph architecture, enhanced visualization, validation, taxonomy-based grouping

---

## 1. Document Purpose

This brief specifies the refactoring of `python_call_flow` to leverage the `semantic_graphs` framework. The refactoring transforms a standalone call flow analyzer into a domain-specific application built on a robust, standards-aligned semantic graph foundation.

**What This Document Covers:**

1. Historical context and evolution of the architecture
2. Mapping of semantic_graphs capabilities to call flow requirements
3. Detailed technical specification for the refactoring
4. Migration strategy and implementation checklist

**Outcome:** A call flow analyzer that inherits all semantic_graphs capabilities: ontology-based validation, typed properties, taxonomy grouping, human-readable projections, and standards alignment.

---

## 2. Historical Context and Evolution

### 2.1 The Journey

The call flow analyzer evolved through six major phases, each building on lessons learned:

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                              ARCHITECTURAL EVOLUTION                              │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                   │
│  Brief 1.0 (v3.63.0)                                                              │
│  ══════════════════                                                               │
│  "Call Flow Analysis - Project Brief"                                             │
│                                                                                   │
│  • Original vision: Static call flow analysis & visualization                     │
│  • Goal: Parse Python → Build graph → Visualize in browser                        │
│  • Key insight: "Hybrid strategy" - deterministic extraction + LLM analysis       │
│                                                                                   │
│                                    │                                              │
│                                    ▼                                              │
│                                                                                   │
│  Brief 2.0 (v3.63.0)                                                              │
│  ══════════════════                                                               │
│  "Call Flow Analyzer - Implementation Brief"                                      │
│                                                                                   │
│  • First implementation with custom schemas                                       │
│  • Schema__Call_Graph__Node with flat attributes (module, file_path on every node)│
│  • Problems identified:                                                           │
│    - Redundancy: module name repeated on every node                               │
│    - Mixed concerns: behavioral (calls) + structural (module) together            │
│    - No queryable relationships: "module contains class" is implicit              │
│                                                                                   │
│                                    │                                              │
│                                    ▼                                              │
│                                                                                   │
│  Brief 3.0 (v3.64.3)                                                              │
│  ══════════════════                                                               │
│  "Semantic Graphs & Code Structure"                                               │
│                                                                                   │
│  • KEY INSIGHT: Call flow is just ONE instance of a generic pattern               │
│  • Decision: Build reusable semantic_graphs framework FIRST                       │
│  • Introduced: Ontology, Taxonomy, Rules, Graph separation                        │
│  • Planned: Code structure graph + lightweight call flow referencing it           │
│                                                                                   │
│                                    │                                              │
│                                    ▼                                              │
│                                                                                   │
│  Brief 3.5 (v3.64.0)                                                              │
│  ═══════════════════                                                              │
│  "ID/Ref Architecture Clarification"                                              │
│                                                                                   │
│  • Clarified naming: *_Id for instances, *_Ref for labels                         │
│  • Added deterministic ID creation: Obj_Id.from_seed()                            │
│  • Established: IDs for integrity, Refs for human readability                     │
│                                                                                   │
│                                    │                                              │
│                                    ▼                                              │
│                                                                                   │
│  Brief 3.7 (v3.64.0)                                                              │
│  ═══════════════════                                                              │
│  "Projected Data Architecture"                                                    │
│                                                                                   │
│  • Introduced Schema__ (master) → Projected__ (derived) pattern                   │
│  • Three-section projections: projection, references, sources                     │
│  • Key principle: "Projections are generated, not edited"                         │
│                                                                                   │
│                                    │                                              │
│                                    ▼                                              │
│                                                                                   │
│  Brief 3.8 (v3.65.0)                                                              │
│  ═══════════════════                                                              │
│  "Complete Semantic Graph Foundation"                                             │
│                                                                                   │
│  • Added property system (Property_Name_Id, Property_Type_Id)                     │
│  • Connected taxonomy to ontology (category_id on node types)                     │
│  • Filtered projections (only include used refs)                                  │
│  • RDF/OWL alignment complete                                                     │
│                                                                                   │
│                                    │                                              │
│                                    ▼                                              │
│                                                                                   │
│  Brief 4.0 (v3.66.0) ← THIS DOCUMENT                                              │
│  ═══════════════════                                                              │
│  "Call Flow as Semantic Graph"                                                    │
│                                                                                   │
│  • Apply semantic_graphs to call flow (the original goal!)                        │
│  • Replace custom schemas with semantic graph schemas                             │
│  • Gain: validation, properties, taxonomy, projections                            │
│                                                                                   │
└──────────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 Why the "Detour" Was Worth It

The semantic_graphs framework development (Briefs 3.0-3.8) was not scope creep — it was essential foundation work:

| Without semantic_graphs | With semantic_graphs |
|------------------------|---------------------|
| Custom node/edge schemas per domain | Reusable Schema__Semantic_Graph__Node/Edge |
| No validation | Ontology-based edge rule validation |
| Flat string attributes | Typed properties with optional validation |
| Enum-based types | Ontology-defined types (extensible) |
| No categorization | Taxonomy-based grouping |
| Custom export logic | Projector generates human-readable output |
| Ad-hoc ID handling | Consistent ID/Ref separation |

### 2.3 The Original Problems (Brief 2) - Now Solved

Brief 2's implementation had these problems, all addressed by semantic_graphs:

| Problem | How semantic_graphs Solves It |
|---------|------------------------------|
| **Redundancy** (module repeated on every node) | Store as property, or create module nodes with CONTAINS edges |
| **Mixed concerns** (behavioral + structural) | Properties separate from graph structure |
| **No relationships** ("module contains class" implicit) | Explicit edges with predicates |
| **No hierarchy** (package→module→class→method) | Taxonomy categories + ontology node types |
| **String matching** for queries | ID-based lookups + predicate filtering |
| **No reusability** | Generic framework, domain-specific ontology |

---

## 3. Capability Mapping

### 3.1 What semantic_graphs Provides

The framework provides these capabilities that call flow will leverage:

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                         SEMANTIC_GRAPHS CAPABILITIES                              │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                   │
│  ONTOLOGY LAYER                                                                   │
│  ══════════════                                                                   │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐  │
│  │ Node Types     │  │ Predicates     │  │ Property Names │  │ Property Types │  │
│  │                │  │                │  │                │  │                │  │
│  │ node_type_id   │  │ predicate_id   │  │ prop_name_id   │  │ prop_type_id   │  │
│  │ node_type_ref  │  │ predicate_ref  │  │ prop_name_ref  │  │ prop_type_ref  │  │
│  │ category_id ───┼──│ inverse_id     │  │ prop_type_id   │  │                │  │
│  └────────────────┘  └────────────────┘  └────────────────┘  └────────────────┘  │
│          │                                                                        │
│          │ category_id (FK)                                                       │
│          ▼                                                                        │
│  TAXONOMY LAYER                                                                   │
│  ══════════════                                                                   │
│  ┌────────────────────────────────────────────────────────────────────────────┐  │
│  │ Categories: code_element → container, callable, reference                   │  │
│  │             Hierarchical classification of node types                       │  │
│  └────────────────────────────────────────────────────────────────────────────┘  │
│                                                                                   │
│  GRAPH LAYER                                                                      │
│  ═══════════                                                                      │
│  ┌────────────────────────────────────────────────────────────────────────────┐  │
│  │ Schema__Semantic_Graph                                                      │  │
│  │ ├── nodes: Dict__Nodes__By_Id                                               │  │
│  │ │   └── Schema__Semantic_Graph__Node                                        │  │
│  │ │       ├── node_id, node_type_id, name                                     │  │
│  │ │       └── properties: Dict__Node_Properties (name_id → text)              │  │
│  │ └── edges: List__Semantic_Graph__Edges                                      │  │
│  │     └── Schema__Semantic_Graph__Edge                                        │  │
│  │         ├── edge_id, from_node_id, to_node_id, predicate_id                 │  │
│  │         └── properties: Dict__Edge_Properties (name_id → text)              │  │
│  └────────────────────────────────────────────────────────────────────────────┘  │
│                                                                                   │
│  RULES LAYER                                                                      │
│  ═══════════                                                                      │
│  ┌────────────────────────────────────────────────────────────────────────────┐  │
│  │ Edge Rules: source_type_id --predicate_id--> target_type_id                 │  │
│  │ Required Properties: node_type_id MUST have property_name_id                │  │
│  │ Cardinality: method can have 0..1 class (optional containment)              │  │
│  └────────────────────────────────────────────────────────────────────────────┘  │
│                                                                                   │
│  PROJECTION LAYER                                                                 │
│  ════════════════                                                                 │
│  ┌────────────────────────────────────────────────────────────────────────────┐  │
│  │ Schema__ (IDs) ──Projector──► Projected__ (Refs)                            │  │
│  │                                                                              │  │
│  │ Three sections:                                                              │  │
│  │ • projection: Human-readable nodes/edges with refs and names                │  │
│  │ • references: Filtered ref→id mappings for correlation                      │  │
│  │ • sources: Provenance (source_graph_id, generated_at)                       │  │
│  └────────────────────────────────────────────────────────────────────────────┘  │
│                                                                                   │
│  BUILDER & VALIDATOR                                                              │
│  ═══════════════════                                                              │
│  ┌────────────────────────────────────────────────────────────────────────────┐  │
│  │ Semantic_Graph__Builder: Fluent API for graph construction                  │  │
│  │ Semantic_Graph__Validator: Validates against ontology edge rules            │  │
│  │ Ontology__Registry / Taxonomy__Registry: Load and cache definitions         │  │
│  └────────────────────────────────────────────────────────────────────────────┘  │
│                                                                                   │
└──────────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Current python_call_flow → semantic_graphs Mapping

| python_call_flow Current | semantic_graphs Target | Notes |
|-------------------------|------------------------|-------|
| `Enum__Call_Graph__Node_Type.CLASS` | `Node_Type_Ref("class")` + `Node_Type_Id` | Defined in ontology |
| `Enum__Call_Graph__Node_Type.METHOD` | `Node_Type_Ref("method")` + `Node_Type_Id` | Defined in ontology |
| `Enum__Call_Graph__Node_Type.FUNCTION` | `Node_Type_Ref("function")` + `Node_Type_Id` | Defined in ontology |
| `Enum__Call_Graph__Node_Type.MODULE` | `Node_Type_Ref("module")` + `Node_Type_Id` | Defined in ontology |
| `Enum__Call_Graph__Edge_Type.CONTAINS` | `Predicate_Ref("contains")` + `Predicate_Id` | Inverse: "contained_by" |
| `Enum__Call_Graph__Edge_Type.CALLS` | `Predicate_Ref("calls")` + `Predicate_Id` | Inverse: "called_by" |
| `Enum__Call_Graph__Edge_Type.SELF` | `Predicate_Ref("calls_self")` + `Predicate_Id` | self.method() calls |
| `Enum__Call_Graph__Edge_Type.CHAIN` | `Predicate_Ref("calls_chain")` + `Predicate_Id` | obj.attr.method() calls |
| `Schema__Call_Graph__Node` | `Schema__Semantic_Graph__Node` | With properties |
| `Schema__Call_Graph__Edge` | `Schema__Semantic_Graph__Edge` | With properties |
| `node.module` | Property: `module_name` | Or: module node + contains edge |
| `node.file_path` | Property: `file_path` | String property |
| `node.line_number` | Property: `line_number` | Integer property |
| `node.depth` | Property: `call_depth` | Integer property |
| `node.is_entry` | Property: `is_entry` | Boolean property |
| `node.is_external` | Property: `is_external` | Boolean property |
| `node.is_recursive` | Property: `is_recursive` | Boolean property |
| `node.source_code` | Property: `source_code` | Text property |
| `edge.is_conditional` | Property: `is_conditional` | Boolean property |
| `Call_Flow__Node__Factory` | `Semantic_Graph__Builder` | Fluent API |
| `Call_Flow__Edge__Factory` | `Semantic_Graph__Builder` | Fluent API |
| `Call_Flow__Node__Registry` | `Dict__Nodes__By_Id` + helper | Built-in to graph |
| `Call_Flow__Exporter__Mermaid` | `Semantic_Graph__Projector` + Mermaid adapter | Project then export |
| (none) | `Semantic_Graph__Validator` | Validates edge rules |
| (none) | Taxonomy categories | Group node types |

### 3.3 What Gets Simplified

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                              SIMPLIFICATION GAINS                                 │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                   │
│  BEFORE (Custom Implementation)           AFTER (Using semantic_graphs)           │
│  ══════════════════════════════           ═════════════════════════════           │
│                                                                                   │
│  Enum__Call_Graph__Node_Type              ─────► Ontology node types              │
│  Enum__Call_Graph__Edge_Type              ─────► Ontology predicates              │
│  Schema__Call_Graph                       ─────► Schema__Semantic_Graph           │
│  Schema__Call_Graph__Node                 ─────► Schema__Semantic_Graph__Node     │
│  Schema__Call_Graph__Edge                 ─────► Schema__Semantic_Graph__Edge     │
│  Schema__Call_Graph__Config               ─────► Keep (analysis config)           │
│  Call_Flow__Node__Factory                 ─────► Semantic_Graph__Builder          │
│  Call_Flow__Edge__Factory                 ─────► Semantic_Graph__Builder          │
│  Call_Flow__Node__Registry                ─────► Helper on builder/graph          │
│                                                                                   │
│  KEPT (Domain-Specific Logic)                                                     │
│  ═════════════════════════════                                                    │
│                                                                                   │
│  Call_Flow__Analyzer                      ─────► Keep (orchestration)             │
│  Call_Flow__AST__Extractor                ─────► Keep (AST extraction)            │
│  Call_Flow__Call__Resolver                ─────► Keep (call resolution)           │
│  Call_Flow__Call__Filter                  ─────► Keep (scope control)             │
│  Call_Flow__Exporter__Mermaid             ─────► Adapt (use projection)           │
│                                                                                   │
│  NEW (From semantic_graphs)                                                       │
│  ══════════════════════════                                                       │
│                                                                                   │
│  (none)                                   ◄───── Ontology validation              │
│  (none)                                   ◄───── Typed properties                 │
│  (none)                                   ◄───── Taxonomy grouping                │
│  (none)                                   ◄───── Human-readable projections       │
│  (none)                                   ◄───── Filtered references              │
│                                                                                   │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. Call Flow Ontology Definition

### 4.1 Node Types

```python
# Ontology: call_flow
# Node types define what kinds of entities exist in a call flow graph

node_types = {
    "class": {
        "node_type_id"  : "<deterministic from seed>",
        "node_type_ref" : "class",
        "category_id"   : "<container category>",
    },
    "method": {
        "node_type_id"  : "<deterministic from seed>",
        "node_type_ref" : "method",
        "category_id"   : "<callable category>",
    },
    "function": {
        "node_type_id"  : "<deterministic from seed>",
        "node_type_ref" : "function",
        "category_id"   : "<callable category>",
    },
    "module": {
        "node_type_id"  : "<deterministic from seed>",
        "node_type_ref" : "module",
        "category_id"   : "<container category>",
    },
    "external": {
        "node_type_id"  : "<deterministic from seed>",
        "node_type_ref" : "external",
        "category_id"   : "<reference category>",
    },
}
```

### 4.2 Predicates (Edge Types)

```python
# Predicates define relationship types between nodes

predicates = {
    "contains": {
        "predicate_id"  : "<deterministic from seed>",
        "predicate_ref" : "contains",
        "inverse_id"    : "<contained_by predicate_id>",
    },
    "contained_by": {
        "predicate_id"  : "<deterministic from seed>",
        "predicate_ref" : "contained_by",
        "inverse_id"    : "<contains predicate_id>",
    },
    "calls": {
        "predicate_id"  : "<deterministic from seed>",
        "predicate_ref" : "calls",
        "inverse_id"    : "<called_by predicate_id>",
    },
    "called_by": {
        "predicate_id"  : "<deterministic from seed>",
        "predicate_ref" : "called_by",
        "inverse_id"    : "<calls predicate_id>",
    },
    "calls_self": {
        "predicate_id"  : "<deterministic from seed>",
        "predicate_ref" : "calls_self",
        "inverse_id"    : None,  # Self-referential within class
    },
    "calls_chain": {
        "predicate_id"  : "<deterministic from seed>",
        "predicate_ref" : "calls_chain",
        "inverse_id"    : None,  # Chain calls (obj.attr.method())
    },
}
```

### 4.3 Edge Rules

```python
# Edge rules define valid connections (source_type --predicate--> target_type)

edge_rules = [
    # Containment rules
    {"source_type_ref": "module",   "predicate_ref": "contains", "target_type_ref": "class"},
    {"source_type_ref": "module",   "predicate_ref": "contains", "target_type_ref": "function"},
    {"source_type_ref": "class",    "predicate_ref": "contains", "target_type_ref": "method"},
    
    # Call rules (any callable can call any callable or external)
    {"source_type_ref": "method",   "predicate_ref": "calls",      "target_type_ref": "method"},
    {"source_type_ref": "method",   "predicate_ref": "calls",      "target_type_ref": "function"},
    {"source_type_ref": "method",   "predicate_ref": "calls",      "target_type_ref": "external"},
    {"source_type_ref": "function", "predicate_ref": "calls",      "target_type_ref": "method"},
    {"source_type_ref": "function", "predicate_ref": "calls",      "target_type_ref": "function"},
    {"source_type_ref": "function", "predicate_ref": "calls",      "target_type_ref": "external"},
    
    # Self calls (method calling another method in same class)
    {"source_type_ref": "method",   "predicate_ref": "calls_self", "target_type_ref": "method"},
    
    # Chain calls (method calling through attribute chain)
    {"source_type_ref": "method",   "predicate_ref": "calls_chain", "target_type_ref": "method"},
    {"source_type_ref": "method",   "predicate_ref": "calls_chain", "target_type_ref": "external"},
    {"source_type_ref": "function", "predicate_ref": "calls_chain", "target_type_ref": "method"},
    {"source_type_ref": "function", "predicate_ref": "calls_chain", "target_type_ref": "external"},
]
```

### 4.4 Property Names

```python
# Property names define what data can be attached to nodes and edges

property_names = {
    # Node properties
    "qualified_name": {
        "property_name_id"  : "<deterministic>",
        "property_name_ref" : "qualified_name",
        "property_type_id"  : "<string type>",
    },
    "module_name": {
        "property_name_id"  : "<deterministic>",
        "property_name_ref" : "module_name",
        "property_type_id"  : "<string type>",
    },
    "file_path": {
        "property_name_id"  : "<deterministic>",
        "property_name_ref" : "file_path",
        "property_type_id"  : "<string type>",
    },
    "line_number": {
        "property_name_id"  : "<deterministic>",
        "property_name_ref" : "line_number",
        "property_type_id"  : "<integer type>",
    },
    "call_depth": {
        "property_name_id"  : "<deterministic>",
        "property_name_ref" : "call_depth",
        "property_type_id"  : "<integer type>",
    },
    "source_code": {
        "property_name_id"  : "<deterministic>",
        "property_name_ref" : "source_code",
        "property_type_id"  : "<text type>",
    },
    "is_entry": {
        "property_name_id"  : "<deterministic>",
        "property_name_ref" : "is_entry",
        "property_type_id"  : "<boolean type>",
    },
    "is_external": {
        "property_name_id"  : "<deterministic>",
        "property_name_ref" : "is_external",
        "property_type_id"  : "<boolean type>",
    },
    "is_recursive": {
        "property_name_id"  : "<deterministic>",
        "property_name_ref" : "is_recursive",
        "property_type_id"  : "<boolean type>",
    },
    
    # Edge properties
    "is_conditional": {
        "property_name_id"  : "<deterministic>",
        "property_name_ref" : "is_conditional",
        "property_type_id"  : "<boolean type>",
    },
    "call_line_number": {
        "property_name_id"  : "<deterministic>",
        "property_name_ref" : "call_line_number",
        "property_type_id"  : "<integer type>",
    },
}
```

### 4.5 Property Types

```python
# Property types for validation (aligned with XSD datatypes)

property_types = {
    "string": {
        "property_type_id"  : "<deterministic>",
        "property_type_ref" : "string",
    },
    "text": {
        "property_type_id"  : "<deterministic>",
        "property_type_ref" : "text",
    },
    "integer": {
        "property_type_id"  : "<deterministic>",
        "property_type_ref" : "integer",
    },
    "boolean": {
        "property_type_id"  : "<deterministic>",
        "property_type_ref" : "boolean",
    },
}
```

### 4.6 Taxonomy Categories

```python
# Taxonomy: call_flow_taxonomy
# Hierarchical classification of node types

taxonomy = {
    "root": "code_element",
    "categories": {
        "code_element": {
            "category_id"  : "<deterministic>",
            "category_ref" : "code_element",
            "parent_id"    : None,
            "child_ids"    : ["<container>", "<callable>", "<reference>"],
        },
        "container": {
            "category_id"  : "<deterministic>",
            "category_ref" : "container",
            "parent_id"    : "<code_element>",
            "child_ids"    : [],
            # Node types: module, class
        },
        "callable": {
            "category_id"  : "<deterministic>",
            "category_ref" : "callable",
            "parent_id"    : "<code_element>",
            "child_ids"    : [],
            # Node types: method, function
        },
        "reference": {
            "category_id"  : "<deterministic>",
            "category_ref" : "reference",
            "parent_id"    : "<code_element>",
            "child_ids"    : [],
            # Node types: external
        },
    }
}
```

### 4.7 Ontology JSON File

The complete ontology will be stored as JSON:

```
osbot_utils/helpers/python_call_flow/data/
├── ontology__call_flow.json
├── taxonomy__call_flow.json
└── rules__call_flow.json        # Optional: required property rules
```

---

## 5. Technical Refactoring Specification

### 5.1 Directory Structure Changes

```
osbot_utils/helpers/python_call_flow/
│
├── __init__.py
│
├── data/                                    # NEW: Ontology definitions
│   ├── __init__.py
│   ├── ontology__call_flow.json            # Node types, predicates, properties
│   ├── taxonomy__call_flow.json            # Category hierarchy
│   └── rules__call_flow.json               # Optional: required properties
│
├── schemas/                                 # MODIFIED: Simplified
│   ├── __init__.py
│   ├── Schema__Call_Flow__Config.py        # KEEP: Analysis configuration
│   └── Schema__Call_Flow__Result.py        # NEW: Wraps semantic graph + metadata
│
├── Call_Flow__Analyzer.py                   # MODIFIED: Use builder
├── Call_Flow__AST__Extractor.py             # KEEP: AST extraction logic
├── Call_Flow__Call__Resolver.py             # KEEP: Call resolution logic
├── Call_Flow__Call__Filter.py               # KEEP: Scope control logic
├── Call_Flow__Ontology.py                   # NEW: Load/cache ontology
├── Call_Flow__Builder.py                    # NEW: Thin wrapper on Semantic_Graph__Builder
├── Call_Flow__Exporter__Mermaid.py          # MODIFIED: Use projection
│
├── DEPRECATED/                              # Files to remove after migration
│   ├── Schema__Call_Graph.py
│   ├── Schema__Call_Graph__Node.py
│   ├── Schema__Call_Graph__Edge.py
│   ├── Enum__Call_Graph__Node_Type.py
│   ├── Enum__Call_Graph__Edge_Type.py
│   ├── Call_Flow__Node__Factory.py
│   ├── Call_Flow__Edge__Factory.py
│   └── Call_Flow__Node__Registry.py
```

### 5.2 Files to DELETE (Replace with semantic_graphs)

| File | Replacement |
|------|-------------|
| `Enum__Call_Graph__Node_Type.py` | Ontology node types |
| `Enum__Call_Graph__Edge_Type.py` | Ontology predicates |
| `Schema__Call_Graph.py` | `Schema__Semantic_Graph` |
| `Schema__Call_Graph__Node.py` | `Schema__Semantic_Graph__Node` |
| `Schema__Call_Graph__Edge.py` | `Schema__Semantic_Graph__Edge` |
| `Call_Flow__Node__Factory.py` | `Semantic_Graph__Builder` |
| `Call_Flow__Edge__Factory.py` | `Semantic_Graph__Builder` |
| `Call_Flow__Node__Registry.py` | Builder helper + graph's `Dict__Nodes__By_Id` |

### 5.3 Files to KEEP (Domain-Specific Logic)

| File | Purpose | Changes Needed |
|------|---------|----------------|
| `Schema__Call_Flow__Config.py` | Analysis configuration | None (maybe add ontology_ref) |
| `Call_Flow__Analyzer.py` | Orchestrates analysis | Use builder, return semantic graph |
| `Call_Flow__AST__Extractor.py` | Extracts calls from AST | None |
| `Call_Flow__Call__Resolver.py` | Resolves call targets | None |
| `Call_Flow__Call__Filter.py` | Scope control (stdlib, etc.) | None |

### 5.4 Files to CREATE

| File | Purpose |
|------|---------|
| `Call_Flow__Ontology.py` | Load and cache call flow ontology/taxonomy |
| `Call_Flow__Builder.py` | Thin wrapper providing call-flow-specific builder methods |
| `Schema__Call_Flow__Result.py` | Wrapper holding semantic graph + analysis metadata |

### 5.5 Files to MODIFY

| File | Modification |
|------|--------------|
| `Call_Flow__Exporter__Mermaid.py` | Work with `Projected__Semantic_Graph` instead of custom schema |

---

## 6. Implementation Details

### 6.1 Call_Flow__Ontology

```python
from osbot_utils.type_safe.Type_Safe                                          import Type_Safe
from osbot_utils.helpers.semantic_graphs.registries.Ontology__Registry        import Ontology__Registry
from osbot_utils.helpers.semantic_graphs.registries.Taxonomy__Registry        import Taxonomy__Registry
from osbot_utils.helpers.semantic_graphs.schemas.ontology.Schema__Ontology    import Schema__Ontology
from osbot_utils.helpers.semantic_graphs.schemas.taxonomy.Schema__Taxonomy    import Schema__Taxonomy

ONTOLOGY_PATH = Path(__file__).parent / 'data' / 'ontology__call_flow.json'
TAXONOMY_PATH = Path(__file__).parent / 'data' / 'taxonomy__call_flow.json'


class Call_Flow__Ontology(Type_Safe):
    """Loads and caches the call flow ontology and taxonomy."""
    
    ontology_registry : Ontology__Registry = None
    taxonomy_registry : Taxonomy__Registry = None
    ontology          : Schema__Ontology   = None
    taxonomy          : Schema__Taxonomy   = None
    
    def setup(self) -> 'Call_Flow__Ontology':
        """Load ontology and taxonomy from JSON files."""
        self.ontology_registry = Ontology__Registry()
        self.taxonomy_registry = Taxonomy__Registry()
        
        self.ontology = self.ontology_registry.load_from_json(ONTOLOGY_PATH)
        self.taxonomy = self.taxonomy_registry.load_from_json(TAXONOMY_PATH)
        
        return self
    
    def node_type_id(self, ref: str) -> Node_Type_Id:
        """Get node type ID by ref (e.g., 'class', 'method')."""
        return self.ontology_registry.node_type_id_by_ref(ref)
    
    def predicate_id(self, ref: str) -> Predicate_Id:
        """Get predicate ID by ref (e.g., 'calls', 'contains')."""
        return self.ontology_registry.predicate_id_by_ref(ref)
    
    def property_name_id(self, ref: str) -> Property_Name_Id:
        """Get property name ID by ref (e.g., 'line_number')."""
        return self.ontology_registry.property_name_id_by_ref(ref)
```

### 6.2 Call_Flow__Builder

```python
from osbot_utils.type_safe.Type_Safe                                          import Type_Safe
from osbot_utils.helpers.semantic_graphs.builders.Semantic_Graph__Builder     import Semantic_Graph__Builder
from osbot_utils.helpers.python_call_flow.Call_Flow__Ontology                 import Call_Flow__Ontology


class Call_Flow__Builder(Type_Safe):
    """Call-flow-specific builder wrapping Semantic_Graph__Builder."""
    
    ontology      : Call_Flow__Ontology      = None
    builder       : Semantic_Graph__Builder  = None
    name_to_id    : dict                     = None    # qualified_name → Node_Id
    
    def setup(self) -> 'Call_Flow__Builder':
        """Initialize builder with call flow ontology."""
        self.ontology = Call_Flow__Ontology().setup()
        self.builder  = Semantic_Graph__Builder(ontology_id=self.ontology.ontology.ontology_id)
        self.name_to_id = {}
        return self
    
    # ─────────────────────────────────────────────────────────────────────────
    # Node Creation (domain-specific convenience methods)
    # ─────────────────────────────────────────────────────────────────────────
    
    def add_class(self, name: str, qualified_name: str, **properties) -> Node_Id:
        """Add a class node."""
        return self._add_node('class', name, qualified_name, **properties)
    
    def add_method(self, name: str, qualified_name: str, **properties) -> Node_Id:
        """Add a method node."""
        return self._add_node('method', name, qualified_name, **properties)
    
    def add_function(self, name: str, qualified_name: str, **properties) -> Node_Id:
        """Add a function node."""
        return self._add_node('function', name, qualified_name, **properties)
    
    def add_module(self, name: str, qualified_name: str, **properties) -> Node_Id:
        """Add a module node."""
        return self._add_node('module', name, qualified_name, **properties)
    
    def add_external(self, name: str, qualified_name: str, **properties) -> Node_Id:
        """Add an external reference node."""
        return self._add_node('external', name, qualified_name, **properties)
    
    def _add_node(self, type_ref: str, name: str, qualified_name: str, **properties) -> Node_Id:
        """Internal: Add node with type and properties."""
        node_type_id = self.ontology.node_type_id(type_ref)
        
        # Use qualified_name as seed for deterministic ID
        node_id = self.builder.add_node(
            node_type_id = node_type_id,
            name         = Safe_Str__Id(name),
            seed         = qualified_name,                                    # Deterministic ID
        )
        
        # Add qualified_name as property
        self.builder.add_node_property(
            node_id          = node_id,
            property_name_id = self.ontology.property_name_id('qualified_name'),
            value            = Safe_Str__Text(qualified_name),
        )
        
        # Add additional properties
        for prop_ref, value in properties.items():
            self.builder.add_node_property(
                node_id          = node_id,
                property_name_id = self.ontology.property_name_id(prop_ref),
                value            = Safe_Str__Text(str(value)),
            )
        
        # Track name → ID mapping
        self.name_to_id[qualified_name] = node_id
        
        return node_id
    
    # ─────────────────────────────────────────────────────────────────────────
    # Edge Creation (domain-specific convenience methods)
    # ─────────────────────────────────────────────────────────────────────────
    
    def add_contains(self, container_id: Node_Id, contained_id: Node_Id) -> Edge_Id:
        """Add containment edge (class contains method, module contains class)."""
        return self._add_edge('contains', container_id, contained_id)
    
    def add_calls(self, caller_id: Node_Id, callee_id: Node_Id, **properties) -> Edge_Id:
        """Add call edge (method calls function)."""
        return self._add_edge('calls', caller_id, callee_id, **properties)
    
    def add_calls_self(self, caller_id: Node_Id, callee_id: Node_Id, **properties) -> Edge_Id:
        """Add self-call edge (self.method() within same class)."""
        return self._add_edge('calls_self', caller_id, callee_id, **properties)
    
    def add_calls_chain(self, caller_id: Node_Id, callee_id: Node_Id, **properties) -> Edge_Id:
        """Add chain call edge (obj.attr.method())."""
        return self._add_edge('calls_chain', caller_id, callee_id, **properties)
    
    def _add_edge(self, predicate_ref: str, from_id: Node_Id, to_id: Node_Id, **properties) -> Edge_Id:
        """Internal: Add edge with predicate and properties."""
        predicate_id = self.ontology.predicate_id(predicate_ref)
        
        edge_id = self.builder.add_edge(
            from_node_id = from_id,
            to_node_id   = to_id,
            predicate_id = predicate_id,
        )
        
        # Add edge properties
        for prop_ref, value in properties.items():
            self.builder.add_edge_property(
                edge_id          = edge_id,
                property_name_id = self.ontology.property_name_id(prop_ref),
                value            = Safe_Str__Text(str(value)),
            )
        
        return edge_id
    
    # ─────────────────────────────────────────────────────────────────────────
    # Registry Helpers
    # ─────────────────────────────────────────────────────────────────────────
    
    def lookup_node_id(self, qualified_name: str) -> Node_Id | None:
        """Look up node ID by qualified name."""
        return self.name_to_id.get(qualified_name)
    
    def node_exists(self, qualified_name: str) -> bool:
        """Check if node already exists."""
        return qualified_name in self.name_to_id
    
    # ─────────────────────────────────────────────────────────────────────────
    # Build
    # ─────────────────────────────────────────────────────────────────────────
    
    def build(self) -> Schema__Semantic_Graph:
        """Build and return the semantic graph."""
        return self.builder.build()
    
    def validate(self) -> List[str]:
        """Validate graph against ontology rules."""
        return self.builder.validate()
```

### 6.3 Schema__Call_Flow__Result

```python
from osbot_utils.type_safe.Type_Safe                                           import Type_Safe
from osbot_utils.helpers.semantic_graphs.schemas.graph.Schema__Semantic_Graph  import Schema__Semantic_Graph
from osbot_utils.helpers.python_call_flow.schemas.Schema__Call_Flow__Config    import Schema__Call_Flow__Config


class Schema__Call_Flow__Result(Type_Safe):
    """Result of call flow analysis: semantic graph + analysis metadata."""
    
    graph          : Schema__Semantic_Graph                                    # The call flow graph
    config         : Schema__Call_Flow__Config                                 # Analysis configuration used
    entry_point    : str                                                       # Entry point analyzed
    node_count     : int                         = 0                           # Total nodes
    edge_count     : int                         = 0                           # Total edges
    max_depth      : int                         = 0                           # Maximum call depth reached
    validation_errors : list                     = None                        # Any validation errors
```

### 6.4 Modified Call_Flow__Analyzer

```python
from osbot_utils.type_safe.Type_Safe                                          import Type_Safe
from osbot_utils.helpers.python_call_flow.Call_Flow__Builder                  import Call_Flow__Builder
from osbot_utils.helpers.python_call_flow.Call_Flow__AST__Extractor           import Call_Flow__AST__Extractor
from osbot_utils.helpers.python_call_flow.Call_Flow__Call__Resolver           import Call_Flow__Call__Resolver
from osbot_utils.helpers.python_call_flow.Call_Flow__Call__Filter             import Call_Flow__Call__Filter
from osbot_utils.helpers.python_call_flow.schemas.Schema__Call_Flow__Config   import Schema__Call_Flow__Config
from osbot_utils.helpers.python_call_flow.schemas.Schema__Call_Flow__Result   import Schema__Call_Flow__Result


class Call_Flow__Analyzer(Type_Safe):
    """Analyzes Python call flows using semantic graph framework."""
    
    config        : Schema__Call_Flow__Config  = None
    builder       : Call_Flow__Builder         = None
    ast_extractor : Call_Flow__AST__Extractor  = None
    resolver      : Call_Flow__Call__Resolver  = None
    filter        : Call_Flow__Call__Filter    = None
    visited       : set                        = None
    
    def __enter__(self):
        self.setup()
        return self
    
    def __exit__(self, *args):
        pass
    
    def setup(self) -> 'Call_Flow__Analyzer':
        """Initialize analyzer components."""
        self.config        = self.config or Schema__Call_Flow__Config()
        self.builder       = Call_Flow__Builder().setup()
        self.ast_extractor = Call_Flow__AST__Extractor()
        self.resolver      = Call_Flow__Call__Resolver()
        self.filter        = Call_Flow__Call__Filter(config=self.config)
        self.visited       = set()
        return self
    
    def analyze(self, target) -> Schema__Call_Flow__Result:
        """Analyze target (class or function) and return call flow result."""
        self.setup()                                                          # Reset state
        
        entry_point = self._get_qualified_name(target)
        
        if inspect.isclass(target):
            self._analyze_class(target, depth=0, is_entry=True)
        elif inspect.isfunction(target) or inspect.ismethod(target):
            self._analyze_function(target, depth=0, is_entry=True)
        else:
            raise ValueError(f"Cannot analyze {type(target)}")
        
        graph = self.builder.build()
        validation_errors = self.builder.validate()
        
        return Schema__Call_Flow__Result(
            graph             = graph,
            config            = self.config,
            entry_point       = entry_point,
            node_count        = len(graph.nodes),
            edge_count        = len(graph.edges),
            max_depth         = self._calculate_max_depth(),
            validation_errors = validation_errors,
        )
    
    def _analyze_class(self, cls, depth: int, is_entry: bool = False):
        """Analyze a class and its methods."""
        qualified_name = self._get_qualified_name(cls)
        
        if qualified_name in self.visited:
            return self.builder.lookup_node_id(qualified_name)
        self.visited.add(qualified_name)
        
        # Create class node
        class_id = self.builder.add_class(
            name           = cls.__name__,
            qualified_name = qualified_name,
            module_name    = cls.__module__,
            file_path      = self._get_file_path(cls),
            call_depth     = depth,
            is_entry       = is_entry,
        )
        
        # Analyze methods
        for name, method in inspect.getmembers(cls, predicate=inspect.isfunction):
            if not self.filter.should_include_method(name):
                continue
            
            method_id = self._analyze_function(
                method, 
                depth      = depth + 1,
                is_entry   = False,
                class_name = qualified_name,
            )
            
            if method_id:
                self.builder.add_contains(class_id, method_id)
        
        return class_id
    
    def _analyze_function(self, func, depth: int, is_entry: bool = False, class_name: str = None):
        """Analyze a function/method and its calls."""
        qualified_name = self._get_qualified_name(func)
        
        if qualified_name in self.visited:
            return self.builder.lookup_node_id(qualified_name)
        self.visited.add(qualified_name)
        
        if depth > self.config.max_depth:
            return None
        
        # Determine node type
        is_method = class_name is not None
        
        # Create node
        if is_method:
            node_id = self.builder.add_method(
                name           = func.__name__,
                qualified_name = qualified_name,
                module_name    = func.__module__,
                file_path      = self._get_file_path(func),
                line_number    = self._get_line_number(func),
                call_depth     = depth,
                is_entry       = is_entry,
            )
        else:
            node_id = self.builder.add_function(
                name           = func.__name__,
                qualified_name = qualified_name,
                module_name    = func.__module__,
                file_path      = self._get_file_path(func),
                line_number    = self._get_line_number(func),
                call_depth     = depth,
                is_entry       = is_entry,
            )
        
        # Extract and process calls
        calls = self.ast_extractor.extract_calls(func)
        
        for call in calls:
            self._process_call(node_id, call, depth, class_name)
        
        return node_id
    
    def _process_call(self, caller_id: Node_Id, call, depth: int, class_name: str):
        """Process a single call and create appropriate edge."""
        resolved = self.resolver.resolve(call, class_name)
        
        if not resolved:
            return
        
        if not self.filter.should_follow(resolved):
            # Create external node
            callee_id = self.builder.add_external(
                name           = resolved.name,
                qualified_name = resolved.qualified_name,
                is_external    = True,
            )
        else:
            # Recursively analyze
            callee_id = self._analyze_target(resolved, depth + 1)
        
        if callee_id:
            # Determine edge type
            if resolved.is_self_call:
                self.builder.add_calls_self(
                    caller_id, 
                    callee_id,
                    call_line_number = call.line_number,
                    is_conditional   = call.is_conditional,
                )
            elif resolved.is_chain_call:
                self.builder.add_calls_chain(
                    caller_id,
                    callee_id,
                    call_line_number = call.line_number,
                    is_conditional   = call.is_conditional,
                )
            else:
                self.builder.add_calls(
                    caller_id,
                    callee_id,
                    call_line_number = call.line_number,
                    is_conditional   = call.is_conditional,
                )
    
    # ... (helper methods: _get_qualified_name, _get_file_path, etc.)
```

### 6.5 Modified Call_Flow__Exporter__Mermaid

```python
from osbot_utils.type_safe.Type_Safe                                                import Type_Safe
from osbot_utils.helpers.semantic_graphs.projectors.Semantic_Graph__Projector       import Semantic_Graph__Projector
from osbot_utils.helpers.semantic_graphs.schemas.projected.Schema__Projected__Semantic_Graph import Schema__Projected__Semantic_Graph
from osbot_utils.helpers.python_call_flow.schemas.Schema__Call_Flow__Result         import Schema__Call_Flow__Result


class Call_Flow__Exporter__Mermaid(Type_Safe):
    """Export call flow graph to Mermaid diagram format."""
    
    projector : Semantic_Graph__Projector = None
    
    def setup(self) -> 'Call_Flow__Exporter__Mermaid':
        self.projector = Semantic_Graph__Projector()
        return self
    
    def export(self, result: Schema__Call_Flow__Result) -> str:
        """Export call flow result to Mermaid flowchart."""
        # Project graph to human-readable form
        projected = self.projector.project(result.graph)
        
        return self._render_mermaid(projected)
    
    def _render_mermaid(self, projected: Schema__Projected__Semantic_Graph) -> str:
        """Render projected graph as Mermaid flowchart."""
        lines = ['flowchart TD']
        
        # Render nodes
        for node in projected.projection.nodes:
            node_id = self._sanitize_id(node.name)
            shape = self._get_shape(node.ref)
            lines.append(f'    {node_id}{shape}')
        
        # Render edges
        for edge in projected.projection.edges:
            from_id = self._sanitize_id(edge.from_name)
            to_id   = self._sanitize_id(edge.to_name)
            arrow   = self._get_arrow(edge.ref)
            label   = self._get_label(edge.ref)
            
            if label:
                lines.append(f'    {from_id} {arrow}|{label}| {to_id}')
            else:
                lines.append(f'    {from_id} {arrow} {to_id}')
        
        return '\n'.join(lines)
    
    def _get_shape(self, node_type_ref: str) -> str:
        """Get Mermaid shape for node type."""
        shapes = {
            'class'   : '["{name}"]',      # Rectangle
            'method'  : '("{name}")',      # Rounded rectangle
            'function': '("{name}")',      # Rounded rectangle
            'module'  : '[["{name}"]]',    # Subroutine shape
            'external': '>"{name}"]',      # Asymmetric
        }
        return shapes.get(node_type_ref, '["{name}"]')
    
    def _get_arrow(self, predicate_ref: str) -> str:
        """Get Mermaid arrow for predicate."""
        arrows = {
            'contains'    : '-->',
            'calls'       : '-->',
            'calls_self'  : '-.->',        # Dotted (self call)
            'calls_chain' : '==>',         # Thick (chain call)
        }
        return arrows.get(predicate_ref, '-->')
    
    def _get_label(self, predicate_ref: str) -> str:
        """Get edge label for predicate."""
        labels = {
            'contains'    : None,          # No label for containment
            'calls'       : None,          # No label for simple calls
            'calls_self'  : 'self',
            'calls_chain' : 'chain',
        }
        return labels.get(predicate_ref)
    
    def _sanitize_id(self, name: str) -> str:
        """Sanitize name for Mermaid ID."""
        return name.replace('.', '_').replace(' ', '_')
```

---

## 7. Ontology JSON Files

### 7.1 ontology__call_flow.json

```json
{
    "ontology_id": "<generated from seed>",
    "ontology_ref": "call_flow",
    "taxonomy_id": "<taxonomy id>",
    "version": "1.0.0",
    
    "node_types": {
        "<class_type_id>": {
            "node_type_id": "<class_type_id>",
            "node_type_ref": "class",
            "category_id": "<container_category_id>"
        },
        "<method_type_id>": {
            "node_type_id": "<method_type_id>",
            "node_type_ref": "method",
            "category_id": "<callable_category_id>"
        },
        "<function_type_id>": {
            "node_type_id": "<function_type_id>",
            "node_type_ref": "function",
            "category_id": "<callable_category_id>"
        },
        "<module_type_id>": {
            "node_type_id": "<module_type_id>",
            "node_type_ref": "module",
            "category_id": "<container_category_id>"
        },
        "<external_type_id>": {
            "node_type_id": "<external_type_id>",
            "node_type_ref": "external",
            "category_id": "<reference_category_id>"
        }
    },
    
    "predicates": {
        "<contains_id>": {
            "predicate_id": "<contains_id>",
            "predicate_ref": "contains",
            "inverse_id": "<contained_by_id>"
        },
        "<contained_by_id>": {
            "predicate_id": "<contained_by_id>",
            "predicate_ref": "contained_by",
            "inverse_id": "<contains_id>"
        },
        "<calls_id>": {
            "predicate_id": "<calls_id>",
            "predicate_ref": "calls",
            "inverse_id": "<called_by_id>"
        },
        "<called_by_id>": {
            "predicate_id": "<called_by_id>",
            "predicate_ref": "called_by",
            "inverse_id": "<calls_id>"
        },
        "<calls_self_id>": {
            "predicate_id": "<calls_self_id>",
            "predicate_ref": "calls_self",
            "inverse_id": null
        },
        "<calls_chain_id>": {
            "predicate_id": "<calls_chain_id>",
            "predicate_ref": "calls_chain",
            "inverse_id": null
        }
    },
    
    "property_names": {
        "<qualified_name_prop_id>": {
            "property_name_id": "<qualified_name_prop_id>",
            "property_name_ref": "qualified_name",
            "property_type_id": "<string_type_id>"
        },
        "<module_name_prop_id>": {
            "property_name_id": "<module_name_prop_id>",
            "property_name_ref": "module_name",
            "property_type_id": "<string_type_id>"
        },
        "<file_path_prop_id>": {
            "property_name_id": "<file_path_prop_id>",
            "property_name_ref": "file_path",
            "property_type_id": "<string_type_id>"
        },
        "<line_number_prop_id>": {
            "property_name_id": "<line_number_prop_id>",
            "property_name_ref": "line_number",
            "property_type_id": "<integer_type_id>"
        },
        "<call_depth_prop_id>": {
            "property_name_id": "<call_depth_prop_id>",
            "property_name_ref": "call_depth",
            "property_type_id": "<integer_type_id>"
        },
        "<source_code_prop_id>": {
            "property_name_id": "<source_code_prop_id>",
            "property_name_ref": "source_code",
            "property_type_id": "<text_type_id>"
        },
        "<is_entry_prop_id>": {
            "property_name_id": "<is_entry_prop_id>",
            "property_name_ref": "is_entry",
            "property_type_id": "<boolean_type_id>"
        },
        "<is_external_prop_id>": {
            "property_name_id": "<is_external_prop_id>",
            "property_name_ref": "is_external",
            "property_type_id": "<boolean_type_id>"
        },
        "<is_recursive_prop_id>": {
            "property_name_id": "<is_recursive_prop_id>",
            "property_name_ref": "is_recursive",
            "property_type_id": "<boolean_type_id>"
        },
        "<is_conditional_prop_id>": {
            "property_name_id": "<is_conditional_prop_id>",
            "property_name_ref": "is_conditional",
            "property_type_id": "<boolean_type_id>"
        },
        "<call_line_number_prop_id>": {
            "property_name_id": "<call_line_number_prop_id>",
            "property_name_ref": "call_line_number",
            "property_type_id": "<integer_type_id>"
        }
    },
    
    "property_types": {
        "<string_type_id>": {
            "property_type_id": "<string_type_id>",
            "property_type_ref": "string"
        },
        "<text_type_id>": {
            "property_type_id": "<text_type_id>",
            "property_type_ref": "text"
        },
        "<integer_type_id>": {
            "property_type_id": "<integer_type_id>",
            "property_type_ref": "integer"
        },
        "<boolean_type_id>": {
            "property_type_id": "<boolean_type_id>",
            "property_type_ref": "boolean"
        }
    },
    
    "edge_rules": [
        {"source_type_id": "<module_type_id>",   "predicate_id": "<contains_id>",    "target_type_id": "<class_type_id>"},
        {"source_type_id": "<module_type_id>",   "predicate_id": "<contains_id>",    "target_type_id": "<function_type_id>"},
        {"source_type_id": "<class_type_id>",    "predicate_id": "<contains_id>",    "target_type_id": "<method_type_id>"},
        
        {"source_type_id": "<method_type_id>",   "predicate_id": "<calls_id>",       "target_type_id": "<method_type_id>"},
        {"source_type_id": "<method_type_id>",   "predicate_id": "<calls_id>",       "target_type_id": "<function_type_id>"},
        {"source_type_id": "<method_type_id>",   "predicate_id": "<calls_id>",       "target_type_id": "<external_type_id>"},
        {"source_type_id": "<function_type_id>", "predicate_id": "<calls_id>",       "target_type_id": "<method_type_id>"},
        {"source_type_id": "<function_type_id>", "predicate_id": "<calls_id>",       "target_type_id": "<function_type_id>"},
        {"source_type_id": "<function_type_id>", "predicate_id": "<calls_id>",       "target_type_id": "<external_type_id>"},
        
        {"source_type_id": "<method_type_id>",   "predicate_id": "<calls_self_id>",  "target_type_id": "<method_type_id>"},
        
        {"source_type_id": "<method_type_id>",   "predicate_id": "<calls_chain_id>", "target_type_id": "<method_type_id>"},
        {"source_type_id": "<method_type_id>",   "predicate_id": "<calls_chain_id>", "target_type_id": "<external_type_id>"},
        {"source_type_id": "<function_type_id>", "predicate_id": "<calls_chain_id>", "target_type_id": "<method_type_id>"},
        {"source_type_id": "<function_type_id>", "predicate_id": "<calls_chain_id>", "target_type_id": "<external_type_id>"}
    ]
}
```

### 7.2 taxonomy__call_flow.json

```json
{
    "taxonomy_id": "<generated from seed>",
    "taxonomy_ref": "call_flow_taxonomy",
    "version": "1.0.0",
    "root_id": "<code_element_id>",
    
    "categories": {
        "<code_element_id>": {
            "category_id": "<code_element_id>",
            "category_ref": "code_element",
            "parent_id": null,
            "child_ids": ["<container_id>", "<callable_id>", "<reference_id>"]
        },
        "<container_id>": {
            "category_id": "<container_id>",
            "category_ref": "container",
            "parent_id": "<code_element_id>",
            "child_ids": []
        },
        "<callable_id>": {
            "category_id": "<callable_id>",
            "category_ref": "callable",
            "parent_id": "<code_element_id>",
            "child_ids": []
        },
        "<reference_id>": {
            "category_id": "<reference_id>",
            "category_ref": "reference",
            "parent_id": "<code_element_id>",
            "child_ids": []
        }
    }
}
```

---

## 8. Implementation Checklist

### Phase 1: Ontology Definition

- [ ] Create `osbot_utils/helpers/python_call_flow/data/` directory
- [ ] Create `ontology__call_flow.json` with all node types, predicates, properties
- [ ] Create `taxonomy__call_flow.json` with category hierarchy
- [ ] Use deterministic IDs from stable seeds (e.g., `call_flow:node_type:class`)
- [ ] Validate ontology loads correctly via `Ontology__Registry`

### Phase 2: Core Infrastructure

- [ ] Create `Call_Flow__Ontology.py` — load/cache ontology and taxonomy
- [ ] Create `Call_Flow__Builder.py` — domain-specific builder wrapper
- [ ] Create `Schema__Call_Flow__Result.py` — result container
- [ ] Write unit tests for all new classes

### Phase 3: Analyzer Refactoring

- [ ] Modify `Call_Flow__Analyzer.py` to use `Call_Flow__Builder`
- [ ] Replace `Schema__Call_Graph` usage with `Schema__Semantic_Graph`
- [ ] Update node creation to use builder methods
- [ ] Update edge creation to use builder methods
- [ ] Add properties instead of flat attributes
- [ ] Return `Schema__Call_Flow__Result` from `analyze()`
- [ ] Update all analyzer tests

### Phase 4: Exporter Refactoring

- [ ] Modify `Call_Flow__Exporter__Mermaid.py` to use projections
- [ ] Project graph before rendering
- [ ] Use `Projected__Node` and `Projected__Edge` for rendering
- [ ] Update exporter tests

### Phase 5: Cleanup

- [ ] Move deprecated files to `DEPRECATED/` directory
- [ ] Update all imports throughout codebase
- [ ] Run full test suite
- [ ] Remove `DEPRECATED/` directory after verification

### Phase 6: Documentation

- [ ] Update module docstrings
- [ ] Update README if applicable
- [ ] Create usage examples

---

## 9. Testing Strategy

### 9.1 Unit Tests for New Classes

```python
class test_Call_Flow__Ontology(TestCase):
    
    def test__setup__loads_ontology(self):
        ontology = Call_Flow__Ontology().setup()
        
        assert ontology.ontology is not None
        assert ontology.taxonomy is not None
    
    def test__node_type_id__returns_correct_id(self):
        ontology = Call_Flow__Ontology().setup()
        
        class_id = ontology.node_type_id('class')
        method_id = ontology.node_type_id('method')
        
        assert class_id is not None
        assert method_id is not None
        assert class_id != method_id


class test_Call_Flow__Builder(TestCase):
    
    def test__add_class__creates_node_with_properties(self):
        with graph_deterministic_ids():
            builder = Call_Flow__Builder().setup()
            
            class_id = builder.add_class(
                name           = 'MyClass',
                qualified_name = 'mymodule.MyClass',
                line_number    = 10,
            )
            
            graph = builder.build()
            node = graph.nodes.get(class_id)
            
            assert node is not None
            assert node.name == Safe_Str__Id('MyClass')
    
    def test__add_calls__creates_edge(self):
        with graph_deterministic_ids():
            builder = Call_Flow__Builder().setup()
            
            method1_id = builder.add_method('method1', 'MyClass.method1')
            method2_id = builder.add_method('method2', 'MyClass.method2')
            
            edge_id = builder.add_calls(method1_id, method2_id)
            
            graph = builder.build()
            
            assert len(graph.edges) == 1
            assert graph.edges[0].from_node_id == method1_id
            assert graph.edges[0].to_node_id == method2_id
```

### 9.2 Integration Tests

```python
class test_Call_Flow__Analyzer__Integration(TestCase):
    
    def test__analyze__class__produces_valid_semantic_graph(self):
        with graph_deterministic_ids():
            analyzer = Call_Flow__Analyzer()
            result = analyzer.analyze(Sample__Processor)
            
            # Result is a Schema__Call_Flow__Result
            assert isinstance(result.graph, Schema__Semantic_Graph)
            assert result.node_count > 0
            assert result.edge_count > 0
    
    def test__analyze__validates_against_ontology(self):
        with graph_deterministic_ids():
            analyzer = Call_Flow__Analyzer()
            result = analyzer.analyze(Sample__Processor)
            
            # No validation errors
            assert result.validation_errors == []
    
    def test__meta__self_analysis(self):
        """Analyzer can analyze itself."""
        with graph_deterministic_ids():
            analyzer = Call_Flow__Analyzer()
            result = analyzer.analyze(Call_Flow__Analyzer)
            
            assert result.node_count >= 5
            assert 'analyze' in result.entry_point or 'Call_Flow__Analyzer' in result.entry_point
```

### 9.3 Export Tests

```python
class test_Call_Flow__Exporter__Mermaid__Integration(TestCase):
    
    def test__export__produces_valid_mermaid(self):
        analyzer = Call_Flow__Analyzer()
        result = analyzer.analyze(Sample__Processor)
        
        exporter = Call_Flow__Exporter__Mermaid().setup()
        mermaid = exporter.export(result)
        
        assert 'flowchart TD' in mermaid
        assert 'Sample__Processor' in mermaid or 'sample' in mermaid.lower()
```

---

## 10. Success Criteria

### 10.1 Functional Requirements

- [ ] `Call_Flow__Analyzer.analyze()` returns `Schema__Call_Flow__Result` with valid semantic graph
- [ ] All node types (class, method, function, module, external) correctly mapped
- [ ] All edge types (contains, calls, calls_self, calls_chain) correctly mapped
- [ ] Properties (line_number, file_path, etc.) stored on nodes/edges
- [ ] Mermaid export works with projected graph
- [ ] Ontology validation passes for all generated graphs

### 10.2 Non-Functional Requirements

- [ ] No regressions in analysis accuracy
- [ ] All existing tests pass (after updates)
- [ ] New capability: taxonomy-based grouping available
- [ ] New capability: validation errors reported

### 10.3 Verification Test

```python
def test__full_workflow(self):
    """Complete workflow from analysis to export."""
    
    # 1. Analyze
    analyzer = Call_Flow__Analyzer()
    result = analyzer.analyze(Sample__Processor)
    
    # 2. Verify semantic graph structure
    assert isinstance(result.graph, Schema__Semantic_Graph)
    assert result.graph.ontology_id is not None
    
    # 3. Verify validation
    assert result.validation_errors == []
    
    # 4. Project for human readability
    projector = Semantic_Graph__Projector()
    projected = projector.project(result.graph)
    
    # 5. Verify projection has no IDs, only refs and names
    json_str = projected.projection.json()
    assert 'node_id' not in json_str
    assert 'ref' in json_str
    assert 'name' in json_str
    
    # 6. Export to Mermaid
    exporter = Call_Flow__Exporter__Mermaid().setup()
    mermaid = exporter.export(result)
    
    assert 'flowchart TD' in mermaid
```

---

## 11. Migration Notes

### 11.1 Breaking Changes

The refactoring changes the public API:

| Before | After |
|--------|-------|
| `analyzer.analyze() → Schema__Call_Graph` | `analyzer.analyze() → Schema__Call_Flow__Result` |
| `result.nodes` (dict of custom nodes) | `result.graph.nodes` (Dict__Nodes__By_Id) |
| `result.edges` (list of custom edges) | `result.graph.edges` (List__Semantic_Graph__Edges) |
| `node.module` (attribute) | `node.properties['module_name']` |
| `node.line_number` (attribute) | `node.properties['line_number']` |

### 11.2 Migration Path for Consumers

If external code uses the current API:

```python
# Before
result = analyzer.analyze(MyClass)
for node_id, node in result.nodes.items():
    print(f"{node.name} in {node.module}")

# After
result = analyzer.analyze(MyClass)
for node_id, node in result.graph.nodes.items():
    module = node.properties.get(module_name_prop_id, '')
    print(f"{node.name} in {module}")

# Or use projection for human-readable access
projected = Semantic_Graph__Projector().project(result.graph)
for node in projected.projection.nodes:
    print(f"{node.name} ({node.ref})")
```

### 11.3 Deprecation Period

Since this is internal tooling, we can:
1. Keep old files in `DEPRECATED/` for reference during migration
2. Remove after all tests pass with new implementation
3. No external deprecation notices needed

---

## 12. Summary

### 12.1 What This Achieves

| Requirement | How Addressed |
|-------------|---------------|
| **Reuse semantic_graphs** | Call flow becomes a domain application of the framework |
| **Ontology-based validation** | Edge rules catch invalid connections |
| **Typed properties** | Properties have optional type validation |
| **Taxonomy grouping** | Node types categorized (container, callable, reference) |
| **Human-readable output** | Projector generates ref-based views |
| **Standards alignment** | RDF/OWL compatible graph structure |
| **Reduced code** | Delete ~8 files, leverage framework instead |

### 12.2 The Complete Architecture

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                         CALL FLOW AS SEMANTIC GRAPH                               │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                   │
│  DOMAIN LAYER (python_call_flow)                                                  │
│  ════════════════════════════════                                                 │
│                                                                                   │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐                   │
│  │ Call_Flow__     │  │ Call_Flow__     │  │ Call_Flow__     │                   │
│  │ Analyzer        │  │ Builder         │  │ Ontology        │                   │
│  │                 │  │                 │  │                 │                   │
│  │ • Orchestrates  │  │ • Domain API    │  │ • Load ontology │                   │
│  │ • Uses builder  │  │ • add_class()   │  │ • Lookup IDs    │                   │
│  │ • AST extraction│  │ • add_method()  │  │ • Cache         │                   │
│  └────────┬────────┘  │ • add_calls()   │  └─────────────────┘                   │
│           │           └────────┬────────┘                                         │
│           │                    │                                                  │
│           │                    │ uses                                             │
│           │                    ▼                                                  │
│  ─────────┼────────────────────────────────────────────────────────────────────  │
│           │                                                                       │
│  FRAMEWORK LAYER (semantic_graphs)                                                │
│  ══════════════════════════════════                                               │
│           │                                                                       │
│           │           ┌─────────────────┐  ┌─────────────────┐                   │
│           │           │ Semantic_Graph__│  │ Semantic_Graph__│                   │
│           │           │ Builder         │  │ Validator       │                   │
│           │           └────────┬────────┘  └────────┬────────┘                   │
│           │                    │                    │                             │
│           │                    ▼                    ▼                             │
│           │           ┌─────────────────────────────────────┐                    │
│           └──────────►│       Schema__Semantic_Graph        │                    │
│                       │  • nodes: Dict__Nodes__By_Id        │                    │
│                       │  • edges: List__Semantic_Graph__Edges│                    │
│                       │  • ontology_id (FK)                 │                    │
│                       └────────────────┬────────────────────┘                    │
│                                        │                                          │
│                                        │ project()                                │
│                                        ▼                                          │
│                       ┌─────────────────────────────────────┐                    │
│                       │    Projected__Semantic_Graph        │                    │
│                       │  • projection (nodes, edges by ref) │                    │
│                       │  • references (ref → id mappings)   │                    │
│                       │  • sources (provenance)             │                    │
│                       └─────────────────────────────────────┘                    │
│                                                                                   │
└──────────────────────────────────────────────────────────────────────────────────┘
```

### 12.3 Next Steps After This Brief

1. **Implement Brief 4.0** — This document
2. **Brief 5.0** — Code Structure Graph (module→package→class→method hierarchy)
3. **Brief 6.0** — Combined Analysis (call flow + code structure + references)
4. **Brief 7.0** — Interactive Visualization (browser-based graph explorer)

---

*End of Implementation Brief*
