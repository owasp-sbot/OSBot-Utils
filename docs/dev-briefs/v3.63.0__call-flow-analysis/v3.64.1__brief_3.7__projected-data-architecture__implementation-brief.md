# (Brief 3.7) Projected Data Architecture

**Version:** v3.64.0  
**Status:** Extension to Brief 3.5  
**Target:** OSBot-Utils (`osbot_utils.helpers.semantic_graphs`)  
**Created:** January 2026  
**Prerequisites:** Brief 3.5 (ID/Ref Architecture) in progress  
**Enables:** Human-readable exports, visualization, debugging  

---

## 1. Document Purpose

This brief introduces the **Projected Data** pattern as an architectural extension to Brief 3.5. It addresses a fundamental tension discovered during implementation:

> **The Problem:** We want ID-based referential integrity for data storage and graph operations, but we also need human-readable representations for visualization, debugging, and understanding.

> **The Solution:** Separate the concerns into two complementary layers:
> - **Schema__ (Master):** ID-based, graph-friendly, source of truth
> - **Projected__ (Derived):** Ref-based, human-readable, generated for understanding

**Key Insight:** This is **not** a round-trip transformation. The projection is **generated** — it's a one-way view designed for human consumption. If you need to modify data, you work with Schema__ directly.

**Audience:** Developers implementing Brief 3.5 who need to understand how the Projected layer completes the architecture.

---

## 2. Design Principles

The following principles guided every decision in this architecture. Understanding them is essential for extending or modifying the design.

### Principle 1: Projections Are Generated, Not Edited

```
Schema__ (Source of Truth) ────► Projected__ (Generated View)
                           
         NO ROUND-TRIP ◄────────────────────────────────────
```

A projection is like a report generated from a database — you read it, you don't edit it. This is fundamentally different from serialization/deserialization where round-trips are expected.

**Why this matters:**
- Projections can be regenerated at any time
- No synchronization complexity
- Schema__ remains the single source of truth
- Projections are disposable artifacts

### Principle 2: Human Readability Is the Primary Goal

The projection exists for one purpose: **to be understood by humans**.

Every design decision should ask: "Does this make the output easier to read and understand?"

- No IDs in the projection section (IDs are for machines)
- Use names that make sense when read aloud
- Structure the data as humans think about it

### Principle 3: Graphs Are Nodes and Edges — Nothing More

In the projection, everything is either:
- A **node** (a thing with a type and a name)
- An **edge** (a relationship between two things)

Properties, metadata, and complexity belong in Schema__. If something is important enough to visualize, represent it as a node or edge.

**Example:** Instead of a `line_number` property on a node, you could have:
```
MyClass --defined_at--> line:42
```

### Principle 4: Refs Are Lookup Keys, Names Are Instance Identity

Two distinct concepts:
- **ref:** The *type* or *category* — looks up to a definition (e.g., "class", "calls")
- **name:** The *instance* identity — what this specific thing is called (e.g., "MyClass")

```json
{"ref": "class", "name": "MyClass"}
```

Read as: "A **class** named **MyClass**" or "The node type is **class**, the instance is **MyClass**"

### Principle 5: Separation of Concerns via Three Sections

A projected file has exactly three sections, each with a distinct purpose:

| Section | Purpose | Contains | For Whom |
|---------|---------|----------|----------|
| **projection** | Understanding | Nodes, edges, relationships | Humans |
| **references** | Correlation | Ref → ID mappings | Tools that need IDs |
| **sources** | Provenance | Where data came from | Debugging, auditing |

This separation means:
- You can read `projection` without ever looking at `references`
- Tools can use `references` to correlate back to Schema__
- `sources` provides an audit trail

### Principle 6: References Map Types, Not Instances

The `references` section maps **type refs** to their IDs:
- `"class"` → node type ID
- `"calls"` → predicate ID

It does **not** map instance names (`"MyClass"`) to node IDs. Why?

1. Instance names ARE the human-readable representation — that's the point
2. If you need instance IDs, use `sources.source_graph_id` to find the Schema__ and look up by name
3. Keeps references small and focused on type definitions

### Principle 7: Consistency in Naming

Fields follow a predictable pattern:

| Field | Meaning | Example |
|-------|---------|---------|
| `ref` | Type/category lookup key | `"class"`, `"calls"` |
| `name` | Instance identity | `"MyClass"` |
| `from_name` | Source node's name | `"MyClass"` |
| `to_name` | Target node's name | `"helper_func"` |

Edges use `from_name`/`to_name` (not `from_node`/`to_node`) because they reference the node's `name` field directly.

---

## 3. The Problem Space

### 3.1 The Current State (Brief 3.5)

Brief 3.5 currently uses `*_Ref` for cross-artifact references:

```python
class Schema__Semantic_Graph(Type_Safe):
    graph_id         : Graph_Id
    graph_id_source  : Schema__Id__Source = None
    ontology_ref     : Ontology_Ref                  # ← Ref, not ID
    rule_set_ref     : Rule_Set_Ref                  # ← Ref, not ID
    nodes            : Dict__Nodes__By_Id
    edges            : List__Semantic_Graph__Edges


class Schema__Semantic_Graph__Node(Type_Safe):
    node_id        : Node_Id
    node_id_source : Schema__Id__Source = None
    node_type      : Node_Type_Ref                   # ← Ref, not ID
    name           : Safe_Str__Id
    line_number    : Safe_UInt
```

**The Problem:** These `*_Ref` fields are string-based lookups, not true foreign keys:

| Issue | Description |
|-------|-------------|
| **No referential integrity** | String "call_flow" doesn't guarantee ontology exists |
| **Rename fragility** | Renaming ontology breaks all references |
| **Ambiguity** | Two ontologies with same ref? Which one? |
| **Graph unfriendly** | MGraph-DB expects ID-based node relationships |

### 3.2 The Tension

If we change to ID-based references (which we should for integrity):

```python
class Schema__Semantic_Graph(Type_Safe):
    ontology_id  : Ontology_Id               # Foreign key to ontology
    rule_set_id  : Rule_Set_Id               # Foreign key to rule set
```

This creates a fundamental tension:

```json
{
    "graph_id": "a3f2b8c1",
    "ontology_id": "7b4e9f12",
    "nodes": {
        "f1a2b3c4": {
            "node_id": "f1a2b3c4",
            "node_type_id": "9e8d7c6b",
            "name": "MyClass"
        }
    }
}
```

**Questions a human reader would ask:**
- What ontology is `7b4e9f12`? 
- What node type is `9e8d7c6b`?
- How do I debug this?
- How do I visualize this?

### 3.3 Before and After: Schema Layer

**BEFORE (Brief 3.5 current - refs everywhere):**

```python
class Schema__Semantic_Graph(Type_Safe):
    graph_id         : Graph_Id
    ontology_ref     : Ontology_Ref              # String lookup
    rule_set_ref     : Rule_Set_Ref              # String lookup
    nodes            : Dict__Nodes__By_Id
    edges            : List__Edges

class Schema__Semantic_Graph__Node(Type_Safe):
    node_id          : Node_Id
    node_type        : Node_Type_Ref             # String lookup
    name             : Safe_Str__Id
```

**AFTER (This brief - IDs for integrity):**

```python
class Schema__Semantic_Graph(Type_Safe):
    graph_id         : Graph_Id
    ontology_id      : Ontology_Id               # Foreign key (ID)
    rule_set_id      : Rule_Set_Id               # Foreign key (ID)
    nodes            : Dict__Nodes__By_Id
    edges            : List__Edges

class Schema__Semantic_Graph__Node(Type_Safe):
    node_id          : Node_Id
    node_type_id     : Node_Type_Id              # Foreign key (ID)
    name             : Safe_Str__Id
```

**The human-readable refs still exist** — they're stored in the Ontology definition (see Section 9.1). The Projector resolves IDs → Refs when generating the projection.

### 3.4 Three Conflicting Requirements

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     THREE REQUIREMENTS IN TENSION                            │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐           │
│  │  GRAPH-FRIENDLY │    │   ID-BASED      │    │ HUMAN-READABLE  │           │
│  │                 │    │                 │    │                 │           │
│  │ • MGraph-DB     │    │ • Referential   │    │ • Debuggable    │           │
│  │   compatible    │    │   integrity     │    │ • Visualizable  │           │
│  │ • Node/Edge     │    │ • Cross-session │    │ • Understandable│           │
│  │   patterns      │    │   identity      │    │ • No IDs        │           │
│  │ • Index-able    │    │ • Deterministic │    │                 │           │
│  └────────┬────────┘    └────────┬────────┘    └────────┬────────┘           │
│           │                      │                      │                    │
│           └──────────────────────┼──────────────────────┘                    │
│                                  │                                           │
│                                  ▼                                           │
│                    ┌─────────────────────────┐                               │
│                    │   HOW DO WE SATISFY     │                               │
│                    │   ALL THREE?            │                               │
│                    └─────────────────────────┘                               │
│                                                                              │
│  ANSWER: Two layers with different responsibilities                          │
│                                                                              │
│  Schema__ ───► Graph-friendly + ID-based (requirements 1 & 2)                │
│  Projected__ ► Human-readable (requirement 3)                                │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 3.5 Why "Projected" Not "View"?

We chose **Projected__** over **View__** deliberately:

| Term | Connotations | Why Not |
|------|--------------|---------|
| **View** | MVC views, database views, UI views | Overloaded, implies interactivity |
| **Export** | File format conversion | Implies serialization only |
| **Rendered** | Visual output | Implies graphics |
| **Generated** | Created from source | Good, but doesn't convey "subset/perspective" |
| **Projected** | Data projection, derived view | ✓ Implies one-way, derived, focused |

**Projected** also connects to the philosophy: *"Use databases as data projections, not data stores."* A projection is a focused, derived representation of underlying data.

---

## 4. The Solution: Schema/Projected Separation

### 4.1 Core Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     SCHEMA / PROJECTED ARCHITECTURE                          │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ┌──────────────────────────────────────────────────────────────────────┐   │
│   │                       SCHEMA__ LAYER                                 │   │
│   │                    (Master / Source of Truth)                        │   │
│   │                                                                      │   │
│   │  • All cross-references use *_Id                                     │   │
│   │  • Graph-friendly (MGraph-DB compatible)                             │   │
│   │  • Referential integrity guaranteed                                  │   │
│   │  • Full properties and metadata                                      │   │
│   │  • Stored, persisted, indexed                                        │   │
│   │                                                                      │   │
│   │  Schema__Semantic_Graph                                              │   │
│   │  Schema__Semantic_Graph__Node                                        │   │
│   │  Schema__Semantic_Graph__Edge                                        │   │
│   └──────────────────────────────────────────────────────────────────────┘   │
│                                    │                                         │
│                                    │ Projector                               │
│                                    │ (one-way generation)                    │
│                                    ▼                                         │
│   ┌──────────────────────────────────────────────────────────────────────┐   │
│   │                      PROJECTED__ LAYER                               │   │
│   │                    (Derived / Generated)                             │   │
│   │                                                                      │   │
│   │  • Human-readable (refs and names only)                              │   │
│   │  • No IDs in projection section                                      │   │
│   │  • Three sections: projection, references, sources                   │   │
│   │  • Computed on-demand, disposable                                    │   │
│   │  • NOT edited — regenerate from Schema__ instead                     │   │
│   │                                                                      │   │
│   │  Projected__Semantic_Graph                                           │   │
│   │    ├── projection  (human-readable nodes/edges)                      │   │
│   │    ├── references  (ref → ID mappings)                               │   │
│   │    └── sources     (provenance)                                      │   │
│   └──────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 Data Flow

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                              DATA FLOW                                       │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│                        ┌──────────────────┐                                  │
│                        │   JSON Config    │                                  │
│                        │   (ontology,     │                                  │
│                        │    taxonomy)     │                                  │
│                        └────────┬─────────┘                                  │
│                                 │                                            │
│                                 │ load + register                            │
│                                 ▼                                            │
│   ┌──────────────────────────────────────────────────────────────────────┐   │
│   │                        REGISTRY LAYER                                │   │
│   │                                                                      │   │
│   │  Ontology__Registry    Taxonomy__Registry    Rule_Set__Registry      │   │
│   │       │                      │                      │                │   │
│   │       │ by_id: Id → Schema   │ by_id: Id → Schema   │                │   │
│   │       │ by_ref: Ref → Id     │ by_ref: Ref → Id     │                │   │
│   └───────┼──────────────────────┼──────────────────────┼────────────────┘   │
│           │                      │                      │                    │
│           └──────────────────────┼──────────────────────┘                    │
│                                  │                                           │
│                                  ▼                                           │
│   ┌──────────────────────────────────────────────────────────────────────┐   │
│   │                Schema__Semantic_Graph                                │   │
│   │                     (ID-based)                                       │   │
│   └───────────────────────────┬──────────────────────────────────────────┘   │
│                               │                                              │
│              ┌────────────────┼────────────────┐                             │
│              │                │                │                             │
│              ▼                ▼                ▼                             │
│   ┌──────────────────┐ ┌────────────┐ ┌───────────────────┐                  │
│   │ MGraph-DB        │ │ Indexing   │ │ Projector         │                  │
│   │ (persistence)    │ │ (queries)  │ │ (generate view)   │                  │
│   └──────────────────┘ └────────────┘ └─────────┬─────────┘                  │
│                                                 │                            │
│                                                 ▼                            │
│                              ┌───────────────────────────────┐               │
│                              │ Projected__Semantic_Graph     │               │
│                              │                               │               │
│                              │ • projection (human-readable) │               │
│                              │ • references (ref → ID)       │               │
│                              │ • sources (provenance)        │               │
│                              └───────────────────────────────┘               │
│                                                 │                            │
│                                                 ▼                            │
│                              ┌───────────────────────────────┐               │
│                              │ Human Consumption             │               │
│                              │ • Visualization               │               │
│                              │ • Debugging                   │               │
│                              │ • Documentation               │               │
│                              │ • Understanding               │               │
│                              └───────────────────────────────┘               │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## 5. The Three-Section Structure

### 5.1 Overview

Every projected file has exactly three sections:

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     PROJECTED FILE STRUCTURE                                 │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────┐    │
│  │  1. PROJECTION                                                       │    │
│  │     (Human Readable — What You Look At)                              │    │
│  │                                                                      │    │
│  │  • Nodes with type (ref) and identity (name)                         │    │
│  │  • Edges with source (from_name), target (to_name), type (ref)       │    │
│  │  • NO IDs anywhere — pure human-readable content                     │    │
│  │                                                                      │    │
│  │  Read this section to understand the graph.                          │    │
│  └──────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────┐    │
│  │  2. REFERENCES                                                       │    │
│  │     (Lookup Index — How to Correlate Back)                           │    │
│  │                                                                      │    │
│  │  • Maps type refs to their IDs                                       │    │
│  │  • nodes: {"class": "9e8d7c6b", ...}                                 │    │
│  │  • edges: {"calls": "p1p2p3p4", ...}                                 │    │
│  │  • Only needed if tooling requires ID correlation                    │    │
│  │                                                                      │    │
│  │  Use this section to find IDs for type definitions.                  │    │
│  └──────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────┐    │
│  │  3. SOURCES                                                          │    │
│  │     (Provenance — Where It Came From)                                │    │
│  │                                                                      │    │
│  │  • source_graph_id: Which Schema__ graph was projected               │    │
│  │  • ontology_seed: The ontology's identity seed                       │    │
│  │  • generated_at: When this projection was created                    │    │
│  │                                                                      │    │
│  │  Use this section to trace back to source data.                      │    │
│  └──────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 5.2 Why This Separation?

**Reading:** A human only needs to look at `projection`. The nodes and edges tell the complete story in human terms.

**Tooling:** A visualization tool might read `projection` for display and `references` to add ID annotations or build indexes.

**Debugging:** When something looks wrong, `sources` tells you exactly which Schema__ graph to investigate.

**Regeneration:** Since `sources` captures provenance, you can always regenerate the projection from the original Schema__.

---

## 6. Detailed Design

### 6.1 The Projection Section

```python
class Projected__Data(Type_Safe):
    """The human-readable projection — NO IDs."""
    nodes : List[Projected__Node]
    edges : List[Projected__Edge]


class Projected__Node(Type_Safe):
    """A node in the projection.
    
    ref:  The type/category of this node (looks up in references.nodes)
    name: The identity of this specific instance
    
    Example: {"ref": "class", "name": "MyClass"}
    Read as: "A class named MyClass"
    """
    ref  : Semantic_Ref
    name : Safe_Str__Id


class Projected__Edge(Type_Safe):
    """An edge in the projection.
    
    from_name: The source node's name (matches a node.name)
    to_name:   The target node's name (matches a node.name)
    ref:       The type of relationship (looks up in references.edges)
    
    Example: {"from_name": "method_a", "to_name": "helper_func", "ref": "calls"}
    Read as: "method_a calls helper_func"
    """
    from_name : Safe_Str__Id
    to_name   : Safe_Str__Id
    ref       : Semantic_Ref
```

### 6.2 The References Section

```python
class Projected__References(Type_Safe):
    """Lookup index from refs to IDs.
    
    Only maps TYPE refs (not instance names).
    Use this when tooling needs to correlate back to Schema__.
    """
    nodes : Dict[Semantic_Ref, Node_Type_Id]      # "class" → ID
    edges : Dict[Semantic_Ref, Predicate_Id]      # "calls" → ID


# Typed dictionary implementations
class Dict__Node_Type_Ids__By_Ref(Type_Safe__Dict):
    expected_key_type   = Semantic_Ref
    expected_value_type = Node_Type_Id

class Dict__Predicate_Ids__By_Ref(Type_Safe__Dict):
    expected_key_type   = Semantic_Ref
    expected_value_type = Predicate_Id
```

### 6.3 The Sources Section

```python
class Projected__Sources(Type_Safe):
    """Provenance information — where this projection came from.
    
    Use this to trace back to the original Schema__ data.
    """
    source_graph_id : Graph_Id                           # The Schema__ graph that was projected
    ontology_seed   : Safe_Str__Id__Seed = None          # Ontology identity (if deterministic)
    generated_at    : Timestamp_Now                       # When projection was created
```

### 6.4 The Complete Projected Schema

```python
class Projected__Semantic_Graph(Type_Safe):
    """A human-readable projection of a Schema__Semantic_Graph.
    
    Three sections:
    - projection: The human-readable content (nodes and edges)
    - references: Lookup index from refs to IDs
    - sources:    Provenance information
    
    This is GENERATED, not edited. To modify data, work with Schema__ directly.
    """
    projection : Projected__Data
    references : Projected__References
    sources    : Projected__Sources
```

---

## 7. Example Output

### 7.1 Complete JSON Example

```json
{
    "projection": {
        "nodes": [
            {"ref": "class",    "name": "MyClass"},
            {"ref": "class",    "name": "OtherClass"},
            {"ref": "function", "name": "helper_func"},
            {"ref": "method",   "name": "my_method"}
        ],
        "edges": [
            {"from_name": "MyClass",    "to_name": "helper_func", "ref": "calls"},
            {"from_name": "MyClass",    "to_name": "OtherClass",  "ref": "inherits"},
            {"from_name": "MyClass",    "to_name": "my_method",   "ref": "contains"},
            {"from_name": "my_method",  "to_name": "helper_func", "ref": "calls"}
        ]
    },
    "references": {
        "nodes": {
            "class":    "9e8d7c6b",
            "function": "5a4b3c2d",
            "method":   "1a2b3c4d"
        },
        "edges": {
            "calls":    "p1p2p3p4",
            "inherits": "p5p6p7p8",
            "contains": "p9p0p1p2"
        }
    },
    "sources": {
        "source_graph_id": "a3f2b8c1",
        "ontology_seed": "http://osbot.dev/ontologies/call_flow/1.0.0",
        "generated_at": "2026-01-04T12:00:00Z"
    }
}
```

### 7.2 How to Read It

Looking only at the `projection` section:

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                                                                              │
│     [class]              [class]                                             │
│     MyClass ─────────────► OtherClass                                        │
│        │     inherits                                                        │
│        │                                                                     │
│        │ contains                                                            │
│        │                                                                     │
│        ▼                                                                     │
│     [method]                                                                 │
│     my_method                                                                │
│        │                                                                     │
│        │ calls                                                               │
│        │                         [function]                                  │
│        └────────────────────────► helper_func ◄──────────────────────┐       │
│                                                                      │       │
│                                                       calls          │       │
│     MyClass ─────────────────────────────────────────────────────────┘       │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

**No IDs needed to understand this graph.** That's the whole point.

---

## 8. The Projector

### 8.1 Projector Implementation

```python
class Semantic_Graph__Projector(Type_Safe):
    """Transforms Schema__ (ID-based) to Projected__ (Ref-based).
    
    This is a one-way transformation. The projection is generated
    for human consumption and is not intended to be edited.
    """
    
    ontology_registry : Ontology__Registry
    
    def project(self, graph: Schema__Semantic_Graph) -> Projected__Semantic_Graph:
        """Generate a human-readable projection of the graph."""
        
        # Get ontology for ref lookups
        ontology = self.ontology_registry.by_id.get(graph.ontology_id)
        
        # Build reverse lookups: ID → Ref
        node_type_id_to_ref = {}
        predicate_id_to_ref = {}
        
        if ontology:
            node_type_id_to_ref = {
                nt.node_type_id: nt.node_type_ref 
                for nt in ontology.node_types.values()
            }
            predicate_id_to_ref = {
                p.predicate_id: p.predicate_ref 
                for p in ontology.predicates.values()
            }
        
        # Build node name lookup for edges
        node_id_to_name = {
            node.node_id: node.name 
            for node in graph.nodes.values()
        }
        
        # Project nodes
        projected_nodes = [
            Projected__Node(
                ref  = node_type_id_to_ref.get(node.node_type_id, Semantic_Ref('')),
                name = node.name,
            )
            for node in graph.nodes.values()
        ]
        
        # Project edges
        projected_edges = [
            Projected__Edge(
                from_name = node_id_to_name.get(edge.from_node_id, Safe_Str__Id('')),
                to_name   = node_id_to_name.get(edge.to_node_id, Safe_Str__Id('')),
                ref       = predicate_id_to_ref.get(edge.predicate_id, Semantic_Ref('')),
            )
            for edge in graph.edges
        ]
        
        # Build references (ref → ID, for type lookups only)
        references = Projected__References(
            nodes = {ref: id for id, ref in node_type_id_to_ref.items()},
            edges = {ref: id for id, ref in predicate_id_to_ref.items()},
        )
        
        # Build sources
        sources = Projected__Sources(
            source_graph_id = graph.graph_id,
            ontology_seed   = ontology.ontology_id_source.seed if ontology and ontology.ontology_id_source else None,
            generated_at    = Timestamp_Now(),
        )
        
        return Projected__Semantic_Graph(
            projection = Projected__Data(
                nodes = projected_nodes,
                edges = projected_edges,
            ),
            references = references,
            sources    = sources,
        )
```

### 8.2 Usage

```python
# Create projector with registry access
projector = Semantic_Graph__Projector(
    ontology_registry = ontology_registry,
)

# Generate projection from Schema__
projected = projector.project(schema_graph)

# Export for humans
print(projected.json())

# Or just the projection section
print(projected.projection.json())
```

---

## 9. Schema Layer Updates (From Brief 3.5)

### 9.1 Where Human-Readable Refs Are Stored

A key clarification: the human-readable refs (`Node_Type_Ref`, `Predicate_Ref`, etc.) are stored **once** in the definition layer, not in every instance.

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                   WHERE REFS ARE STORED (NORMALIZED)                         │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  DEFINITION LAYER (Ontology) - Refs defined ONCE                             │
│  ───────────────────────────────────────────────                             │
│                                                                              │
│  Schema__Ontology                                                            │
│  ├── ontology_id  : Ontology_Id           # "7b4e9f12"                       │
│  ├── ontology_ref : Ontology_Ref          # "call_flow" ← STORED HERE        │
│  │                                                                           │
│  ├── node_types: Dict[Node_Type_Id, Schema__Ontology__Node_Type]             │
│  │   │                                                                       │
│  │   └── Schema__Ontology__Node_Type                                         │
│  │       ├── node_type_id  : Node_Type_Id     # "9e8d7c6b"                   │
│  │       └── node_type_ref : Node_Type_Ref    # "class" ← STORED ONCE        │
│  │                                                                           │
│  ├── predicates: Dict[Predicate_Id, Schema__Ontology__Predicate]             │
│  │   │                                                                       │
│  │   └── Schema__Ontology__Predicate                                         │
│  │       ├── predicate_id  : Predicate_Id     # "p1p2p3p4"                   │
│  │       ├── predicate_ref : Predicate_Ref    # "calls" ← STORED ONCE        │
│  │       └── inverse_id    : Predicate_Id     # points to "called_by"        │
│  │                                                                           │
│  └── edge_rules: List[Schema__Ontology__Edge_Rule]                           │
│      │                                                                       │
│      └── Schema__Ontology__Edge_Rule                                         │
│          ├── source_type_id : Node_Type_Id    # method                       │
│          ├── predicate_id   : Predicate_Id    # calls (by ID, not ref)       │
│          └── target_type_id : Node_Type_Id    # function                     │
│                                                                              │
│                                                                              │
│  INSTANCE LAYER (Graph) - IDs only, no refs                                  │
│  ──────────────────────────────────────────                                  │
│                                                                              │
│  Schema__Semantic_Graph__Node                                                │
│  ├── node_id      : Node_Id               # "f1a2b3c4"                       │
│  ├── node_type_id : Node_Type_Id          # "9e8d7c6b" ← Just the ID         │
│  └── name         : Safe_Str__Id          # "MyClass"                        │
│      (no node_type_ref - look it up in Ontology.node_types)                  │
│                                                                              │
│  Schema__Semantic_Graph__Edge                                                │
│  ├── edge_id      : Edge_Id               # "e1e2e3e4"                       │
│  ├── from_node_id : Node_Id               # "f1a2b3c4"                       │
│  ├── to_node_id   : Node_Id               # "a7b8c9d0"                       │
│  └── predicate_id : Predicate_Id          # "p1p2p3p4" ← Just the ID         │
│      (no predicate_ref - look it up in Ontology.predicates)                  │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

**Why this design:**
- Refs are defined once (in Ontology), not duplicated in every node/edge
- Predicates are first-class entities with their own IDs
- Changing a ref means updating one place (the definition)
- Instances are lightweight (just IDs)
- The Projector resolves IDs → Refs by looking up the Ontology

### 9.2 All Cross-References Use IDs

Building on Brief 3.5, the Schema__ layer uses `*_Id` for all cross-artifact references.

#### Definition Layer - Normalized Structure

Predicates are **first-class entities** defined once, referenced by ID everywhere:

```python
class Schema__Ontology(Type_Safe):
    ontology_id       : Ontology_Id
    ontology_id_source: Ontology_Id__Source = None
    ontology_ref      : Ontology_Ref                  # Human label (not a link)
    description       : Safe_Str__Text
    taxonomy_id       : Taxonomy_Id                   # Foreign key to taxonomy
    node_types        : Dict__Node_Types__By_Id       # Node type definitions
    predicates        : Dict__Predicates__By_Id       # Predicate definitions (ONCE each)
    edge_rules        : List__Edge_Rules              # What edges are allowed


class Schema__Ontology__Node_Type(Type_Safe):
    node_type_id        : Node_Type_Id
    node_type_id_source : Node_Type_Id__Source = None   
    node_type_ref       : Node_Type_Ref                 # "class", "method" - defined ONCE
    description         : Safe_Str__Text


class Schema__Ontology__Predicate(Type_Safe):
    predicate_id      : Predicate_Id
    predicate_id_source : Predicate_Id__Source = None  
    predicate_ref     : Predicate_Ref                   # "calls" - defined ONCE
    inverse_id        : Predicate_Id           = None   # Points to inverse predicate (e.g., "called_by")
    description       : Safe_Str__Text         = None


class Schema__Ontology__Edge_Rule(Type_Safe):         # Defines what edges are allowed: source --predicate--> target
    source_type_id    : Node_Type_Id                  # e.g., method
    predicate_id      : Predicate_Id                  # e.g., calls
    target_type_id    : Node_Type_Id                  # e.g., function
```

#### Why Normalized Predicates?

**Before (denormalized):** "calls" repeated in every node type that uses it:

```python
# OLD: "calls" defined multiple times
method_node_type = Schema__Ontology__Node_Type(
    relationships = {'calls': Schema__Ontology__Relationship(inverse='called_by', ...)}
)
function_node_type = Schema__Ontology__Node_Type(
    relationships = {'calls': Schema__Ontology__Relationship(inverse='called_by', ...)}  # Duplicate!
)
```

**After (normalized):** "calls" defined once, referenced by ID:

```python
# NEW: "calls" defined ONCE
predicates = {
    calls_id: Schema__Ontology__Predicate(
        predicate_id  = calls_id,
        predicate_ref = Predicate_Ref('calls'),       # Defined ONCE
        inverse_id    = called_by_id,
    ),
    called_by_id: Schema__Ontology__Predicate(
        predicate_id  = called_by_id,
        predicate_ref = Predicate_Ref('called_by'),   # Defined ONCE
        inverse_id    = calls_id,
    ),
}

# Edge rules reference by ID
edge_rules = [
    Schema__Ontology__Edge_Rule(source_type_id=method_id,   predicate_id=calls_id, target_type_id=method_id),
    Schema__Ontology__Edge_Rule(source_type_id=method_id,   predicate_id=calls_id, target_type_id=function_id),
    Schema__Ontology__Edge_Rule(source_type_id=function_id, predicate_id=calls_id, target_type_id=function_id),
]
```

| Aspect | Denormalized (Before) | Normalized (After) |
|--------|----------------------|-------------------|
| **Predicate definition** | Repeated per node type | Once |
| **Rename predicate** | Find all occurrences | Change one place |
| **Inverse consistency** | Could mismatch | Single source of truth |
| **Projection references** | Can't map to ID | `references.edges["calls"] → predicate_id` ✓ |

#### Instance Layer - IDs Only

```python
class Schema__Semantic_Graph(Type_Safe):
    graph_id          : Graph_Id
    graph_id_source   : Graph_Id__Source = None
    ontology_id       : Ontology_Id                   # Foreign key (ID, not Ref)
    rule_set_id       : Rule_Set_Id                   # Foreign key (ID, not Ref)
    nodes             : Dict__Nodes__By_Id
    edges             : List__Edges


class Schema__Semantic_Graph__Node(Type_Safe):
    node_id           : Node_Id
    node_id_source    : Node_Id__Source = None
    node_type_id      : Node_Type_Id                  # Foreign key (ID, not Ref)
    name              : Safe_Str__Id
    # NO node_type_ref - look it up in Ontology.node_types[node_type_id].node_type_ref


class Schema__Semantic_Graph__Edge(Type_Safe):
    edge_id           : Edge_Id
    edge_id_source    : Edge_Id__Source = None
    from_node_id      : Node_Id
    to_node_id        : Node_Id
    predicate_id      : Predicate_Id                  # Foreign key (ID, not Ref)
    # NO predicate_ref - look it up in Ontology.predicates[predicate_id].predicate_ref
```

#### Concrete Example: Python Code Ontology

Showing how the test ontology transforms from denormalized to normalized:

**OLD (denormalized - relationships embedded in node types):**
```python
method_node_type = Schema__Ontology__Node_Type(
    description   = 'Python method',
    relationships = {
        'calls': Schema__Ontology__Relationship(
            inverse = 'called_by',
            targets = ['method', 'function']
        )
    }
)
```

**NEW (normalized - predicates and edge_rules separate):**
```python
# Node types - just identity and description
node_types = {
    method_id:   Schema__Ontology__Node_Type(node_type_id=method_id,   node_type_ref=Node_Type_Ref('method')),
    function_id: Schema__Ontology__Node_Type(node_type_id=function_id, node_type_ref=Node_Type_Ref('function')),
    class_id:    Schema__Ontology__Node_Type(node_type_id=class_id,    node_type_ref=Node_Type_Ref('class')),
    module_id:   Schema__Ontology__Node_Type(node_type_id=module_id,   node_type_ref=Node_Type_Ref('module')),
}

# Predicates - defined ONCE with inverse relationships
predicates = {
    calls_id:     Schema__Ontology__Predicate(predicate_id=calls_id,     predicate_ref=Predicate_Ref('calls'),     inverse_id=called_by_id),
    called_by_id: Schema__Ontology__Predicate(predicate_id=called_by_id, predicate_ref=Predicate_Ref('called_by'), inverse_id=calls_id),
    defines_id:   Schema__Ontology__Predicate(predicate_id=defines_id,   predicate_ref=Predicate_Ref('defines'),   inverse_id=defined_in_id),
    defined_in_id:Schema__Ontology__Predicate(predicate_id=defined_in_id,predicate_ref=Predicate_Ref('defined_in'),inverse_id=defines_id),
    # ... etc
}

# Edge rules - what edges are allowed
edge_rules = [
    Schema__Ontology__Edge_Rule(source_type_id=method_id,   predicate_id=calls_id,   target_type_id=method_id),
    Schema__Ontology__Edge_Rule(source_type_id=method_id,   predicate_id=calls_id,   target_type_id=function_id),
    Schema__Ontology__Edge_Rule(source_type_id=module_id,   predicate_id=defines_id, target_type_id=class_id),
    Schema__Ontology__Edge_Rule(source_type_id=module_id,   predicate_id=defines_id, target_type_id=function_id),
    # ... etc
]
```

### 9.3 ID Reference Map

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                         ID REFERENCE MAP                                     │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  DEFINITION LAYER                                                            │
│  ────────────────                                                            │
│                                                                              │
│  Schema__Ontology                                                            │
│  ├── ontology_id ──────────► (self)                                          │
│  └── taxonomy_id ──────────► Taxonomy__Registry.by_id                        │
│                                                                              │
│  Schema__Ontology__Node_Type                                                 │
│  ├── node_type_id ─────────► (self)                                          │
│                                                                              │
│  Schema__Ontology__Predicate                                                 │
│  ├── predicate_id ─────────► (self)                                          │
│  └── inverse_id ───────────► Ontology.predicates[id] (the inverse predicate) │
│                                                                              │
│  Schema__Ontology__Edge_Rule                                                 │
│  ├── source_type_id ───────► Ontology.node_types[id]                         │
│  ├── predicate_id ─────────► Ontology.predicates[id]                         │
│  └── target_type_id ───────► Ontology.node_types[id]                         │
│                                                                              │
│                                                                              │
│  INSTANCE LAYER                                                              │
│  ──────────────                                                              │
│                                                                              │
│  Schema__Semantic_Graph                                                      │
│  ├── graph_id ─────────────► (self)                                          │
│  ├── ontology_id ──────────► Ontology__Registry.by_id                        │
│  └── rule_set_id ──────────► Rule_Set__Registry.by_id                        │
│                                                                              │
│  Schema__Semantic_Graph__Node                                                │
│  ├── node_id ──────────────► (self)                                          │
│  └── node_type_id ─────────► Ontology.node_types[id]                         │
│                                                                              │
│  Schema__Semantic_Graph__Edge                                                │
│  ├── edge_id ──────────────► (self)                                          │
│  ├── from_node_id ─────────► Graph.nodes[id]                                 │
│  ├── to_node_id ───────────► Graph.nodes[id]                                 │
│  └── predicate_id ─────────► Ontology.predicates[id]                         │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

## 10. How Artifacts Fit Together

### 10.1 Complete Architecture

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                     COMPLETE DATA ARCHITECTURE                               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│                         DEFINITION LAYER                                     │
│  ┌──────────────────────────────────────────────────────────────────────┐    │
│  │                                                                      │    │
│  │   JSON Configs ──► Registries ──► Schema__ definitions               │    │
│  │                                                                      │    │
│  │   • Ontology                                                         │    │
│  │     ├── node_types  (Node_Type_Id → Schema__Ontology__Node_Type)     │    │
│  │     ├── predicates  (Predicate_Id → Schema__Ontology__Predicate)     │    │
│  │     └── edge_rules  (what edges are allowed)                         │    │
│  │   • Taxonomy (categories)                                            │    │
│  │   • Rule Sets (validation rules)                                     │    │
│  │                                                                      │    │
│  └──────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                                    │ referenced by ID                        │
│                                    ▼                                         │
│                          INSTANCE LAYER                                      │
│  ┌──────────────────────────────────────────────────────────────────────┐    │
│  │                                                                      │    │
│  │   Schema__Semantic_Graph (ID-based, stored, indexed)                 │    │
│  │   ├── nodes: Node_Id → Schema__Node                                  │    │
│  │   └── edges: List[Schema__Edge]                                      │    │
│  │                                                                      │    │
│  └──────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                                    │ projected (one-way)                     │
│                                    ▼                                         │
│                        PROJECTION LAYER                                      │
│  ┌──────────────────────────────────────────────────────────────────────┐    │
│  │                                                                      │    │
│  │   Projected__Semantic_Graph (Ref-based, generated, disposable)       │    │
│  │   ├── projection: Human-readable nodes/edges                         │    │
│  │   ├── references: Ref → ID lookup                                    │    │
│  │   └── sources: Provenance                                            │    │
│  │                                                                      │    │
│  └──────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                                    ▼                                         │
│                         CONSUMPTION LAYER                                    │
│  ┌──────────────────────────────────────────────────────────────────────┐    │
│  │                                                                      │    │
│  │   • Visualization tools                                              │    │
│  │   • Documentation generators                                         │    │
│  │   • Debugging / inspection                                           │    │
│  │   • Human understanding                                              │    │
│  │                                                                      │    │
│  └──────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 10.2 What Goes Where

| Artifact | Layer | Contains | Stored? |
|----------|-------|----------|---------|
| JSON configs | Definition | Ontology, taxonomy definitions | Yes (files) |
| Registries | Definition | ID ↔ Ref mappings | Runtime |
| Schema__Semantic_Graph | Instance | ID-based graph data | Yes (MGraph-DB) |
| Projected__Semantic_Graph | Projection | Ref-based human view | No (regenerate) |

---

## 11. File Structure

### 11.1 Updated Ontology Files (Normalized)

```
osbot_utils/helpers/semantic_graphs/schemas/
├── identifier/
│   ├── Node_Type_Id.py                             # NEW: ID for node types
│   ├── Predicate_Id.py                             # NEW: ID for predicates
│   └── ...
├── ontology/
│   ├── Schema__Ontology.py                         # UPDATED: add predicates, edge_rules
│   ├── Schema__Ontology__Node_Type.py              # UPDATED: add node_type_id, node_type_ref
│   ├── Schema__Ontology__Predicate.py              # NEW: predicate definition
│   ├── Schema__Ontology__Edge_Rule.py              # NEW: edge constraint rule
│   └── Schema__Ontology__Relationship.py           # DEPRECATED: remove after migration
├── collection/
│   ├── Dict__Node_Types__By_Id.py                  # NEW: Node_Type_Id → Schema__Ontology__Node_Type
│   ├── Dict__Predicates__By_Id.py                  # NEW: Predicate_Id → Schema__Ontology__Predicate
│   └── List__Edge_Rules.py                         # NEW: List of edge rules
```

### 11.2 New Projected Files

```
osbot_utils/helpers/semantic_graphs/
├── schemas/                                        # Schema__ (master data)
│   ├── graph/
│   │   ├── Schema__Semantic_Graph.py
│   │   ├── Schema__Semantic_Graph__Node.py
│   │   └── Schema__Semantic_Graph__Edge.py
│   └── ...
├── projected/                                      # NEW DIRECTORY
│   ├── __init__.py
│   ├── Projected__Semantic_Graph.py               # Container with 3 sections
│   ├── Projected__Data.py                         # The projection section
│   ├── Projected__Node.py
│   ├── Projected__Edge.py
│   ├── Projected__References.py                   # The references section
│   └── Projected__Sources.py                      # The sources section
└── projectors/                                     # NEW DIRECTORY
    ├── __init__.py
    └── Semantic_Graph__Projector.py
```

---

## 12. Implementation Checklist

### Phase 1: Ontology Normalization (Definition Layer)

- [ ] Create `Predicate_Id` type in identifiers
- [ ] Create `Schema__Ontology__Predicate` with predicate_id, predicate_ref, inverse_id
- [ ] Create `Schema__Ontology__Edge_Rule` with source_type_id, predicate_id, target_type_id
- [ ] Update `Schema__Ontology` to add `predicates` and `edge_rules` collections
- [ ] Update `Schema__Ontology__Node_Type` to remove `relationships` dict
- [ ] Add `node_type_id` and `node_type_ref` to `Schema__Ontology__Node_Type`
- [ ] Create `Dict__Predicates__By_Id` collection type
- [ ] Create `List__Edge_Rules` collection type
- [ ] Update `Ontology__Utils` for new structure (valid_edge, get_inverse_verb, etc.)
- [ ] Add migration helper to convert old ontology format to new

### Phase 2: Schema Layer Updates (Instance Layer)

- [ ] Change `Schema__Semantic_Graph.ontology_ref` → `ontology_id`
- [ ] Change `Schema__Semantic_Graph.rule_set_ref` → `rule_set_id`
- [ ] Change `Schema__Semantic_Graph__Node.node_type` → `node_type_id`
- [ ] Add `predicate_id` to `Schema__Semantic_Graph__Edge`
- [ ] Update registries with ID-based lookups (by_id, by_ref)
- [ ] Update `Schema__Semantic_Graph__Builder` for ID-based creation

### Phase 3: Create Projected Layer

- [ ] Create `projected/` directory
- [ ] Implement `Projected__Node` (ref, name)
- [ ] Implement `Projected__Edge` (from_name, to_name, ref)
- [ ] Implement `Projected__Data` (nodes, edges)
- [ ] Implement `Projected__References` (nodes dict, edges dict)
- [ ] Implement `Projected__Sources` (source_graph_id, ontology_seed, generated_at)
- [ ] Implement `Projected__Semantic_Graph` (projection, references, sources)
- [ ] Add tests for all Projected__ types

### Phase 4: Create Projector

- [ ] Create `projectors/` directory
- [ ] Implement `Semantic_Graph__Projector`
- [ ] Add tests for projection generation
- [ ] Verify projection output matches expected format

### Phase 5: Integration & Migration

- [ ] Add `.project()` convenience method to builders
- [ ] Test full flow: JSON → Registry → Schema__ → Projected__
- [ ] Update existing ontology JSON files to new format
- [ ] Update all tests for new structure
- [ ] Document usage patterns

---

## 13. Success Criteria

### 13.1 Projection Is Human-Readable

```python
def test__projection_no_ids(self):
    """Projection section contains NO IDs."""
    projected = projector.project(schema_graph)
    
    json_str = projected.projection.json()
    
    # No ID patterns in projection
    assert 'node_id' not in json_str
    assert 'edge_id' not in json_str
    assert 'node_type_id' not in json_str
    assert 'predicate_id' not in json_str
    
    # Has refs and names
    assert 'ref' in json_str
    assert 'name' in json_str
    assert 'from_name' in json_str
    assert 'to_name' in json_str
```

### 13.2 References Enable Correlation

```python
def test__references_map_types(self):
    """References section maps type refs to IDs."""
    projected = projector.project(schema_graph)
    
    # Can look up node type ID from ref
    class_id = projected.references.nodes.get(Semantic_Ref('class'))
    assert class_id is not None
    
    # Can look up predicate ID from ref
    calls_id = projected.references.edges.get(Semantic_Ref('calls'))
    assert calls_id is not None
```

### 13.3 Sources Enable Tracing

```python
def test__sources_provide_provenance(self):
    """Sources section enables tracing back to Schema__."""
    projected = projector.project(schema_graph)
    
    # Can find original graph
    assert projected.sources.source_graph_id == schema_graph.graph_id
    
    # Has timestamp
    assert projected.sources.generated_at is not None
```

### 13.4 Consistent Field Naming

```python
def test__consistent_naming(self):
    """Fields follow consistent naming conventions."""
    projected = projector.project(schema_graph)
    
    for node in projected.projection.nodes:
        assert hasattr(node, 'ref')       # Type lookup key
        assert hasattr(node, 'name')      # Instance identity
    
    for edge in projected.projection.edges:
        assert hasattr(edge, 'from_name') # Source node's name
        assert hasattr(edge, 'to_name')   # Target node's name
        assert hasattr(edge, 'ref')       # Relationship type lookup key
```

---

## 14. Summary

### 14.1 The Pattern

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                                                                              │
│   Schema__ (Master)              ────────►       Projected__ (Generated)     │
│                                  Projector                                   │
│   • All refs by *_Id                             • All refs by Semantic_Ref  │
│   • Graph-friendly                               • Human-readable            │
│   • Stored/persisted                             • Three sections:           │
│   • Source of truth                                - projection (content)    │
│   • Full properties                                - references (lookups)    │
│                                                    - sources (provenance)    │
│                                                  • Generated, not edited     │
│                                                                              │
│                          NO ROUND-TRIP                                       │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 14.2 Key Decisions

| Decision | Rationale |
|----------|-----------|
| "Projected__" not "View__" | Implies one-way generation, not interactive |
| Three sections | Separates concerns: content, correlation, provenance |
| `ref` for type lookups | Consistent field name across nodes and edges |
| `name`/`from_name`/`to_name` | Clear instance identity |
| No IDs in projection | Human readability is the primary goal |
| References map types only | Instance names ARE the human representation |
| No round-trip | Projection is disposable, regenerate from Schema__ |

### 14.3 Benefits Achieved

| Requirement | How Addressed |
|-------------|---------------|
| **Graph-friendly** | Schema__ uses IDs, MGraph-DB compatible |
| **ID-based integrity** | All cross-refs are foreign keys in Schema__ |
| **Human-readable** | Projected__ has no IDs, just refs and names |
| **Debuggable** | Projection JSON is immediately understandable |
| **Traceable** | References and sources enable correlation |
| **Single source of truth** | Schema__ is master, Projected__ is derived |
| **Simple model** | Nodes have ref+name, edges have from_name+to_name+ref |

---

*End of Implementation Brief*