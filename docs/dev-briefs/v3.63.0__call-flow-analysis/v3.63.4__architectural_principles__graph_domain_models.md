# Architectural Principles: Graph Domain Models & Data Projections

- **Version**: v3.64.2
- **Date**: January 2026
- **Purpose**: Architectural guidance for graph-based systems using Semantic Graphs framework
- **Related**: v3_64_2__llm_brief__type_safe_guidance_updates.md

---

## Overview

These principles provide broader architectural guidance for building graph-based systems. They emerged from the Semantic Graphs framework implementation and apply to any system that converts data to graph databases.

**Core Principles**:

| Principle | Key Insight |
|-----------|-------------|
| **Domain Models First** | Graph structure exists in typed domain model before any database |
| **DBs as Projections** | Databases are query-optimized views, not source of truth |
| **Early ID Allocation** | IDs assigned at source/discovery, not at persistence |

---

## 1. Graph Domain Models as the First Step in Data-to-Graph Conversion

### The Problem: Direct Database Coupling

A common anti-pattern is converting source data directly to graph database format:

```python
# ✗ WRONG - Direct coupling to graph database
def import_code_structure(module):
    neo4j_driver = GraphDatabase.driver(uri, auth=(user, password))
    with neo4j_driver.session() as session:
        # Creating nodes directly in the database
        session.run("CREATE (m:Module {name: $name})", name=module.__name__)
        for cls in get_classes(module):
            session.run("CREATE (c:Class {name: $name})", name=cls.__name__)
            session.run("""
                MATCH (m:Module {name: $module_name})
                MATCH (c:Class {name: $class_name})
                CREATE (m)-[:DEFINES]->(c)
            """, module_name=module.__name__, class_name=cls.__name__)
```

**Problems with this approach**:
- No validation before persistence
- Database-specific code throughout your application
- Difficult to test (requires running database)
- No type safety on node/edge properties
- Hard to reason about the graph structure
- Tight coupling makes database migration painful

### The Solution: Domain Model First

Build a typed, validated domain model that represents your graph structure **before** any database interaction:

```python
# ✓ CORRECT - Domain model first
from osbot_utils.helpers.semantic_graphs.graph.schemas.Schema__Semantic_Graph import Schema__Semantic_Graph
from osbot_utils.helpers.semantic_graphs.graph.Semantic_Graph__Builder        import Semantic_Graph__Builder

def analyze_code_structure(module) -> Schema__Semantic_Graph:                        # Returns domain model, not DB result
    with Semantic_Graph__Builder() as builder:
        builder.with_ontology(code_structure_ontology)
        
        module_id = builder.add_node(node_type = Node_Type_Id('module')  ,
                                     name      = module.__name__         ,
                                     source    = inspect.getfile(module) )
        
        for cls in get_classes(module):
            class_id = builder.add_node(node_type = Node_Type_Id('class'),
                                        name      = cls.__name__         ,
                                        source    = inspect.getfile(cls) )
            builder.add_edge(module_id, 'defines', class_id)
        
        return builder.build()                                                       # Type-safe domain model

# Separate concern: persistence
def persist_to_neo4j(graph: Schema__Semantic_Graph, driver: Driver) -> None:
    # Convert domain model to database operations
    # This is the ONLY place with database-specific code
    ...
```

### Benefits of Domain Model First

| Aspect | Direct DB | Domain Model First |
|--------|-----------|-------------------|
| **Validation** | At DB insertion (late, expensive) | Before persistence (early, cheap) |
| **Testing** | Requires running DB | Pure unit tests |
| **Type Safety** | None (strings/dicts) | Full Type_Safe enforcement |
| **Portability** | Locked to one DB | Switch DBs by changing projection layer |
| **Debugging** | Query DB to see state | Inspect in-memory model |
| **Ontology Enforcement** | Manual or none | Automatic via `Semantic_Graph__Validator` |

### The Conversion Pipeline

```
┌─────────────────┐     ┌─────────────────────┐     ┌─────────────────┐
│   Source Data   │     │  Graph Domain Model │     │   Graph DB(s)   │
│                 │     │                     │     │                 │
│  - Code files   │────▶│  Schema__Semantic_  │────▶│  - Neo4j        │
│  - JSON docs    │     │       Graph         │     │  - MGraph       │
│  - API responses│     │                     │     │  - Neptune      │
│  - Events       │     │  - Type-safe nodes  │     │                 │
│                 │     │  - Validated edges  │     │  (Projections)  │
└─────────────────┘     │  - Ontology-checked │     └─────────────────┘
                        └─────────────────────┘
                                  │
                                  ▼
                        ┌─────────────────────┐
                        │   Business Logic    │
                        │                     │
                        │  - Queries          │
                        │  - Transformations  │
                        │  - Analysis         │
                        └─────────────────────┘
```

---

## 2. Databases as Data Projections, Not Data Stores

### The Insight: Source of Truth vs Query Optimization

A fundamental architectural mistake is treating graph databases (or any specialized database) as the **source of truth**. Instead, they should be **materialized projections** optimized for specific query patterns.

### The Anti-Pattern: Database as Source of Truth

```python
# ✗ WRONG - Graph DB as source of truth
class CodeAnalysisService:
    def __init__(self, neo4j_driver):
        self.driver = neo4j_driver
    
    def add_class(self, module_name: str, class_name: str):
        # Writing directly to DB - this IS the data
        self.driver.session().run("""
            MATCH (m:Module {name: $module})
            CREATE (c:Class {name: $class})
            CREATE (m)-[:DEFINES]->(c)
        """, module=module_name, class=class_name)
    
    def get_classes(self, module_name: str) -> List[str]:
        # Reading from DB - only place data exists
        result = self.driver.session().run("""
            MATCH (m:Module {name: $module})-[:DEFINES]->(c:Class)
            RETURN c.name
        """, module=module_name)
        return [r['c.name'] for r in result]
```

**Problems**:
- Data locked in one database format
- Schema migrations are painful
- Can't easily rebuild if corrupted
- Testing requires database
- No separation between "what happened" and "how we query it"

### The Pattern: Domain Model as Source, DBs as Projections

```python
# ✓ CORRECT - Domain model is source of truth, DBs are projections

# 1. Source of Truth: Domain Events / Domain Models
class Code_Analysis__Event_Store(Type_Safe):
    events : List__Code_Analysis_Events                                              # Immutable event log
    
    def record_class_discovered(self, module: str, class_name: str, metadata: dict):
        event = Event__Class_Discovered(module     = module    ,
                                        class_name = class_name,
                                        metadata   = metadata  ,
                                        timestamp  = utc_now() )
        self.events.append(event)

# 2. Build Domain Model from Events
class Code_Structure__Projector(Type_Safe):
    
    @type_safe
    def project_to_graph(self, events: List__Code_Analysis_Events) -> Schema__Semantic_Graph:
        with Semantic_Graph__Builder() as builder:
            for event in events:
                match event:
                    case Event__Class_Discovered():
                        self._handle_class_discovered(builder, event)
                    case Event__Method_Discovered():
                        self._handle_method_discovered(builder, event)
            return builder.build()

# 3. Project to Various Databases (Read-Optimized)
class Graph_DB__Projector(Type_Safe):
    
    @type_safe
    def project_to_neo4j(self, graph: Schema__Semantic_Graph, driver: Driver) -> None:
        # Projection: optimized for traversal queries
        ...
    
    @type_safe
    def project_to_mgraph(self, graph: Schema__Semantic_Graph) -> MGraph:
        # Projection: optimized for in-memory analysis
        ...
    
    @type_safe
    def project_to_elasticsearch(self, graph: Schema__Semantic_Graph, client: ES) -> None:
        # Projection: optimized for full-text search on node properties
        ...
```

### The Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         SOURCE OF TRUTH                                  │
│                                                                          │
│   ┌──────────────────┐         ┌──────────────────────┐                 │
│   │   Event Store    │────────▶│  Graph Domain Model  │                 │
│   │                  │         │                      │                 │
│   │  - Immutable     │         │  Schema__Semantic_   │                 │
│   │  - Append-only   │         │       Graph          │                 │
│   │  - Auditable     │         │                      │                 │
│   └──────────────────┘         │  - Complete state    │                 │
│                                │  - Type-safe         │                 │
│                                │  - Validated         │                 │
│                                └──────────┬───────────┘                 │
└───────────────────────────────────────────┼─────────────────────────────┘
                                            │
                    ┌───────────────────────┼───────────────────────┐
                    │                       │                       │
                    ▼                       ▼                       ▼
┌─────────────────────────┐  ┌─────────────────────────┐  ┌─────────────────────────┐
│   PROJECTION: Neo4j     │  │   PROJECTION: MGraph    │  │  PROJECTION: Search     │
│                         │  │                         │  │                         │
│  Optimized for:         │  │  Optimized for:         │  │  Optimized for:         │
│  - Path traversal       │  │  - In-memory analysis   │  │  - Full-text search     │
│  - Pattern matching     │  │  - Fast iteration       │  │  - Faceted queries      │
│  - Cypher queries       │  │  - Python integration   │  │  - Aggregations         │
│                         │  │                         │  │                         │
│  Can be:                │  │  Can be:                │  │  Can be:                │
│  - Rebuilt anytime      │  │  - Rebuilt anytime      │  │  - Rebuilt anytime      │
│  - Deleted and recreated│  │  - Deleted and recreated│  │  - Deleted and recreated│
└─────────────────────────┘  └─────────────────────────┘  └─────────────────────────┘
```

### Why Projections Matter

| Concern | DB as Source | DB as Projection |
|---------|--------------|------------------|
| **Corruption Recovery** | Restore from backup (data loss risk) | Rebuild from source (no data loss) |
| **Schema Evolution** | Complex migrations | Delete and rebuild with new schema |
| **Multiple Query Patterns** | One DB must serve all needs | Different DBs for different queries |
| **Testing** | Need DB for integration tests | Test domain model in isolation |
| **Audit Trail** | Must query DB history | Events ARE the history |
| **Debugging** | Query DB state | Replay events to reproduce |

### Key Insight

> **The graph database doesn't store your data. It stores a query-optimized VIEW of your data.**

This means:
- You can delete and rebuild the graph DB anytime
- You can have multiple graph DBs with different schemas for different query patterns
- Schema changes are trivial: rebuild the projection
- Testing doesn't require the database

---

## 3. Allocate IDs as Early as Possible

### The Problem: Late ID Allocation

When IDs are generated at persistence time, you lose traceability and create serialization issues:

```python
# ✗ WRONG - IDs generated at database insertion
def persist_node(self, node_data: dict) -> str:
    node_id = self.database.insert(node_data)                                        # DB generates ID
    return node_id                                                                   # Caller only now knows the ID

# ✗ WRONG - IDs generated during deserialization (Safe_Id problem)
class Schema__Node(Type_Safe):
    node_id : Safe_Id                                                                # Auto-generates if empty!
    name    : str

# Serialization round-trip creates NEW IDs
original = Schema__Node(name='MyClass')
json_str = original.json()
restored = Schema__Node.from_json(json_str)                                          # Different node_id!
assert original.node_id != restored.node_id                                          # FAILS - IDs don't match
```

**Problems with late ID allocation**:
- Can't reference entities before persistence
- Serialization/deserialization creates duplicate entities
- Can't deduplicate across systems
- Can't correlate entities across projections
- Testing becomes non-deterministic

### The Solution: Allocate IDs at the Source

IDs should be allocated at the earliest possible point - ideally in the source document or immediately upon entity discovery:

```python
# ✓ CORRECT - ID allocated in source document
{
    "ontology_id": "code_structure",                                                 # ID in source JSON
    "node_types": {
        "class": { ... },                                                            # type_id is the key itself
        "method": { ... }
    }
}

# ✓ CORRECT - ID allocated immediately on discovery
class Code_Structure__Analyzer(Type_Safe):
    node_registry : Dict__Nodes__By_Qualified_Name                                   # Track by stable identifier
    
    @type_safe
    def analyze_class(self, cls: type) -> Node_Id:
        qualified_name = f"{cls.__module__}.{cls.__qualname__}"                      # Stable, deterministic
        
        existing_id = self.node_registry.get(qualified_name)                         # Check if already discovered
        if existing_id:
            return existing_id                                                       # Return SAME ID
        
        node_id = Node_Id()                                                          # Allocate ID NOW
        self.node_registry[qualified_name] = node_id                                 # Register immediately
        
        # Now build the node with the pre-allocated ID
        node = Schema__Semantic_Graph__Node(node_id     = node_id                  ,
                                            node_type   = Node_Type_Id('class')    ,
                                            name        = cls.__name__             ,
                                            line_number = get_line_number(cls)     )
        self.graph.add_node(node)
        return node_id
```

### ID Allocation Strategy by Layer

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        ID ALLOCATION POINTS                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  LAYER 1: Source Documents (BEST)                                        │
│  ─────────────────────────────────                                       │
│  IDs embedded in source data itself                                      │
│                                                                          │
│    {                                                                     │
│      "ontology_id": "code_structure",        ◄── ID in document          │
│      "nodes": {                                                          │
│        "node_001": { "type": "class", ... }, ◄── ID is the key           │
│        "node_002": { "type": "method", ... }                             │
│      }                                                                   │
│    }                                                                     │
│                                                                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  LAYER 2: Domain Model Construction (GOOD)                               │
│  ─────────────────────────────────────────                               │
│  IDs allocated when entity is first discovered                           │
│                                                                          │
│    def discover_class(self, cls) -> Node_Id:                             │
│        node_id = Node_Id()                   ◄── Allocate immediately    │
│        self.registry[qualified_name] = node_id                           │
│        # ID is now stable for this entity                                │
│        return node_id                                                    │
│                                                                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  LAYER 3: Persistence (AVOID)                                            │
│  ────────────────────────────                                            │
│  Database generates ID on insert                                         │
│                                                                          │
│    # ✗ Too late - can't reference entity before this                     │
│    node_id = database.insert(node_data)                                  │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### Semantic_Id: Designed for Early Allocation

This is exactly why we created `Semantic_Id` instead of using `Safe_Id`:

```python
# Semantic_Id: Allows empty, NEVER auto-generates
class Semantic_Id(Safe_Str):
    regex           = re.compile(r'[^a-zA-Z0-9_\-.]')
    max_length      = 128
    allow_empty     = True                                                           # Can be empty initially
    trim_whitespace = True
    # NO auto-generation!

# Usage: ID comes from source document
ontology_id = Ontology_Id(data.get('ontology_id', ''))                               # From JSON
node_type_id = Node_Type_Id('class')                                                 # From key in dict

# Serialization is stable
original = Schema__Ontology(ontology_id = Ontology_Id('code_structure'))
restored = Schema__Ontology.from_json(original.json())
assert original.ontology_id == restored.ontology_id                                  # ✓ PASSES - same ID
```

### Benefits of Early ID Allocation

| Aspect | Late Allocation | Early Allocation |
|--------|-----------------|------------------|
| **Referential Integrity** | Build graph, then fix references | References valid from start |
| **Deduplication** | Check DB before insert | Check registry immediately |
| **Serialization** | IDs change on round-trip | IDs stable across serialization |
| **Cross-System Correlation** | Need mapping tables | Same ID everywhere |
| **Testing** | Non-deterministic IDs | Deterministic with `graph_ids_for_tests()` |
| **Debugging** | "Which node is this?" | ID traces back to source |

### Practical Pattern: Registry for ID Stability

```python
class Dict__Node_Ids__By_Qualified_Name(Type_Safe__Dict):
    expected_key_type   = Safe_Str__Python__Qualified_Name
    expected_value_type = Node_Id


class Code_Structure__Analyzer(Type_Safe):
    graph         : Schema__Semantic_Graph
    node_registry : Dict__Node_Ids__By_Qualified_Name                                # Ensures ID stability
    
    @type_safe
    def get_or_create_node_id(self, qualified_name: Safe_Str__Python__Qualified_Name) -> Node_Id:
        existing = self.node_registry.get(qualified_name)
        if existing:
            return existing                                                          # Same entity = same ID
        
        new_id = Node_Id()                                                           # Allocate once
        self.node_registry[qualified_name] = new_id                                  # Register immediately
        return new_id
    
    @type_safe
    def analyze_class(self, cls: type) -> Node_Id:
        qualified_name = Safe_Str__Python__Qualified_Name(f"{cls.__module__}.{cls.__qualname__}")
        node_id = self.get_or_create_node_id(qualified_name)                         # Stable ID
        
        # Check if already fully analyzed
        if self.graph.get_node(node_id):
            return node_id                                                           # Already done
        
        # Build node with pre-allocated ID
        node = Schema__Semantic_Graph__Node(node_id   = node_id                    ,
                                            node_type = Node_Type_Id('class')      ,
                                            name      = cls.__name__               )
        self.graph.add_node(node)
        return node_id
```

---

## Summary

These three principles work together to create robust, testable, and maintainable graph-based systems:

| Principle | Key Insight |
|-----------|-------------|
| **Domain Models First** | Graph structure exists in typed domain model before any database |
| **DBs as Projections** | Databases are query-optimized views, not source of truth |
| **Early ID Allocation** | IDs assigned at source/discovery, not at persistence |

**Benefits**:
- **Testability**: Domain models can be tested without databases
- **Portability**: Switch databases by changing projection layer
- **Reliability**: Rebuild any projection from source of truth
- **Traceability**: IDs correlate entities across all systems
- **Type Safety**: Full validation before any persistence

---

## Document History

| Version | Date | Changes |
|---------|------|---------|
| v3.64.2 | January 2026 | Initial document from Semantic Graphs implementation review |
