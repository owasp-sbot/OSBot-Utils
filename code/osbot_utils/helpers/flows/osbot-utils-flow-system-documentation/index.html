<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://owasp-sbot.github.io/OSBot-Utils/code/osbot_utils/helpers/flows/osbot-utils-flow-system-documentation/" />
      <link rel="shortcut icon" href="../../../../../img/favicon.ico" />
    <title>Flows - OSBot-Utils Documentation</title>
    <link rel="stylesheet" href="../../../../../css/theme.css" />
    <link rel="stylesheet" href="../../../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Flows";
        var mkdocs_page_input_path = "code/osbot_utils/helpers/flows/osbot-utils-flow-system-documentation.md";
        var mkdocs_page_url = "/OSBot-Utils/code/osbot_utils/helpers/flows/osbot-utils-flow-system-documentation/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../../../.." class="icon icon-home"> OSBot-Utils Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Code</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" >OSBot Utils</a>
    <ul class="current">
                <li class="toctree-l2 current"><a class="reference internal current" >Helpers</a>
    <ul class="current">
                <li class="toctree-l3 current"><a class="reference internal current" href="#">Flows</a>
    <ul class="current">
    <li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#common-patterns-and-examples">Common Patterns and Examples</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#implementation-guidelines">Implementation Guidelines</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#advanced-topics">Advanced Topics</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#conclusion">Conclusion</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#configuration">Configuration</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#usage-patterns">Usage Patterns</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#technical-details">Technical Details</a>
    </li>
    </ul>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Development</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../../../../dev/Python-code-formatting-guidelines/">Coding Guidelines</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Type Safety</a>
    <ul>
                <li class="toctree-l2"><a class="" href="../../../../../dev/type_safe/python-type-safety-frameworks-compared.md">Frameworks Compared</a>
                </li>
                <li class="toctree-l2"><a class="" href="../../../../../dev/type_safe/type-safe-technical-documentation.md">Technical Documentation</a>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../..">OSBot-Utils Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Code</li>
          <li class="breadcrumb-item">OSBot Utils</li>
          <li class="breadcrumb-item">Helpers</li>
      <li class="breadcrumb-item active">Flows</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="osbot-utils-flow-system-documentation">OSBot-Utils Flow System Documentation<a class="headerlink" href="#osbot-utils-flow-system-documentation" title="Permanent link">&para;</a></h1>
<h2 id="overview">Overview<a class="headerlink" href="#overview" title="Permanent link">&para;</a></h2>
<p>The Flow system is part of the OSBot-Utils package (available at https://github.com/owasp-sbot/OSBot-Utils) and was inspired by the excellent open-source project 'Prefect' (Pythonic orchestration for modern teams). Building on Prefect's foundations, the Flow system in OSBot-Utils is designed to solve the common challenge of orchestrating complex task execution in Python applications, with a strong focus on making the API as Pythonic and intuitive as possible.</p>
<p>Unlike simple sequential execution, the Flow system provides a rich context that enables monitoring, debugging, and maintenance of task execution flows. This is particularly valuable in applications that require robust error handling, detailed logging, and complex task dependencies.</p>
<h3 id="quick-start-examples">Quick Start Examples<a class="headerlink" href="#quick-start-examples" title="Permanent link">&para;</a></h3>
<p>The Flow system is designed to be incredibly intuitive and Pythonic. Here are some simple examples to get you started:</p>
<pre><code class="language-python">from osbot_utils.helpers.flows.decorators.flow import flow
from osbot_utils.helpers.flows.decorators.task import task

# Simple example: A flow with a single task
@flow()
def simple_flow(data):
    result = process_data(data)
    return result

@task()
def process_data(data):
    return data.upper()

# Use it naturally like any Python function
result = simple_flow(&quot;hello world&quot;).execute()
</code></pre>
<p>Context manager style for more complex flows:</p>
<pre><code class="language-python">with ComplexDataFlow() as flow:
    flow.input_data = my_data
    result = flow.execute()
    print(f&quot;Processing complete: {result}&quot;)
</code></pre>
<h3 id="prefect-compatibility">Prefect Compatibility<a class="headerlink" href="#prefect-compatibility" title="Permanent link">&para;</a></h3>
<p>The Flow system is 100% compatible with Prefect, allowing you to easily integrate with existing Prefect workflows. Here's a real-world example showing how the Flow system can be used in a web service context:</p>
<pre><code class="language-python">def url_pdf(self, url=&quot;https://httpbin.org/get&quot;, return_file:bool=False):
    self.install_browser()
    with Flow__Playwright__Get_Page_Pdf() as _:
        _.url = url
        run_data   = _.run()
        pdf_bytes  = run_data.get('pdf_bytes')
        pdf_base64 = run_data.get('pdf_base64')

        if return_file is True:
            pdf_stream = io.BytesIO(pdf_bytes)
            response = StreamingResponse(
                pdf_stream,
                media_type = &quot;application/pdf&quot;,
                headers    = {&quot;Content-Disposition&quot;: &quot;attachment; filename=document.pdf&quot;}
            )
        else:
            response = {'pdf_base64': pdf_base64}

        return response
</code></pre>
<p>This example demonstrates how the Flow system can be used to:
- Handle complex browser automation tasks
- Manage resource lifecycles
- Process and transform data
- Integrate with web services
- Maintain compatibility with Prefect workflows</p>
<h2 id="common-patterns-and-examples">Common Patterns and Examples<a class="headerlink" href="#common-patterns-and-examples" title="Permanent link">&para;</a></h2>
<h3 id="data-processing-pipeline">Data Processing Pipeline<a class="headerlink" href="#data-processing-pipeline" title="Permanent link">&para;</a></h3>
<p>Here's an expanded example of a data processing pipeline that demonstrates key Flow system capabilities:</p>
<pre><code class="language-python">class DataProcessingFlow(Type_Safe):
    @task()
    async def fetch_data(self, flow_data: dict):
        # Simulating data fetch
        raw_data = await self.data_source.fetch()
        flow_data['raw_data'] = raw_data

    @task()
    def validate_data(self, flow_data: dict):
        raw_data = flow_data['raw_data']
        if not self.validator.is_valid(raw_data):
            raise ValueError(&quot;Invalid data format&quot;)

    @task()
    def transform_data(self, flow_data: dict):
        raw_data = flow_data['raw_data']
        transformed = self.transformer.process(raw_data)
        flow_data['transformed_data'] = transformed

    @task()
    async def store_results(self, flow_data: dict):
        transformed = flow_data['transformed_data']
        await self.storage.save(transformed)

    @flow()
    async def process_data(self) -&gt; Flow:
        await self.fetch_data()
        self.validate_data()
        self.transform_data()
        await self.store_results()
        return 'processing complete'
</code></pre>
<p>This example shows:
- Task sequencing
- Data validation
- Error handling
- Data sharing between tasks
- Mixed sync/async operations</p>
<h3 id="web-automation-example">Web Automation Example<a class="headerlink" href="#web-automation-example" title="Permanent link">&para;</a></h3>
<p>Building on our previous Playwright examples, here's a complete web automation flow that demonstrates real-world usage:</p>
<pre><code class="language-python">class Flow__Web__Automation(Type_Safe):
    playwright_serverless : Playwright__Serverless
    url                   : str = 'https://example.com'

    @task()
    async def setup_browser(self) -&gt; Browser:
        await self.playwright_serverless.launch()
        await self.playwright_serverless.new_page()
        print('Browser setup complete')

    @task()
    async def navigate_and_wait(self) -&gt; None:
        await self.playwright_serverless.goto(self.url)
        await asyncio.sleep(1)  # Allow page to stabilize

    @task()
    async def perform_interactions(self, flow_data: dict) -&gt; None:
        page = self.playwright_serverless.page
        await page.click('#main-button')
        content = await page.content()
        flow_data['page_content'] = content

    @task()
    def process_results(self, flow_data: dict) -&gt; None:
        content = flow_data['page_content']
        results = self.analyze_content(content)
        flow_data['analysis_results'] = results

    @flow()
    async def execute_automation(self) -&gt; Flow:
        await self.setup_browser()
        await self.navigate_and_wait()
        await self.perform_interactions()
        self.process_results()
        return 'automation complete'
</code></pre>
<p>This example demonstrates:
- Browser automation
- Resource management
- Error handling
- Data capture and processing
- Flow orchestration</p>
<h2 id="implementation-guidelines">Implementation Guidelines<a class="headerlink" href="#implementation-guidelines" title="Permanent link">&para;</a></h2>
<h3 id="error-recovery-strategies">Error Recovery Strategies<a class="headerlink" href="#error-recovery-strategies" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Task-Level Recovery</strong></li>
</ol>
<pre><code class="language-python">@task(raise_on_error=False)
async def resilient_task(this_flow=None):
    try:
        await perform_operation()
    except Exception as error:
        this_flow.add_flow_artifact(
            key=&quot;error_details&quot;,
            data=str(error),
            artifact_type=&quot;error&quot;
        )
        return &quot;fallback_value&quot;
</code></pre>
<ol>
<li><strong>Flow-Level Recovery</strong></li>
</ol>
<pre><code class="language-python">@flow()
async def resilient_flow():
    try:
        await main_task()
    except Exception:
        await cleanup_task()
        await fallback_task()
</code></pre>
<h3 id="resource-management">Resource Management<a class="headerlink" href="#resource-management" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Context Manager Pattern</strong></li>
</ol>
<pre><code class="language-python">class ManagedResourceFlow(Type_Safe):
    def __enter__(self):
        # Setup resources
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        # Cleanup resources
        pass
</code></pre>
<ol>
<li><strong>Async Resource Management</strong></li>
</ol>
<pre><code class="language-python">class AsyncResourceFlow(Type_Safe):
    async def __aenter__(self):
        await self.setup_resources()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.cleanup_resources()
</code></pre>
<h3 id="performance-optimization">Performance Optimization<a class="headerlink" href="#performance-optimization" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Minimal Logging</strong></li>
</ol>
<pre><code class="language-python">flow_config = Flow_Run__Config(
    log_to_memory=False,
    log_to_console=False
)
</code></pre>
<ol>
<li><strong>Efficient Task Design</strong></li>
</ol>
<pre><code class="language-python">@task()
def optimized_task(flow_data: dict):
    # Process only required data
    subset = {k: flow_data[k] for k in required_keys}
    result = process_subset(subset)
    # Store only necessary results
    flow_data.update(result)
</code></pre>
<h3 id="testing-strategies">Testing Strategies<a class="headerlink" href="#testing-strategies" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Mock Dependencies</strong></li>
</ol>
<pre><code class="language-python">@task()
def testable_task(this_flow=None):
    # Dependencies can be mocked for testing
    service = this_flow.get_service()
    return service.operation()
</code></pre>
<ol>
<li><strong>Flow Testing</strong></li>
</ol>
<pre><code class="language-python">def test_flow():
    with MockedDependencies():
        flow = TestFlow()
        result = flow.execute()
        assert result.status == 'success'
</code></pre>
<h2 id="advanced-topics">Advanced Topics<a class="headerlink" href="#advanced-topics" title="Permanent link">&para;</a></h2>
<h3 id="custom-event-handlers">Custom Event Handlers<a class="headerlink" href="#custom-event-handlers" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">class CustomEventHandler:
    def __init__(self):
        self.events = []

    def handle_event(self, event: Flow_Run__Event):
        if event.event_type == Flow_Run__Event_Type.TASK_START:
            self.handle_task_start(event)
        elif event.event_type == Flow_Run__Event_Type.TASK_STOP:
            self.handle_task_stop(event)

    def handle_task_start(self, event):
        task_name = event.event_data.task_name
        self.events.append(f&quot;Started: {task_name}&quot;)

    def handle_task_stop(self, event):
        task_name = event.event_data.task_name
        self.events.append(f&quot;Completed: {task_name}&quot;)
</code></pre>
<h3 id="custom-flow-configurations">Custom Flow Configurations<a class="headerlink" href="#custom-flow-configurations" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">class CustomFlowConfig(Flow_Run__Config):
    def __init__(self):
        super().__init__()
        self.log_to_console = True
        self.print_logs = True

    def custom_setup(self):
        # Additional setup logic
        pass
</code></pre>
<h3 id="integration-patterns">Integration Patterns<a class="headerlink" href="#integration-patterns" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>External Service Integration</strong></li>
</ol>
<pre><code class="language-python">class ServiceIntegrationFlow(Type_Safe):
    @task()
    async def call_service(self, flow_data: dict):
        response = await self.service.call()
        flow_data['service_response'] = response

    @task()
    def process_response(self, flow_data: dict):
        response = flow_data['service_response']
        result = self.process(response)
        return result
</code></pre>
<ol>
<li><strong>Database Integration</strong></li>
</ol>
<pre><code class="language-python">class DatabaseFlow(Type_Safe):
    @task()
    async def fetch_records(self, flow_data: dict):
        async with self.db.session() as session:
            records = await session.query(Model).all()
            flow_data['records'] = records

    @task()
    def process_records(self, flow_data: dict):
        records = flow_data['records']
        return [self.transform(record) for record in records]
</code></pre>
<h2 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">&para;</a></h2>
<p>The Flow system provides a robust foundation for building complex, maintainable Python applications. By following these patterns and guidelines, developers can create reliable, testable, and efficient solutions for a wide range of use cases. Flow</p>
<p>The Flow class serves as the execution context and lifecycle manager for tasks. Think of it as a container that provides the environment and services needed by tasks. When a Flow executes, it maintains state information, manages resources, and coordinates the execution of tasks. The Flow instance becomes a central point for monitoring progress, handling errors, and collecting results.</p>
<p>Key aspects of Flow:
- <strong>Task execution monitoring</strong>: Tracks the progress and status of each task
- <strong>Event emission</strong>: Notifies listeners about important lifecycle events
- <strong>Structured logging</strong>: Maintains organized, contextual logs
- <strong>Error handling</strong>: Manages and propagates errors appropriately
- <strong>Data sharing</strong>: Provides mechanisms for tasks to share data
- <strong>Artifact management</strong>: Stores and manages execution artifacts</p>
<h3 id="task">Task<a class="headerlink" href="#task" title="Permanent link">&para;</a></h3>
<p>Tasks represent individual units of work within a Flow. They are designed to be self-contained, reusable components that can access the services provided by their parent Flow. Tasks can be created either through decoration or direct instantiation, offering flexibility in how you structure your code.</p>
<p>Key aspects of Task:
- <strong>Flow context discovery</strong>: Automatically finds its parent Flow
- <strong>Dependency injection</strong>: Receives required dependencies automatically
- <strong>Error handling</strong>: Configurable error behavior
- <strong>Event emission</strong>: Notifies about task lifecycle events
- <strong>Data access</strong>: Can access shared Flow data</p>
<h3 id="event-system">Event System<a class="headerlink" href="#event-system" title="Permanent link">&para;</a></h3>
<p>The event system provides real-time visibility into Flow and Task execution. It uses an observer pattern where listeners can subscribe to various types of events. This is particularly useful for monitoring, debugging, and integrating with external systems.</p>
<p>Event types and their purposes:</p>
<pre><code class="language-python">Flow_Run__Event_Type:
- FLOW_START   : Marks the beginning of flow execution
   Used to initialize resources and prepare for execution

- FLOW_STOP    : Marks the completion of flow execution
   Used for cleanup and final status reporting

- TASK_START   : Indicates a task is beginning
   Useful for tracking task progress and timing

- TASK_STOP    : Indicates a task has completed
   Captures task results and execution metrics

- FLOW_MESSAGE : Carries log messages
   Provides detailed execution information

- NEW_ARTIFACT : Indicates new artifact creation
   Tracks data products and intermediary results

- NEW_RESULT   : Indicates result generation
   Captures final or important intermediate results
</code></pre>
<h2 id="configuration">Configuration<a class="headerlink" href="#configuration" title="Permanent link">&para;</a></h2>
<h3 id="flow-configuration-flow_run__config">Flow Configuration (Flow_Run__Config)<a class="headerlink" href="#flow-configuration-flow_run__config" title="Permanent link">&para;</a></h3>
<p>The configuration system provides fine-grained control over Flow behavior. Each setting affects a specific aspect of Flow execution, allowing you to customize the behavior for different use cases.</p>
<pre><code class="language-python">class Flow_Run__Config:
    # Controls whether tasks are added to the flow instance
    # Useful for tracking task history and relationships
    add_task_to_self         : bool = True    

    # Determines if logs should be written to console
    # Helpful for development and debugging
    log_to_console           : bool = False   

    # Controls in-memory log retention
    # Important for post-execution analysis
    log_to_memory           : bool = True    

    # Master switch for logging functionality
    # Can disable all logging for performance
    logging_enabled         : bool = True    

    # Controls automatic log printing after execution
    # Useful for immediate feedback
    print_logs             : bool = False   

    # Determines if None returns are printed
    # Helps track task completion
    print_none_return_value: bool = False   

    # Controls end-of-execution messages
    # Provides execution boundaries
    print_finished_message : bool = False   

    # Controls error propagation
    # Critical for error handling strategy
    raise_flow_error       : bool = True    
</code></pre>
<p>Each configuration option serves a specific purpose:</p>
<p><strong>add_task_to_self (True)</strong>:
- Maintains a list of executed tasks in the Flow instance
- Enables task history tracking and debugging
- Useful for understanding task execution patterns</p>
<p><strong>log_to_console (False)</strong>:
- Controls immediate visibility of log messages
- Helpful during development and debugging
- Can be disabled in production for performance</p>
<p><strong>log_to_memory (True)</strong>:
- Keeps logs in memory for later analysis
- Enables post-execution log examination
- Important for debugging and audit trails</p>
<p><strong>logging_enabled (True)</strong>:
- Master switch for all logging features
- Can be disabled for maximum performance
- Affects both console and memory logging</p>
<p><strong>print_logs (False)</strong>:
- Automatically prints logs after Flow completion
- Provides immediate execution feedback
- Useful for interactive development</p>
<p><strong>print_none_return_value (False)</strong>:
- Controls visibility of None returns
- Helps track task completion
- Useful for debugging task chains</p>
<p><strong>print_finished_message (False)</strong>:
- Marks Flow completion in logs
- Helps track Flow boundaries
- Useful in multi-Flow scenarios</p>
<p><strong>raise_flow_error (True)</strong>:
- Controls error propagation strategy
- Affects Flow error handling behavior
- Critical for application error management</p>
<h2 id="usage-patterns">Usage Patterns<a class="headerlink" href="#usage-patterns" title="Permanent link">&para;</a></h2>
<h3 id="basic-flow-usage">Basic Flow Usage<a class="headerlink" href="#basic-flow-usage" title="Permanent link">&para;</a></h3>
<p>The basic usage pattern demonstrates how to create and execute simple Flows. This pattern is the foundation for more complex implementations.</p>
<pre><code class="language-python">from osbot_utils.helpers.flows.decorators.flow import flow
from osbot_utils.helpers.flows.decorators.task import task

# Define a flow that processes input data
@flow()
def my_flow(input_data):
    # The flow coordinates the overall process
    result = process_data(input_data)
    return result

# Define a task that performs specific work
@task()
def process_data(data):
    # Tasks handle individual units of work
    # This could be data transformation, API calls, etc.
    return processed_data

# Execute the flow and get results
flow_instance = my_flow(data).execute()
</code></pre>
<p>This pattern shows several key concepts:
1. Flow definition using decorators
2. Task integration within flows
3. Data passing between components
4. Flow execution and result handling</p>
<h3 id="task-dependencies-and-data-sharing">Task Dependencies and Data Sharing<a class="headerlink" href="#task-dependencies-and-data-sharing" title="Permanent link">&para;</a></h3>
<p>The dependency injection system automates the provision of common dependencies to tasks. This reduces boilerplate code and makes tasks more modular.</p>
<pre><code class="language-python">@task()
def task_with_deps(this_task=None, this_flow=None, task_data=None, flow_data=None):
    # this_task: Access to task instance for internal operations
    # this_flow: Access to parent flow for flow-level operations
    # task_data: Task-specific storage that doesn't persist
    # flow_data: Flow-wide storage shared between tasks

    # Task-specific data example
    task_data['local'] = 'only visible to this task'

    # Flow-wide data example
    flow_data['shared'] = 'visible to all tasks'
</code></pre>
<p>Key aspects of dependency injection:
1. Automatic dependency resolution
2. Scoped data storage
3. Access to flow and task contexts
4. Clean separation of concerns</p>
<h3 id="async-support">Async Support<a class="headerlink" href="#async-support" title="Permanent link">&para;</a></h3>
<p>The Flow system fully supports asynchronous execution, allowing efficient handling of I/O-bound operations. This is particularly valuable for web automation and network operations.</p>
<pre><code class="language-python">@flow()
async def async_flow():
    result = await async_task()
    return result

@task()
async def async_task():
    await asyncio.sleep(1)
    return &quot;completed&quot;
</code></pre>
<p>A real-world example from web automation shows how async flows handle complex operations:</p>
<pre><code class="language-python">class WebAutomationFlow(Type_Safe):
    @task()
    async def launch_browser(self) -&gt; Browser:
        await self.browser_instance.launch()
        print('launched browser')

    @task()
    async def navigate(self) -&gt; None:
        print(f&quot;opening url: {self.target_url}&quot;)
        await self.browser_instance.goto(self.target_url)
        await asyncio.sleep(1)  # Ensure page load

    @flow()
    async def execute_automation(self) -&gt; Flow:
        await self.launch_browser()
        await self.navigate()
        return 'completed'
</code></pre>
<p>Async support features:
1. Compatible with asyncio
2. Maintains Flow context in async operations
3. Supports mixed sync/async tasks
4. Preserves error handling and logging
5. Handles browser automation gracefully
6. Supports wait operations and timing controls</p>
<h3 id="real-world-implementation-patterns">Real-World Implementation Patterns<a class="headerlink" href="#real-world-implementation-patterns" title="Permanent link">&para;</a></h3>
<h4 id="web-automation-pattern">Web Automation Pattern<a class="headerlink" href="#web-automation-pattern" title="Permanent link">&para;</a></h4>
<p>The Flow system excels at managing complex web automation tasks, as demonstrated by the Playwright integration examples:</p>
<pre><code class="language-python">class Flow__Playwright__Operation(Type_Safe):
    playwright_serverless : Playwright__Serverless
    url                   : str = 'https://example.com'

    @task()
    def check_config(self) -&gt; Browser:
        print('checking config')

    @task()
    async def launch_browser(self) -&gt; Browser:
        await self.playwright_serverless.launch()

    @task()
    async def new_page(self) -&gt; Browser:
        await self.playwright_serverless.new_page()

    @task()
    async def perform_operation(self, flow_data: dict) -&gt; None:
        # Operation-specific logic here
        pass

    @flow()
    async def execute(self) -&gt; Flow:
        self.check_config()
        await self.launch_browser()
        await self.new_page()
        await self.perform_operation()
        return 'all done'
</code></pre>
<p>This pattern showcases several important concepts:
1. <strong>Resource Management</strong>: Browser lifecycle handling
2. <strong>Flow Data</strong>: Using flow_data for sharing state
3. <strong>Async Operations</strong>: Managing asynchronous browser interactions
4. <strong>Error Handling</strong>: Graceful handling of browser operations
5. <strong>Task Sequencing</strong>: Logical ordering of operations</p>
<h4 id="data-transformation-pattern">Data Transformation Pattern<a class="headerlink" href="#data-transformation-pattern" title="Permanent link">&para;</a></h4>
<p>The Flow system can effectively manage data transformation pipelines, as shown in the screenshot and PDF generation examples:</p>
<pre><code class="language-python">class Flow__Data__Transform(Type_Safe):
    @task()
    async def capture_data(self, flow_data: dict) -&gt; None:
        raw_data = await self.source.get_data()
        flow_data['raw_data'] = raw_data

    @task()
    def transform_data(self, flow_data: dict) -&gt; None:
        raw_data = flow_data['raw_data']
        transformed = self.transform_function(raw_data)
        flow_data['transformed'] = transformed

    @flow()
    async def execute_transformation(self) -&gt; Flow:
        await self.capture_data()
        self.transform_data()
        return 'transformation complete'
</code></pre>
<p>Key aspects of this pattern:
1. <strong>Data Flow</strong>: Clear data movement between tasks
2. <strong>State Management</strong>: Using flow_data for intermediate results
3. <strong>Transform Steps</strong>: Clearly defined transformation stages
4. <strong>Type Safety</strong>: Leveraging Type_Safe for robust typing</p>
<h3 id="flow-composition-and-inheritance">Flow Composition and Inheritance<a class="headerlink" href="#flow-composition-and-inheritance" title="Permanent link">&para;</a></h3>
<p>The provided examples demonstrate effective patterns for flow composition and inheritance:</p>
<pre><code class="language-python">class BaseWebFlow(Type_Safe):
    @task()
    async def common_setup(self):
        # Shared setup logic
        pass

class SpecificWebFlow(BaseWebFlow):
    @task()
    async def specific_operation(self):
        # Specific operation logic
        pass

    @flow()
    async def execute(self) -&gt; Flow:
        await self.common_setup()
        await self.specific_operation()
        return 'operation complete'
</code></pre>
<p>Benefits of this approach:
1. <strong>Code Reuse</strong>: Common operations shared across flows
2. <strong>Consistency</strong>: Standardized handling of common operations
3. <strong>Maintainability</strong>: Clear separation of concerns
4. <strong>Extensibility</strong>: Easy to add new specialized flows</p>
<h3 id="error-handling">Error Handling<a class="headerlink" href="#error-handling" title="Permanent link">&para;</a></h3>
<p>The error handling system provides flexible control over how errors are managed at both Flow and Task levels.</p>
<pre><code class="language-python"># Task-level error handling
@task(raise_on_error=False)
def task_continues_on_error():
    # This error won't stop the flow
    raise ValueError(&quot;Task error&quot;)

# Flow-level error handling
flow_config = Flow_Run__Config(raise_flow_error=False)
@flow(flow_config=flow_config)
def flow_continues_on_error():
    # Flow continues despite task errors
    task_continues_on_error()
    return &quot;Flow completed despite error&quot;
</code></pre>
<p>Error handling features:
1. Configurable error propagation
2. Detailed error logging
3. Error context preservation
4. Flexible recovery options</p>
<h3 id="event-listening">Event Listening<a class="headerlink" href="#event-listening" title="Permanent link">&para;</a></h3>
<p>The event system enables real-time monitoring and reaction to Flow and Task execution events.</p>
<pre><code class="language-python">def event_listener(event: Flow_Run__Event):
    # Handle different event types
    if event.event_type == Flow_Run__Event_Type.TASK_START:
        print(f&quot;Task started: {event.event_data.task_name}&quot;)
    elif event.event_type == Flow_Run__Event_Type.FLOW_MESSAGE:
        print(f&quot;Log message: {event.event_data.data['message_data']['message']}&quot;)

# Register the listener
flow_events.event_listeners.append(event_listener)
</code></pre>
<p>Event system features:
1. Real-time event notification
2. Structured event data
3. Multiple listener support
4. Error-resistant event dispatch</p>
<h3 id="artifacts-and-results">Artifacts and Results<a class="headerlink" href="#artifacts-and-results" title="Permanent link">&para;</a></h3>
<p>The artifact system provides a structured way to store and track data products and results.</p>
<pre><code class="language-python">@flow()
def flow_with_artifacts(this_flow=None):
    # Store structured data as an artifact
    this_flow.add_flow_artifact(
        description=&quot;API Response&quot;,
        key=&quot;api-response&quot;,
        data={&quot;status&quot;: &quot;success&quot;},
        artifact_type=&quot;json&quot;
    )

    # Record a result
    this_flow.add_flow_result(
        key=&quot;calculation-result&quot;,
        description=&quot;Final calculation value: 42&quot;
    )
</code></pre>
<p>Artifact system features:
1. Structured data storage
2. Result tracking
3. Artifact type classification
4. Event notification</p>
<h2 id="technical-details">Technical Details<a class="headerlink" href="#technical-details" title="Permanent link">&para;</a></h2>
<h3 id="flow-lifecycle">Flow Lifecycle<a class="headerlink" href="#flow-lifecycle" title="Permanent link">&para;</a></h3>
<p>The Flow lifecycle consists of several distinct phases, each with specific responsibilities:</p>
<ol>
<li>Flow Creation</li>
<li>Instance initialization</li>
<li>Configuration application</li>
<li>Event listener setup</li>
<li>
<p>Resource preparation</p>
</li>
<li>
<p>Flow Execution</p>
</li>
<li>Event notification</li>
<li>Argument resolution</li>
<li>Task coordination</li>
<li>Result collection</li>
<li>
<p>Resource cleanup</p>
</li>
<li>
<p>Task Execution</p>
</li>
<li>Context discovery</li>
<li>Event notification</li>
<li>Dependency injection</li>
<li>Output capture</li>
<li>Error handling</li>
</ol>
<h3 id="context-discovery">Context Discovery<a class="headerlink" href="#context-discovery" title="Permanent link">&para;</a></h3>
<p>The context discovery system uses stack inspection to locate the parent Flow:</p>
<pre><code class="language-python">def find_flow(self):
    # Examine the call stack
    stack = inspect.stack()
    for frame_info in stack:
        frame = frame_info.frame
        # Look for Flow instances
        for var_name, var_value in frame.f_locals.items():
            if type(var_value) is Flow:
                return var_value
    return None
</code></pre>
<p>Context discovery features:
1. Automatic Flow location
2. Stack frame examination
3. Variable inspection
4. Robust error handling</p>
<h3 id="dependency-injection">Dependency Injection<a class="headerlink" href="#dependency-injection" title="Permanent link">&para;</a></h3>
<p>The dependency injection system automatically provides required dependencies:</p>
<p>Key features:
1. Automatic dependency resolution
2. Type-based injection
3. Named parameter matching
4. Default value support</p>
<h3 id="event-data-structure">Event Data Structure<a class="headerlink" href="#event-data-structure" title="Permanent link">&para;</a></h3>
<p>Events carry structured data about Flow and Task execution:</p>
<pre><code class="language-python">class Flow_Run__Event_Data:
    data        : dict   # Event-specific payload
    event_source: str    # Event origin
    flow_name   : str    # Flow identifier
    flow_run_id : str    # Execution identifier
    log_level   : int    # Message severity
    task_name   : str    # Task identifier
    task_run_id : str    # Task execution identifier
</code></pre>
<p>Event data features:
1. Structured information
2. Context preservation
3. Unique identification
4. Severity classification</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../../../.." class="btn btn-neutral float-left" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../../../../../dev/Python-code-formatting-guidelines/" class="btn btn-neutral float-right" title="Coding Guidelines">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../../../../.." style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../../../../../dev/Python-code-formatting-guidelines/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../../../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../../../../..";</script>
    <script src="../../../../../js/theme_extra.js"></script>
    <script src="../../../../../js/theme.js"></script>
      <script src="../../../../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
