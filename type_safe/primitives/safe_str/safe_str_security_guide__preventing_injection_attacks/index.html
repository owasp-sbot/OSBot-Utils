<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://owasp-sbot.github.io/OSBot-Utils/type_safe/primitives/safe_str/safe_str_security_guide__preventing_injection_attacks/" />
      <link rel="shortcut icon" href="../../../../img/favicon.ico" />
    <title>Safe_Str Security Guide: Preventing Injection Attacks and Data Validation - OSBot-Utils Documentation</title>
    <link rel="stylesheet" href="../../../../css/theme.css" />
    <link rel="stylesheet" href="../../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Safe_Str Security Guide: Preventing Injection Attacks and Data Validation";
        var mkdocs_page_input_path = "type_safe/primitives/safe_str/safe_str_security_guide__preventing_injection_attacks.md";
        var mkdocs_page_url = "/OSBot-Utils/type_safe/primitives/safe_str/safe_str_security_guide__preventing_injection_attacks/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../../.." class="icon icon-home"> OSBot-Utils Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Code</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" >OSBot Utils</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" >Helpers</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../../../code/osbot_utils/helpers/flows/osbot-utils-flow-system-documentation/">Flows</a>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Development</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../../../dev/Python-code-formatting-guidelines/">Coding Guidelines</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Type Safety</a>
    <ul>
                <li class="toctree-l2"><a class="" href="../../../../dev/type_safe/python-type-safety-frameworks-compared.md">Frameworks Compared</a>
                </li>
                <li class="toctree-l2"><a class="" href="../../../../dev/type_safe/type-safe-technical-documentation.md">Technical Documentation</a>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../..">OSBot-Utils Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Safe_Str Security Guide: Preventing Injection Attacks and Data Validation</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="safe_str-security-guide-preventing-injection-attacks-and-data-validation">Safe_Str Security Guide: Preventing Injection Attacks and Data Validation<a class="headerlink" href="#safe_str-security-guide-preventing-injection-attacks-and-data-validation" title="Permanent link">&para;</a></h1>
<h2 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h2>
<p>Safe_Str is designed with security as its primary goal. This guide demonstrates how Safe_Str types prevent common security vulnerabilities and provides best practices for using them in security-critical applications.</p>
<h2 id="threat-model-and-protection">Threat Model and Protection<a class="headerlink" href="#threat-model-and-protection" title="Permanent link">&para;</a></h2>
<h3 id="what-safe_str-protects-against">What Safe_Str Protects Against<a class="headerlink" href="#what-safe_str-protects-against" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Threat</th>
<th>Protection Mechanism</th>
<th>Safe_Str Types</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SQL Injection</strong></td>
<td>Character filtering, pattern validation</td>
<td>Safe_Str (custom)</td>
</tr>
<tr>
<td><strong>Command Injection</strong></td>
<td>Shell metacharacter removal</td>
<td>Safe_Str (custom)</td>
</tr>
<tr>
<td><strong>Path Traversal</strong></td>
<td>Directory separator filtering</td>
<td>Safe_Str__File__Name</td>
</tr>
<tr>
<td><strong>XSS Attacks</strong></td>
<td>HTML/JS character sanitization</td>
<td>Safe_Str__Text, Safe_Str__Html</td>
</tr>
<tr>
<td><strong>Header Injection</strong></td>
<td>CRLF removal</td>
<td>Safe_Str__Http__* types</td>
</tr>
<tr>
<td><strong>URL Manipulation</strong></td>
<td>URL validation and sanitization</td>
<td>Safe_Str__Url</td>
</tr>
<tr>
<td><strong>IP Spoofing</strong></td>
<td>IP address validation</td>
<td>Safe_Str__IP_Address</td>
</tr>
<tr>
<td><strong>Format String Attacks</strong></td>
<td>Character restrictions</td>
<td>Safe_Str (custom)</td>
</tr>
</tbody>
</table>
<h2 id="sql-injection-prevention">SQL Injection Prevention<a class="headerlink" href="#sql-injection-prevention" title="Permanent link">&para;</a></h2>
<h3 id="the-vulnerability">The Vulnerability<a class="headerlink" href="#the-vulnerability" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># DANGEROUS - SQL Injection vulnerable
def get_user_unsafe(username):
    query = f&quot;SELECT * FROM users WHERE username = '{username}'&quot;
    return db.execute(query)

# Attack vector
get_user_unsafe(&quot;admin' OR '1'='1&quot;)  # Returns all users!
</code></pre>
<h3 id="safe_str-protection">Safe_Str Protection<a class="headerlink" href="#safe_str-protection" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">import re
from osbot_utils.type_safe.primitives.safe_str.Safe_Str import Safe_Str

class Safe_Str__SQL_Identifier(Safe_Str):
    &quot;&quot;&quot;Safe SQL identifier - table/column names only&quot;&quot;&quot;
    regex = re.compile(r'[^a-zA-Z0-9_]')
    max_length = 64  # MySQL identifier limit
    allow_empty = False
    trim_whitespace = True

class Safe_Str__SQL_Value(Safe_Str):
    &quot;&quot;&quot;Safe SQL value - alphanumeric and basic punctuation&quot;&quot;&quot;
    regex = re.compile(r&quot;[^a-zA-Z0-9\s\-_.,]&quot;)
    max_length = 255
    strict_validation = False  # Sanitize instead of reject

# Safe usage
def get_user_safe(username):
    safe_username = Safe_Str__SQL_Value(username)
    # Even with string formatting, injection is prevented
    query = f&quot;SELECT * FROM users WHERE username = '{safe_username}'&quot;
    return db.execute(query)

# Attack attempt is neutralized
get_user_safe(&quot;admin' OR '1'='1&quot;)
# Sanitized to: &quot;admin__OR__1___1&quot;
# Query becomes: SELECT * FROM users WHERE username = 'admin__OR__1___1'
</code></pre>
<h3 id="best-practice-defense-in-depth">Best Practice: Defense in Depth<a class="headerlink" href="#best-practice-defense-in-depth" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">class UserRepository(Type_Safe):
    table_name: Safe_Str__SQL_Identifier

    def get_user(self, username: Safe_Str__SQL_Value):
        # Layer 1: Safe_Str sanitization
        # Layer 2: Parameterized queries
        query = &quot;SELECT * FROM users WHERE username = ?&quot;
        return db.execute(query, [str(username)])

    def get_from_table(self, table: Safe_Str__SQL_Identifier):
        # Safe for dynamic table names (where parameterization doesn't work)
        query = f&quot;SELECT * FROM {table}&quot;
        return db.execute(query)
</code></pre>
<h2 id="command-injection-prevention">Command Injection Prevention<a class="headerlink" href="#command-injection-prevention" title="Permanent link">&para;</a></h2>
<h3 id="the-vulnerability_1">The Vulnerability<a class="headerlink" href="#the-vulnerability_1" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># DANGEROUS - Command injection vulnerable
import os

def process_file_unsafe(filename):
    os.system(f&quot;cat {filename}&quot;)

# Attack vector
process_file_unsafe(&quot;file.txt; rm -rf /&quot;)  # Executes deletion!
</code></pre>
<h3 id="safe_str-protection_1">Safe_Str Protection<a class="headerlink" href="#safe_str-protection_1" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">class Safe_Str__Shell_Arg(Safe_Str):
    &quot;&quot;&quot;Safe shell argument - no shell metacharacters&quot;&quot;&quot;
    regex = re.compile(r'[^a-zA-Z0-9\-_./]')
    max_length = 255
    allow_empty = False

    def __new__(cls, value):
        # Additional validation for suspicious patterns
        if value and ('..' in value or value.startswith('/')):
            raise ValueError(&quot;Absolute paths and parent directory access not allowed&quot;)
        return super().__new__(cls, value)

def process_file_safe(filename):
    safe_filename = Safe_Str__Shell_Arg(filename)
    # Even with os.system, injection is prevented
    os.system(f&quot;cat {safe_filename}&quot;)

# Attack neutralized
try:
    process_file_safe(&quot;file.txt; rm -rf /&quot;)
except ValueError:
    # Sanitized to: &quot;file.txt_rm_-rf_&quot;
    pass
</code></pre>
<h3 id="safer-alternative-with-subprocess">Safer Alternative with subprocess<a class="headerlink" href="#safer-alternative-with-subprocess" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">import subprocess

def process_file_best(filename):
    safe_filename = Safe_Str__Shell_Arg(filename)
    # Best practice: use subprocess with list arguments
    result = subprocess.run(
        [&quot;cat&quot;, str(safe_filename)],
        capture_output=True,
        text=True
    )
    return result.stdout
</code></pre>
<h2 id="path-traversal-prevention">Path Traversal Prevention<a class="headerlink" href="#path-traversal-prevention" title="Permanent link">&para;</a></h2>
<h3 id="the-vulnerability_2">The Vulnerability<a class="headerlink" href="#the-vulnerability_2" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># DANGEROUS - Path traversal vulnerable
def read_user_file_unsafe(user_id, filename):
    path = f&quot;/data/users/{user_id}/{filename}&quot;
    with open(path, 'r') as f:
        return f.read()

# Attack vector
read_user_file_unsafe(&quot;123&quot;, &quot;../../etc/passwd&quot;)  # Reads system file!
</code></pre>
<h3 id="safe_str-protection_2">Safe_Str Protection<a class="headerlink" href="#safe_str-protection_2" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.type_safe.primitives.safe_str.Safe_Str__File__Name import Safe_Str__File__Name
from osbot_utils.type_safe.primitives.safe_str.Safe_Str__File__Path import Safe_Str__File__Path
from pathlib import Path

class SecureFileAccess(Type_Safe):
    base_directory: Safe_Str__File__Path

    def read_user_file(self, user_id: str, filename: str):
        # Sanitize filename - removes directory separators
        safe_filename = Safe_Str__File__Name(filename)
        # &quot;../../etc/passwd&quot; becomes &quot;___etc_passwd&quot;

        # Construct safe path
        user_dir = Safe_Str__File__Path(f&quot;{self.base_directory}/{user_id}&quot;)
        full_path = Path(str(user_dir)) / str(safe_filename)

        # Additional check: ensure path is within base directory
        try:
            full_path = full_path.resolve()
            base = Path(str(self.base_directory)).resolve()
            if not str(full_path).startswith(str(base)):
                raise ValueError(&quot;Path traversal attempt detected&quot;)
        except (ValueError, OSError) as e:
            raise ValueError(f&quot;Invalid file path: {e}&quot;)

        with open(full_path, 'r') as f:
            return f.read()

# Safe usage
file_access = SecureFileAccess(base_directory=&quot;/data/users&quot;)
content = file_access.read_user_file(&quot;123&quot;, &quot;profile.json&quot;)  # ✓ Safe

# Attack prevented
try:
    content = file_access.read_user_file(&quot;123&quot;, &quot;../../etc/passwd&quot;)
    # Filename becomes &quot;___etc_passwd&quot;, path traversal prevented
except FileNotFoundError:
    pass  # File doesn't exist in safe directory
</code></pre>
<h2 id="cross-site-scripting-xss-prevention">Cross-Site Scripting (XSS) Prevention<a class="headerlink" href="#cross-site-scripting-xss-prevention" title="Permanent link">&para;</a></h2>
<h3 id="the-vulnerability_3">The Vulnerability<a class="headerlink" href="#the-vulnerability_3" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># DANGEROUS - XSS vulnerable
def render_comment_unsafe(comment):
    return f&quot;&lt;div class='comment'&gt;{comment}&lt;/div&gt;&quot;

# Attack vector
html = render_comment_unsafe(&quot;&lt;script&gt;alert('XSS')&lt;/script&gt;&quot;)
# Browser executes the script!
</code></pre>
<h3 id="safe_str-protection_3">Safe_Str Protection<a class="headerlink" href="#safe_str-protection_3" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.type_safe.primitives.safe_str.Safe_Str__Text import Safe_Str__Text
from osbot_utils.helpers.safe_str.http.Safe_Str__Html import Safe_Str__Html
import html

class Safe_Str__Comment(Safe_Str):
    &quot;&quot;&quot;User comments - no HTML allowed&quot;&quot;&quot;
    regex = re.compile(r'[&lt;&gt;\&quot;\'&amp;]')  # Remove HTML special chars
    max_length = 1000
    replacement_char = ''  # Remove instead of replace

class ContentRenderer(Type_Safe):

    def render_comment_safe(self, comment: str) -&gt; str:
        # Option 1: Strip HTML characters
        safe_comment = Safe_Str__Comment(comment)
        return f&quot;&lt;div class='comment'&gt;{safe_comment}&lt;/div&gt;&quot;

    def render_comment_escaped(self, comment: str) -&gt; str:
        # Option 2: HTML escape (preserves but neutralizes)
        safe_text = Safe_Str__Text(comment)
        escaped = html.escape(str(safe_text))
        return f&quot;&lt;div class='comment'&gt;{escaped}&lt;/div&gt;&quot;

    def render_rich_content(self, content: str) -&gt; str:
        # Option 3: Allow some HTML but sanitize
        safe_html = Safe_Str__Html(content)
        # Additional sanitization with a library like bleach
        return f&quot;&lt;div class='content'&gt;{safe_html}&lt;/div&gt;&quot;

renderer = ContentRenderer()

# XSS attempts are neutralized
comment = &quot;&lt;script&gt;alert('XSS')&lt;/script&gt;&quot;

# Method 1: Strips tags completely
result1 = renderer.render_comment_safe(comment)
# Returns: &lt;div class='comment'&gt;scriptalert('XSS')/script&lt;/div&gt;

# Method 2: Escapes HTML
result2 = renderer.render_comment_escaped(comment)
# Returns: &lt;div class='comment'&gt;&amp;lt;script&amp;gt;alert('XSS')&amp;lt;/script&amp;gt;&lt;/div&gt;
</code></pre>
<h2 id="http-header-injection-prevention">HTTP Header Injection Prevention<a class="headerlink" href="#http-header-injection-prevention" title="Permanent link">&para;</a></h2>
<h3 id="the-vulnerability_4">The Vulnerability<a class="headerlink" href="#the-vulnerability_4" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># DANGEROUS - Header injection vulnerable
def set_cookie_unsafe(name, value):
    response.headers['Set-Cookie'] = f&quot;{name}={value}&quot;

# Attack vector
set_cookie_unsafe(&quot;user&quot;, &quot;admin\r\nX-Injected-Header: malicious&quot;)
# Injects additional header!
</code></pre>
<h3 id="safe_str-protection_4">Safe_Str Protection<a class="headerlink" href="#safe_str-protection_4" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.helpers.safe_str.http.Safe_Str__Http__Content_Type import Safe_Str__Http__Content_Type

class Safe_Str__Cookie_Value(Safe_Str):
    &quot;&quot;&quot;Safe cookie value - no control characters&quot;&quot;&quot;
    regex = re.compile(r'[\r\n\x00-\x1f\x7f;,\\&quot;]')
    max_length = 4096  # Common cookie size limit
    trim_whitespace = True

class Safe_Str__Header_Value(Safe_Str):
    &quot;&quot;&quot;Generic safe HTTP header value&quot;&quot;&quot;
    regex = re.compile(r'[\r\n\x00-\x1f\x7f]')
    max_length = 8192
    trim_whitespace = True

class HTTPResponse(Type_Safe):
    headers: Dict[str, Safe_Str__Header_Value]

    def set_cookie(self, name: str, value: str):
        safe_name = Safe_Str__Cookie_Value(name)
        safe_value = Safe_Str__Cookie_Value(value)

        cookie_header = f&quot;{safe_name}={safe_value}; HttpOnly; Secure; SameSite=Strict&quot;
        self.headers['Set-Cookie'] = Safe_Str__Header_Value(cookie_header)

    def set_content_type(self, content_type: str):
        safe_ct = Safe_Str__Http__Content_Type(content_type)
        self.headers['Content-Type'] = safe_ct

# Safe usage
response = HTTPResponse()
response.set_cookie(&quot;user&quot;, &quot;admin\r\nX-Injected: bad&quot;)
# CRLF characters are removed, injection prevented
</code></pre>
<h2 id="url-manipulation-prevention">URL Manipulation Prevention<a class="headerlink" href="#url-manipulation-prevention" title="Permanent link">&para;</a></h2>
<h3 id="the-vulnerability_5">The Vulnerability<a class="headerlink" href="#the-vulnerability_5" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># DANGEROUS - Open redirect vulnerable
def redirect_unsafe(url):
    return flask.redirect(url)

# Attack vector
redirect_unsafe(&quot;javascript:alert('XSS')&quot;)
redirect_unsafe(&quot;//evil.com&quot;)
</code></pre>
<h3 id="safe_str-protection_5">Safe_Str Protection<a class="headerlink" href="#safe_str-protection_5" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">from osbot_utils.type_safe.primitives.safe_str.Safe_Str__Url import Safe_Str__Url
from urllib.parse import urlparse

class Safe_Str__Redirect_Url(Safe_Str__Url):
    &quot;&quot;&quot;Safe redirect URL - only HTTPS to known domains&quot;&quot;&quot;

    def __new__(cls, value):
        # First apply parent sanitization
        safe_url = super().__new__(cls, value)

        # Parse and validate
        parsed = urlparse(str(safe_url))

        # Only allow HTTPS
        if parsed.scheme not in ['https']:
            raise ValueError(&quot;Only HTTPS URLs allowed for redirects&quot;)

        # Whitelist of allowed domains
        allowed_domains = ['example.com', 'app.example.com']
        if parsed.netloc not in allowed_domains:
            raise ValueError(f&quot;Domain {parsed.netloc} not in whitelist&quot;)

        return safe_url

class SecureRedirect(Type_Safe):

    def redirect(self, url: str):
        try:
            safe_url = Safe_Str__Redirect_Url(url)
            return flask.redirect(str(safe_url))
        except ValueError as e:
            # Log potential attack
            logger.warning(f&quot;Blocked redirect attempt: {e}&quot;)
            # Redirect to safe default
            return flask.redirect(&quot;https://example.com/&quot;)

# Attack prevented
redirector = SecureRedirect()
redirector.redirect(&quot;javascript:alert('XSS')&quot;)  # Blocked
redirector.redirect(&quot;//evil.com&quot;)                # Blocked
redirector.redirect(&quot;https://example.com/page&quot;)  # ✓ Allowed
</code></pre>
<h2 id="input-validation-best-practices">Input Validation Best Practices<a class="headerlink" href="#input-validation-best-practices" title="Permanent link">&para;</a></h2>
<h3 id="1-layer-your-defenses">1. Layer Your Defenses<a class="headerlink" href="#1-layer-your-defenses" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">class SecureUserInput(Type_Safe):
    &quot;&quot;&quot;Multi-layer input validation&quot;&quot;&quot;

    # Layer 1: Type-safe attributes
    username: Safe_Str__Username
    email: Safe_Str__Email
    bio: Safe_Str__Text

    # Layer 2: Business logic validation
    def validate(self):
        if len(self.username) &lt; 3:
            raise ValueError(&quot;Username too short&quot;)

        if self.email.count('@') != 1:
            raise ValueError(&quot;Invalid email format&quot;)

        # Check for prohibited words in bio
        prohibited = ['spam', 'viagra', 'casino']
        bio_lower = str(self.bio).lower()
        for word in prohibited:
            if word in bio_lower:
                raise ValueError(f&quot;Prohibited content detected&quot;)

    # Layer 3: Rate limiting (external)
    # Layer 4: CAPTCHA verification (external)
</code></pre>
<h3 id="2-fail-securely">2. Fail Securely<a class="headerlink" href="#2-fail-securely" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">class SafeInputHandler:

    def process_input(self, user_input: str, input_type: str):
        &quot;&quot;&quot;Fail securely with safe defaults&quot;&quot;&quot;

        try:
            if input_type == &quot;username&quot;:
                return Safe_Str__Username(user_input)
            elif input_type == &quot;email&quot;:
                return Safe_Str__Email(user_input)
            elif input_type == &quot;url&quot;:
                return Safe_Str__Url(user_input)
            else:
                # Unknown type - use most restrictive
                return Safe_Str(user_input)

        except ValueError as e:
            # Log the attempt
            logger.warning(f&quot;Invalid input rejected: {e}&quot;)

            # Return safe default or raise
            if input_type == &quot;username&quot;:
                return Safe_Str__Username(&quot;anonymous&quot;)
            else:
                raise  # Reject the request
</code></pre>
<h3 id="3-context-aware-validation">3. Context-Aware Validation<a class="headerlink" href="#3-context-aware-validation" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">class ContextAwareSanitizer(Type_Safe):

    def sanitize_for_context(self, data: str, context: str) -&gt; str:
        &quot;&quot;&quot;Apply different sanitization based on usage context&quot;&quot;&quot;

        if context == &quot;html_display&quot;:
            # Most restrictive for HTML
            return Safe_Str__Text(data)

        elif context == &quot;sql_query&quot;:
            # SQL-safe characters only
            return Safe_Str__SQL_Value(data)

        elif context == &quot;file_system&quot;:
            # File system safe
            return Safe_Str__File__Name(data)

        elif context == &quot;shell_command&quot;:
            # Shell-safe characters
            return Safe_Str__Shell_Arg(data)

        elif context == &quot;json_value&quot;:
            # JSON-safe (escape quotes, newlines)
            class Safe_Str__JSON(Safe_Str):
                regex = re.compile(r'[&quot;\\\n\r\t]')
            return Safe_Str__JSON(data)

        else:
            # Default to strictest
            return Safe_Str(data)
</code></pre>
<h3 id="4-audit-and-logging">4. Audit and Logging<a class="headerlink" href="#4-audit-and-logging" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">import logging
from datetime import datetime

class AuditedSafeInput(Type_Safe):
    &quot;&quot;&quot;Input validation with audit trail&quot;&quot;&quot;

    def validate_with_audit(self, 
                           input_value: str, 
                           input_type: type,
                           user_id: str) -&gt; Safe_Str:
        &quot;&quot;&quot;Validate input and log all attempts&quot;&quot;&quot;

        start_time = datetime.now()
        success = False
        sanitized_value = None

        try:
            # Attempt validation
            if input_type == Safe_Str__Email:
                sanitized_value = Safe_Str__Email(input_value)
            elif input_type == Safe_Str__Username:
                sanitized_value = Safe_Str__Username(input_value)
            else:
                sanitized_value = Safe_Str(input_value)

            success = True
            return sanitized_value

        except ValueError as e:
            # Log validation failure
            logging.warning(
                &quot;INPUT_VALIDATION_FAILED&quot;,
                extra={
                    'user_id': user_id,
                    'input_type': input_type.__name__,
                    'input_length': len(input_value),
                    'error': str(e),
                    'timestamp': start_time.isoformat()
                }
            )
            raise

        finally:
            # Always log attempt
            logging.info(
                &quot;INPUT_VALIDATION_ATTEMPT&quot;,
                extra={
                    'user_id': user_id,
                    'input_type': input_type.__name__,
                    'success': success,
                    'original_length': len(input_value),
                    'sanitized_length': len(str(sanitized_value)) if sanitized_value else 0,
                    'duration_ms': (datetime.now() - start_time).total_seconds() * 1000
                }
            )
</code></pre>
<h2 id="security-checklist">Security Checklist<a class="headerlink" href="#security-checklist" title="Permanent link">&para;</a></h2>
<p>When implementing Safe_Str for security:</p>
<ul>
<li>[ ] <strong>Choose the right Safe_Str type</strong> for your use case</li>
<li>[ ] <strong>Use strict_validation=True</strong> for critical inputs</li>
<li>[ ] <strong>Set appropriate max_length</strong> to prevent DoS</li>
<li>[ ] <strong>Layer your defenses</strong> - don't rely on Safe_Str alone</li>
<li>[ ] <strong>Test with malicious input</strong> - use OWASP testing guides</li>
<li>[ ] <strong>Log validation failures</strong> for security monitoring</li>
<li>[ ] <strong>Handle errors securely</strong> - don't expose internal details</li>
<li>[ ] <strong>Review regex patterns</strong> - ensure they're not too permissive</li>
<li>[ ] <strong>Keep Safe_Str types updated</strong> as threats evolve</li>
<li>[ ] <strong>Document security assumptions</strong> in your code</li>
</ul>
<h2 id="common-mistakes-to-avoid">Common Mistakes to Avoid<a class="headerlink" href="#common-mistakes-to-avoid" title="Permanent link">&para;</a></h2>
<h3 id="1-dont-trust-safe_str-alone">1. Don't Trust Safe_Str Alone<a class="headerlink" href="#1-dont-trust-safe_str-alone" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># BAD - Safe_Str is not a complete security solution
def execute_query_bad(table_name):
    safe_table = Safe_Str__SQL_Identifier(table_name)
    # Still vulnerable if database user has too many permissions
    return db.execute(f&quot;SELECT * FROM {safe_table}&quot;)

# GOOD - Defense in depth
def execute_query_good(table_name):
    safe_table = Safe_Str__SQL_Identifier(table_name)

    # Additional validation
    allowed_tables = ['users', 'posts', 'comments']
    if str(safe_table) not in allowed_tables:
        raise ValueError(&quot;Table not in whitelist&quot;)

    # Use least-privilege database user
    # Use prepared statements where possible
    return db.execute(f&quot;SELECT * FROM {safe_table}&quot;)
</code></pre>
<h3 id="2-dont-bypass-safe_str">2. Don't Bypass Safe_Str<a class="headerlink" href="#2-dont-bypass-safe_str" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># BAD - Bypassing Safe_Str protection
user_input = Safe_Str__Username(raw_input)
# Later in code...
query = f&quot;SELECT * FROM users WHERE name = '{raw_input}'&quot;  # Used original!

# GOOD - Always use the sanitized value
user_input = Safe_Str__Username(raw_input)
query = f&quot;SELECT * FROM users WHERE name = '{user_input}'&quot;
</code></pre>
<h3 id="3-dont-mix-contexts">3. Don't Mix Contexts<a class="headerlink" href="#3-dont-mix-contexts" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># BAD - Using wrong Safe_Str type for context
html_content = Safe_Str__SQL_Value(user_input)  # Wrong type!
return f&quot;&lt;div&gt;{html_content}&lt;/div&gt;&quot;

# GOOD - Use context-appropriate type
html_content = Safe_Str__Text(user_input)
return f&quot;&lt;div&gt;{html_content}&lt;/div&gt;&quot;
</code></pre>
<h2 id="summary">Summary<a class="headerlink" href="#summary" title="Permanent link">&para;</a></h2>
<p>Safe_Str provides powerful primitives for input validation and sanitization, serving as a critical first line of defense against injection attacks. However, remember:</p>
<ol>
<li><strong>Safe_Str is one layer</strong> in a defense-in-depth strategy</li>
<li><strong>Choose the right type</strong> for your specific context</li>
<li><strong>Combine with other controls</strong> like parameterized queries, CSP headers, etc.</li>
<li><strong>Test thoroughly</strong> with known attack vectors</li>
<li><strong>Monitor and log</strong> validation failures for security insights</li>
<li><strong>Stay updated</strong> on new attack techniques and update patterns accordingly</li>
</ol>
<p>When properly implemented, Safe_Str significantly reduces the attack surface of your application by ensuring that string data conforms to expected patterns before it's used in security-sensitive contexts.</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="../../../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../../../..";</script>
    <script src="../../../../js/theme_extra.js"></script>
    <script src="../../../../js/theme.js"></script>
      <script src="../../../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
